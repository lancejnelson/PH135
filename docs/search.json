[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Scientific Computing",
    "section": "",
    "text": "Jupyter Notebook\n\n\nPython is a computer programming language available on all major platforms (Mac, Windows, Linux). Python is a scripting language which means that the computer interprets and runs your code at the moment you run it. In contrast, with a compiled language like C the code must first be converted into binary before it can run (called “compiling” the code). There are pros and cons to both types of languages. The on-the-fly interpretation of Python makes it quick and easy to write code and provides fast results for simple calculations. When codes become longer and more complex, on-the-fly interpretation becomes less efficient and execution time will be much slower than it would be with a compiled language. The pros and cons flip for a compiled language; writing code in a compiled language can be cumbersome and slow, but the execution time is typically much faster. Out of necessity, most programmers become proficient in both types of languages. Python(or another interpreted language) is used to “toy around” with your problem and build familiarity. As the complexity of the code increases the user is then forced to transition to a compiled language to get the needed speed. This is the famous “two language” problem and there is a new programming language designed to eliminate this problem by combining the pros from both into one language. (The name of the language is Julia)\nPython is free, open source software and is maintained by the non-profit Python software foundation. This is great because it means that you will always have free access to the Python language regardless of what organization or university you are affiliated with. You’ll never have to worry about not being able to use your Python code without paying for it. Another benefit of open source languages is that all of the codes developed by other people are available for anyone to inspect, modify, and use. This allows anyone to review another’s code to ensure that it does what they say it does, or to modify it to do something else. One last benefit that comes with an open source language is the community of Python users available to answer questions and provide instruction to the beginner. Answers to most questions about python are readily available on tutorial or forum websites.\n\n\n\nThe first step is to install the software (if you haven’t already). The most convenient way to install Python and also get many of the commonly-used libraries is to use an installer. I recommend Anaconda. When installing the software be sure to choose Python 3 since this is the current version. By default, Anaconda will install a suit of softwares and libraries that are commonly used. If you want to install other Python libraries, open the Anaconda-Navigator (green circle icon) and select the Environment tab on the left. Select Not Installed from the pull-down to see all of the libraries that are available to be installed. To install a library, check the box next to it and click Apply. Anaconda will take care of the rest.\n\nTo Do:\n\nInstall Anaconda\nCheck to see if the library “numpy” is installed. If not, install it.\n\n\n\n\n\nA Jupyter notebook is an electronic document designed to support interactive data processing, analysis, and visualization in an easily shared format. A Jupyter notebook can contain live code, math equations, explanatory text, and the output of codes (numbers, plots, graphics, etc..). To launch a Jupyter notebook, first open Anaconda-Navigator (green circle icon) and click the Launch button under JupyterLab. Jupyter can also be launched from the command line by typing jupyter-lab. The jupyter notebook will launch in your default web browser, but it is not a website. From here you can select an already existing Jupyter notebook, denoted by the orange icons and the .ipynb extension, or create a new notebook by clicking New from the File menu.\n\nTo Do:\n\nOn iLearn, find the module entitled “Jupyter Notebooks” and download the file “Intro.ipynb”.\nLaunch JupyterLab as explained above.\nOpen “Intro.ipynb” that you downloaded in step 1 and continue reading this book in the jupyter notebook.\n\n\n\n\nThere are two types of “cells” in a Jupyter notebook: code cells and text cells (also called Markdown cell). Code cells contain “live” Python code that can be run inside of the notebook with any output appearing directly below it. An example of a code cell is given below:\naccel = 9.8\ndt = 0.5\nvi = 10\nvf = vi + a * dt\nprint(vf)\nMarkdown cells are designed to contain explanatory information about what is happening inside of the code cells. They can contain text, math equations, and images. Markdown cells support markdown, html, and \\(\\mathrm{\\LaTeX}\\) (for generating pretty math equations).\nBoth markdown and code cells can be executed by either selecting Run Selected Cells in the Run menu, by clicking the Play icon at the top of the notebook, or by using the Shift-Return shortcut when your cursor is in the desired cell.\n\n\n\nOften you will want to include math equations as part of your explanation/text. Below is an example of what your math should and should not look like.\n\n\\(|\\vec{v}| = \\sqrt{v_x^2 + v_y^2}\\) (like this)\n\nv = sqrt(vx^2 + vy^2) (not like this)\n\nTo make your math equations look like the first example, you must enclose your math equation in “$$”, one pair at the beginnning of the equation and one pair at the end. Enclosing your expression in double dollar signs will put the expression on its own line. To place the expression in the middle of a sentence (inline) you’ll need to enclose the expression in single dollar signs. To generate the math symbols that often show up in equations, you’ll need to know the correct syntax. A table of commonly used math symbols is given below.\n\n\n\n\n\n\n\n\nMath symbol\nExample\n\\(\\mathrm{\\LaTeX}\\) syntax\n\n\n\n\nSubscript\n\\(v_x\\)\nv_x\n\n\nPowers\n\\(v^2\\)\nv^2\n\n\nPowers with more than one digit\n\\(v^{10}\\)\nv^{10}\n\n\nSquare root\n\\(\\sqrt{a + b}\\)\n\\sqrt{a + b}\n\n\nFractions\n\\(\\frac{a}{b}\\)\n\\frac{a}{b}\n\n\nVectors\n\\(\\vec{x}\\)\n\\vec{x}\n\n\nIntegrals\n\\(\\int x^2 dx\\)\n\\int x^2 dx\n\n\nPartial Derivatives\n\\({\\partial f \\over \\partial x}\\)\n{\\partial f \\over \\partial x}\n\n\nSummations\n\\(\\sum_{i = 1}^{10} x_i^2\\)\n\\sum_{i = 1}^{10} x_i^2\n\n\nInfinity\n\\(\\infty\\)\n\\infty\n\n\n\nYou can include Greek letters in your expressions if you know the corresponding syntax. The table below shows some of the more common Greek letters used in physics.\n\n\n\nGreek Letter\n\\(\\mathrm{\\LaTeX}\\) syntax\n\n\n\n\n\\(\\alpha\\)\n\\alpha\n\n\n\\(\\beta\\)\n\\beta\n\n\n\\(\\gamma\\)\n\\gamma\n\n\n\\(\\Delta\\)\n\\Delta\n\n\n\\(\\epsilon\\)\n\\epsilon\n\n\n\nA more comprehensive list of math symbols available can be found here\n\n\n\nTables are often useful for presenting data. You can make a table in a jupyter notebook using the following syntax\n|t (s)       | v (m/s)     |\n|------------|-------------|\n| 0          | 10          |\n| 1.2        | 22          |\n| 2.3        | 25          |\n| 3.0        | 38          |\n| 5.5        | 56          |\nwhich will generate the following table:\n\n\n\nt (s)\nv (m/s)\n\n\n\n\n0\n10\n\n\n1.2\n22\n\n\n2.3\n25\n\n\n3.0\n38\n\n\n5.5\n56\n\n\n\n\n\n\nNavigating a Jupyter notebook is fairly straightforward but there are a few handy shortcuts/hotkeys that will make navigation quicker and your workflow more efficient. When working in a Jupyter notebook, you are always operating in one of two modes: edit mode or navigate mode. In edit mode you can make modifications to the text or code in a cell and in navigate mode you can add/delete cells and modify the cell type. If you can see a blinking cursor in one of the cells you are in edit mode. Otherwise you are in navigate mode. To exit edit mode, simply press the esc key and you will enter navigate mode. To exit navigate mode, simply press the enter key and you will enter edit mode for the cell you were focused on. (You can also double click on a cell with your mouse to enter edit mode.) The shift + enter key sequence will “execute” a cell and produce the associated output. For text cells, executing just means to render the text in a nicely formatted fashion. “Executing” a code cell will actually execute the code block contained in the cell. You also enter navigate mode every time you execute a cell using the shift + enter key sequence. A summary of these shortcuts is given below:\n\nUp/down arrows - Navigate to different cells in the notebook.\nY - turns a text cell into a code cell.\nM - turns a code cell into a text cell.\nA - inserts a new cell above the current cell.\nB - inserts a new cell below the current cell.\nX - deletes the current cell.\nenter - enters edit mode.\nshift + enter - execute a cell.\nesc - enter navigate mode.\n\n\n\n\n\n\n\nJupyter notebooks in this class will be a nice mix of text cells (explanation) and code cells (examples). You will soon learn that code cells produce no output unless you explicitly tell them to using a print statement (similar to the one you used above). When you encounter a code cell, you should feel free to make modifications and additions to the cell until you fully understand how the code works.\n\n\n\nComments are a way to describe what each section of code does and makes it easier for you and others to understand the code. It may seem clear what each section of code does as you write it, but after a week, month or longer, it is unlikely to be obvious. Paul Wilson of the University of Wisconsin at Madison is quoted as saying, “Your closest collaborator is you six months ago, but you don’t reply to emails.” Comment your code now so that you are not confused later.\nThere are several ways to add comments to your code:\n\nUse # to start a comment. Everything on the line that follows will be ignored.\nFor longer comments that will span several lines, use triple double quotes to begin and end the comment (\"\"\")\n\nThe cell below illustrates these two ways to make comments:\n# Speed of light in a vacuum\nc = 3e8\n\nv = 300 # Speed of sound in air\n\n\"\"\"\nThe variables below are the initial conditions for a cannon\nlaunching a ball at a 30 degree angle with an initial speed of\n50 m/s.  The initial height of the cannon ball is 1000 m\n\"\"\"\nv = 50\ntheta = 30\nh_i = 1000\n\nTo Do:\n\nExecute the code block below and verify that no output is produced.\nAdd print statements that help you see the result of the calculation.\nAdd simple comments next to each line explaining the code.\n\n\na = 2 \nb = 3 \nc = a**b\n\n\n\n\n\nPerform the following actions using the shortcuts above:\n\nAdd a cell below this one.\nTurn the cell into a code cell (observe the distinct appearance of code cells).\nIn the code cell, calculate the Stefan-Boltzmann constant using the equation given in the first column of the table found here. Add a print statement so you can verify that you did it correctly.\nExecute the cell using shift + enter. Observe the output.\nCreate another cell just below the code cell you just created.\nTurn it into a text/markdown cell if it isn’t already.\nUsing \\(\\mathrm{\\LaTeX}\\) syntax, write the equation from the table that you used to peform the calculation.\n“Execute” the cell and observe the new output.\n\nRecreate the first three columns of your top 10 favorite physical constants found here (same table as given in exercise 1). Pick constants that have Greek letters and fun mathematical equations associated with them."
  },
  {
    "objectID": "chapters/variables.html",
    "href": "chapters/variables.html",
    "title": "2  Variables and Numbers",
    "section": "",
    "text": "Jupyter Notebook"
  },
  {
    "objectID": "chapters/variables.html#variables",
    "href": "chapters/variables.html#variables",
    "title": "2  Variables and Numbers",
    "section": "2.1 Variables",
    "text": "2.1 Variables\nWhen performing mathematical operations, it is often desirable to store the values in variables for later use instead of manually typing them back in each time you need to use them. This will reduce effort because small changes to variables can automatically propagate through your calculations.\nAttaching a value to a variable is called assignment and is performed using the equal sign (=), as demonstrated in the cell below:\na = 5.0\nb = 3\nc = a + b\n\n2.1.1 Variable naming convention\nThere are some rules for allowed variable names in Python. They are as follows:\n\nVariable names must begin with a letter or an underscore (_)\nVariables names must only contain letters, numbers, and underscores.\nVariable names cannot contain spaces.\nVariables names cannot be a word reserved by Python for something else. These words are:\n\n\n\n\n\nPython\nreserved\nwords\n\n\n\n\n\nand\nas\nassert\nbreak\nclass\n\n\ncontinue\ndef\ndel\nelif\nelse\n\n\nexcept\nFalse\nfinally\nfor\nfrom\n\n\nglobal\nif\nimport\nin\nis\n\n\nlambda\nNone\nnonlocal\nnot\nor\n\n\npass\nraise\nreturn\nTrue\ntry\n\n\nwhy\nwith\nyield\n\n\n\n\n\nThe cell below contains some allowed variable names and some that are not allowed.\n\nTo Do:\n\nDetermine which variable names are allowed and which are not in the cell below.\nWhat does Python do if you try to define a variable using a name that is not allowed?\n\n\nmy1variable = 3\n1stvariables = 2\na big constant = 3\na_big_constant = 1e8\nIt is also a good practice to make variable names meaningful. For example, in the cell below we calculate \\(E = mc^2\\) using two choices for variable assignments. In one case, it is easy to determine what the calculation is and in the other it isn’t.\n# Good Variable Names\nmass_kg = 1.6\nlight_speed = 3.0e8\nenergy = mass_kg * light_speed**2\n\n\n# Poor Variable Names\na = 1.6\nb = 3.0e8\nc = a * b**2"
  },
  {
    "objectID": "chapters/variables.html#numbers-integers-and-floats",
    "href": "chapters/variables.html#numbers-integers-and-floats",
    "title": "2  Variables and Numbers",
    "section": "2.2 Numbers: Integers and Floats",
    "text": "2.2 Numbers: Integers and Floats\nThere are two types of numbers in Python - floats and integers. Floats, short for “floating point numbers,” are values with decimals in them. They may be either whole or non-whole numbers such as 3.0 or 1.2, but there is always a decimal point. Integers are whole numbers with no decimal point such as 2 or 53.\nMathematical operations that only use integers and evaluate to a whole number will generate an integers (except for division). All other situations will generate a float. See the example cell below.\na = 24\nb = 6\nd = 0.3\ne = a + b # Produces an integer.\nf = a + d # Produces a float\ng = a * b # Produces a ???\nh = a / b # Produces a ???\n\nTo Do:\n\nFor each of the mathematical operations above guess what type of number the result will be.\nUse print statements to verify your guesses and formulate a general rule that you can rely on. (Tip, the type() function will tell you what kind of number a variable is.)\n\n\n# Python Code Here!\nIntegers and floats can be inter-converted to each other using the int() and float() functions.\n\nint(3.0)\nfloat(4)\n\n4.0\n\n\nThe distinction between floats and ints is often a minor detail. Occasionally, a function will require that an argument be a float or an int but usually you won’t have to worry about which one you use.\nBelow you will find some other common mathematical operations that can be performed on numerical variables.\na = 20\nb = 10\nc = a + b \nd = a/b  \nr = a//b\nr = a % b\ne = a * b\nf = c**4\n\nTo Do:\n\nUse print statements to investigate what each operation does.\n\nGuess what type of number you expect the result to produce (int or float) and then check yourself?\nAdd comments next to each line (Use # to start a comment) explaining that operation.\n\n\n# Python Code Here!\n\n2.2.1 Augmented Assignment\nAugmented assignment is a shortened way to make a simple modification to a variable. For example, if we want to increase the value of a variable by 10, one way to do it would be like this.\na = 5\na = a + 10\nThis is certainly not difficult, but it does involve typing the variable twice which becomes cumbersome as your variable name gets longer. Alternatively, we can accomplish the same thing with the += operator.\na = 5\na += 10\nAugmented assignment can be used with addition, subtraction, multiplication, and division as shown in the code cell below.\na = 7\na += 3\na -= 1\na *= 4\na /= 3\n\nTo Do:\n\nPredict what the final result of a will be in the code cell above.\nAdd an appropriately-place print statement to see if you were correct.\nIf you were wrong, pow-wow with your neighbor until you understand.\n\n\n# Python Code Here!\n\n\n2.2.2 Compound Assignment\nAt the beginning of a program or calculation, it is often necessary to define a set of variables. Each variable may get it’s own line of code, but if there are a lot of variables, this can begin to clutter your code a little. An alternative is to assign multiple variables on a single line. In the code below, we assign the atomic mass of the first three elements.\nH, He, Li = 1.01, 4.00, 5.39\n\nTo Do:\n\nUse print statements to verify that each variable was assigned it’s own value.\nAdd assignments for the atomic masses of the next three elements on the periodic table.\n\n\n# Python Code Here!\n\n\n2.2.3 Large numbers\nSometimes you find yourself working with large numbers in your calculation. Maybe your calculation involves the use of ten billion, which has 10 zeros in it. It can be difficult to look at all of those zeros with no commas to help break it up. In those cases, you can use an underscore (_) in place of the comma, as shown below.\nmyLargeNumber = 10000000000 # This is tough to look at.\nmyLargeNumber = 10_000_000_000  # This is easy to read\n\nmyLargeFloat = 5000000.6 # This is tough to read\nmyLargeFloat = 5_000_000.6 # This is easy to read\n\n\n2.2.4 Very Large Numbers\nIf your number is very large or very small ( \\(20-30\\) zeros), you would probably rather not have to type all of the zeros at all, even if you can break it up with the underscores. For example, the Boltzmann constant, which comes up in thermodynamics, has a value equal to\n\\[ 1.38 \\times 10^{-23}\\]\nWe can avoid typing all those zeros by using scientific notation when defining the variable. (see example below) This is super handy for very large and very small numbers. (Numbers of both variety show up frequently in physics!)\nkB = 1.38e-23\n\n\n2.2.5 Python functions\nIn addition to basic mathematical functions, python contains several mathematical functions. As in mathematics, a function has a name (e.g. f) and the arguments are places inside of the parenthesis after the name. The argument is any value or piece of information fed into the function. In the case below, f requires a single argument x.\n\\[f(x)\\]\nIn the cell below, you will find several useful Python functions.\n\nabs(-5.5)\nfloat(2)\nint(5.6)\nprint(1.26e-6)\nround(-5.51)\nstr(3.2)\n\n1.26e-06\n\n\n'3.2'\n\n\nIn addition to Python’s native collection of mathematical functions, there is also a math module with more mathematical functions. Think of a module as an add-on or tool pack for Python just like a library. The math module comes with every installation of python and can be imported (i.e. activated) using the import math command. After the module has been imported, any function in the module is called using math.function() where function is the name of the function. Here is a list of commonly-used functions inside the math module:\n\nimport math\nmath.sqrt(4)\nmath.ceil(4.3)\nmath.cos(1.5)\nmath.sin(1.5)\nmath.tan(3.14)\nmath.asin(1)\nmath.acos(1/2)\nmath.atan(2)\nmath.degrees(6.28)\nmath.e\nmath.exp(5)\nmath.factorial(4)\nmath.log(200)\nmath.log10(1000)\nmath.radians(360)\nmath.pi\nmath.pow(2,8)\n\n256.0\n\n\n\nTo Do:\n\nUse print statements to figure out what each function in the code cell above does. Pay special attention to trigonometric function. Do these functions expect the argument to be in radians or degrees?\nAdd comments to remind yourself for later.\n\n\n# Python Code Here!\nThere are other ways to import functions from modules. If you only want to use a single function inside the module, you can selectively import it using from, as shown below.\n\nfrom math import radians\nradians(4)\n\n0.06981317007977318"
  },
  {
    "objectID": "chapters/variables.html#flash-cards",
    "href": "chapters/variables.html#flash-cards",
    "title": "2  Variables and Numbers",
    "section": "2.3 Flash Cards",
    "text": "2.3 Flash Cards\n\nWhat are the rules for naming variables in Python?\nWhen will a mathematical calculation produce a float?\nWhen will a mathematical calculation produce an int?\nWhat is the best way to increase/decrease the value of a variable by a multiplicative factor (multiply it by a number)?\nWhat is the best way to increase/decrease the value of a variable by an additive constant (add a number to it)?\nWhen assigning large numbers to variables, what character can replace the “,” to separate the numbers into groups of three?\nHow do you use scientific notation to assign a very large number to a variable?\nWhen using a trig function (\\(\\sin \\theta\\), \\(\\cos \\theta\\), \\(\\tan \\theta\\)), the number that is passed in must have what units?\nWhat does the math.radians function do?\nWhere can you find King Benjamin’s address to his people?"
  },
  {
    "objectID": "chapters/variables.html#exercises",
    "href": "chapters/variables.html#exercises",
    "title": "2  Variables and Numbers",
    "section": "2.4 Exercises",
    "text": "2.4 Exercises\n\nMost (or all) of you have use Pythagorean’s theorem to calculate the hypotenuse of a right triangle. The theorem states taht \\(a^2 + b^2 = c^2\\) for a right triangle, where \\(a\\) and \\(b\\) are the lengths of the sides forming the right angle and \\(c\\) is the length of the hypotenuse. There is a Python function called hypot (found in a library called math) that will perform this calculation for your. Calculate the distance from the point \\((-48,56)\\) to the point \\((23,81)\\) using\n\nPythogorean’s theorem\nThe Python function hypot. To learn how to use the hypot function, visit the following documentation page and search for the explanation for the hypot function. Learning to read and understand online documentation is a skill that you you should develop.\n\n\nPrint out the result and check your answer with your neighbor’s answer.\n# Python Code Here!\n\nSolve the quadratic equation using the quadratic function below for \\(a = 1\\), \\(b = 2\\), and \\(c = 1\\). \\[ x = {- b \\pm \\sqrt{b^2 - 4 a c} \\over 2a}  \\] Print out the result and check your answer with a classmate.\n\n# Python Code Here!\n\n(Solar Mass) The mass of the sun can be calculated using the following formula:\\[ M_\\text{sun} = {4 \\pi^2 (1 \\text{ AU})^3\\over G (1 \\text{ yr})^2}\\]\nThe unit AU is called an astronomical unit of length and is defined to be the average distance between the sun and earth. \\[ 1 \\text{ AU} = 1.58\\times 10^{-5} \\text{ light years}\\] where \\(1 \\text{ lightyear} = 9.5 \\times 10^{12}\\) km. The constant \\(G\\) is called the gravitational constant and has the value: \\[ G = 6.674 \\times 10^{-11} \\text{ m}^3 \\text{ kg}^{-1}\\text{ s}^{-1}\\] Calculate the mass of the sun and display your result using a print statement. You should find a value of \\(M_\\text{Sun} = 2.01 \\times 10^{30}\\) kg\n\n# Python Code Here!\n\n(Projectile Motion) The range of a projectile is given by the equation:\\[ d = {2 v^2 \\cos \\theta \\sin \\theta \\over g}\\] or the equivalent expression:\\[ d = {v^2  \\sin 2 \\theta \\over g}\\] where \\(g = 9.8\\) m/s\\(^2\\), \\(\\theta\\) is the launch angle, and \\(v\\) is the launch speed.\n\nUsing a launch angle of 60\\(^\\circ\\) and a launch speed of \\(40\\) m/s, verify that both expressions above give the same result for the range.\nNow pick one of the equations above and use trial and error to determine the angle that gives maximum range.\n\n\nv = 40\ng = 9.8\n\n(Rydberg’s constant) Rydberg’s constant (\\(R_\\infty\\)) is a physical constant in Rydberg’s formula which was used to predict the spectrum of light emitted by a heavy atom. Rydberg’s constant is given by: \\[R_\\infty = {m_e e^4 \\over 8 \\epsilon_0^2 h^3 c}\\]\nwhere\n\n\\(m_e = 9.109 \\times 10^{-31}\\) kg is the mass of an electron.\n\\(e = 1.602 \\times 10^{-19}\\) C is the charge of an electron/proton.\n\\(\\epsilon_0 = 8.854 \\times 10^{-12}\\) C V\\(^{-1}\\) m\\(^{-1}\\) is the electrical constant.\n\\(h = 6.626 \\times 10^{-34}\\) J Hz is the Planck constant.\n\\(c = 3 \\times 10^8\\) m/s is the speed of light.\n\nThese constants show up all over in physics. In the cell below write some code that assigns the constants to variables and then use the variables to calculate Rydberg’s constant. Use a print statement to display the result. The result should be: \\(R_\\infty = 10961656.2162\\) (in m\\(^{-1}\\))\n\n# Python Code Here!\n\nIn Einstein’s special theory of relativity, the momentum of an object with mass \\(m\\) (in kg) and velocity \\(v\\) (in m/s) is given by:\\[ p = m v \\gamma\\] where \\[\\gamma = {1\\over \\sqrt{1 - {v^2\\over c^2}}}\\] with \\(c = 3 \\times 10^8\\) m/s\n\nCalculate the momentum of an object with mass \\(m = 0.14\\) kg and speed \\(v = 50\\) m/s. Then compare to the classical expression for momentum: \\(p = mv\\).\nNow calculate the momentum of an object with mass \\(m = 0.14\\) kg and whose speed is \\({1 \\over 4}\\) the speed of light. Repeat the comparison to the classical value.\n\nRepeat for the following speeds: \\({1\\over 2}\\) the speed of light, \\({3\\over 4}\\) the speed of light, and \\({7\\over 8}\\) the speed of light. Repeat the comparison to the classical value.\n\n\n# Python Code Here!"
  },
  {
    "objectID": "chapters/strings.html",
    "href": "chapters/strings.html",
    "title": "3  Strings",
    "section": "",
    "text": "Jupyter Notebook\nAnother commonly-used type of data is a string of characters known simply as strings. Strings can contain a variety of characters including letters, numbers, and symbols."
  },
  {
    "objectID": "chapters/strings.html#creating-strings",
    "href": "chapters/strings.html#creating-strings",
    "title": "3  Strings",
    "section": "3.1 Creating Strings",
    "text": "3.1 Creating Strings\nStrings are created by placing the sequence of characters in single (or double) quotes.\ntext = \"some text\"\nStrings can also be created by converting a float or an integer into a string using the str() function.\ntext = str(4.5)\nOne common error made when working with strings is to attempt to perform math with them. Python will not perform math with strings because it sees them as a series of characters and nothing more. In the cell below, we attempt to perform math with some strings.\na = \"4\"\nb = \"2\"\nc = 5\n\nd = a + b\ne = a * b\nf = b * c\n\nTo Do:\n\nUse print statements in the cell above to determine what happens when you add two strings together. (Ancillary question: Can you subtract strings?)\nUse print statements in the cell above to determine what happens when you multiply two strings.\nUse print statements in the cell above to determine what happens when you multiply a string and an integer.\nWhat do you think will happen if you multiplied a string and a float? Guess and then see if you’re right.\nAdd comments for you to refer back to later.\n\n\n# Python Code Here!\nIf you want to know the length of a string, you can use the len() function\n\ntext = \"some text\"\nlen(text)\n\n9\n\n\nThe length of the string above is 9 because a space is a valid character."
  },
  {
    "objectID": "chapters/strings.html#displaying-text-and-numbers-together",
    "href": "chapters/strings.html#displaying-text-and-numbers-together",
    "title": "3  Strings",
    "section": "3.2 Displaying text and numbers together",
    "text": "3.2 Displaying text and numbers together\nYou have been using print() statements quite a lot lately (hopefully) but you probably haven’t printed text and numbers together. To display both text and numbers in the same message, there are several options. The first is to just put multiple variables into the print() function, separating them with commas.\n\ng = 9.8\nunit = \"m/s^2\"\nprint(g,unit)\n\n9.8 m/s^2\n\n\nAnother option is to convert the number to a string and then “add” it to the other string. This creates a single string as an argument to the print() function.\n\ng = 9.8\nunit = \"m/s^2\"\nprint(str(g) + unit)\n\n9.8m/s^2\n\n\nNotice the lack of space between the number and the unit. “Adding” the two strings smashed them together exactly as they were, no spaces added. You can insert multiple numbers into a string using something called “f”-strings. (short for formatted strings). To construct an f-string, simply place an “f” in front of the string. Anytime you want to insert a number in your string, enclose it in curly braces.\n\nv = 5.0\nc = 3e8\nprint(f\"The speed of light is {c} and the speed of my car is {v}\")\n\nThe speed of light is 300000000.0 and the speed of my car is 5.0\n\n\nThat’s a clever way to insert a numerical value into a string, but the value of the speed of light is still displaying too many digits. To specify how the number should be formatted place a : after the variable name followed by a formatting tag.\n\nv1 = 5.0\nv2 = 8.3\nc = 2.998e8\nn = 2\n\nprint(f\"There are {n:d} cars traveling side by side.  One car is traveling at {v1:4.2f} m/s and the other is traveling at {v2:4.2f} m/s.  Those speeds are much smaller than the speed of light, which is {c:.2e} m/s\") \n\nThere are 2 cars traveling side by side.  One car is traveling at 5.00 m/s and the other is traveling at 8.30 m/s.  Those speeds are much smaller than the speed of light, which is 3.00e+08 m/s\n\n\nThe structure of the stuff inside of the curly braces is {variable:formatcode}; variable holds the value to be displayed and formatcode indicates how the variable should be formatted when it is printed. The f in :4.2f indicates that the variable should be displayed as a float and the 4.2 indicates that four spaces should be allocated to display the number and no more than 2 numbers after the decimal should be displayed. A selection of some commonly-used format codes is given below.\n\nA summary of common format codes.\n\n\n\n\n\n\nformat code\nexplanation\n\n\n\n\n{variable}\nUse the default format for the data type.\n\n\n{variable:4d}\nDisplay as an integer, allocating 4 spaces for it.\n\n\n{variable:.4f}\nDisplay as a float, with four numbers after the decimal being displayed.\n\n\n{variable:8.4f}\nDisplay as a float, allocating 8 total spaces and 4 numbers after the decimal place.\n\n\n{variable:8.4e}\nDisplay using scientific notation, allocating 8 total spaces and 4 numbers after the decimal place.\n\n\n{variable:6s}\nDisplay as a string, allocating 6 total spaces for it. If the string is longer than 6 spaces, it will display the entire string with no extra white space. If the string is shorter than 6 spaces, it will pad the string with whitespace until it is 6 spaces long.\n\n\n\n\nTo Do:\n\nModify the print statement above so that the float variables are given 8 total spaces with only 1 number after the decimal being displayed.\nModify the print statement above so that the speed of light is displayed with 3 numbers after the decimal place.\n\n\n# Python Code Here!"
  },
  {
    "objectID": "chapters/strings.html#indexing-and-slicing",
    "href": "chapters/strings.html#indexing-and-slicing",
    "title": "3  Strings",
    "section": "3.3 Indexing and Slicing",
    "text": "3.3 Indexing and Slicing\nAccessing a piece (or slice) of a string is a common task in scientific computing. Often you will import data into Python from a text file and need to extract a portion of the file for later use in calculations. Indexing allows the user to extract a single element, or character, from a string. The key detail about indexing in Python is that indices start from zero. That means that the first character is index zero, the second character is index 1, and so on. For example, maybe a string contains the following amino acid sequence ‘MSLFKIRMPE’. For this example, the indices are as follows:\n\n\n\nCharacters\nM\nS\nL\nF\nK\nI\nR\nM\nP\nE\n\n\n\n\nIndex\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\nTo access a single character from a string, place the desired index in square brackets after the name of the string.\n\nseq = \"MSLFKIRMPE\"\nseq[0]\n\n'M'\n\n\nTo access the last character in a string you could do\n\nseq = \"MSLFKIRMPI\"\nseq[len(seq) - 1]\n\n'I'\n\n\nBut this seems overly cumbersome. An easier approach is to index backwards. The string can be reverse indexed from the last character to the first using negative indices, starting with -1 as the last charcter.\n\nseq = \"MSLFKIRMPE\"\nseq[-1]\n\n'E'\n\n\n\nTo Do:\n\nAccess the 5th character in the peptide sequence above.\nAccess the character that is 3rd from the end in the peptide sequence above.\n\n\n# Python Code Here!\nIndexing only provides a single character, but it is common to want a series of characters from a string. Slicing allows us to grab a section of a string. Slicing is performed by specifying start and stop indices separated by a colon in the square brackets. One important detail worth mentioning: the character at the starting index is included in the slice while the character located at the final index is not included in the slice.\n\nseq = \"MSLFKIRMPE\"\nseq[0:5]\n\n'MSLFK'\n\n\nLooking at the string, you notice that the character at location 5 (I) has been excluded from the slice. You can leave off the first number when slicing and the slice will start at the beginning of the string.\n\nseq = \"MSLFKIRMPE\"\nseq[:5]\n\n'MSLFK'\n\n\nYou can also use negative indices when slicing. This is especially helpful when you want to grab the last few characters in a string.\n\nfile = \"data.txt\"\next = file[-3:]\nprint(ext)\n\ntxt\n\n\nFinally, we can adjust the step size in the slice. That is, we can ask for every other character in the string by setting a step size of 2. The structure of the slice is [start,stop,step].\n\nseq = \"MSLFKIRMPE\"\nseq[0:8:2]\n\n'MLKR'\n\n\nYou can omit the start and stop indices and Python will assume that you are slicing the entire string.\n\nseq = \"MSLFKIRMPE\"\nseq[::2]\n\n'MLKRP'"
  },
  {
    "objectID": "chapters/strings.html#string-methods",
    "href": "chapters/strings.html#string-methods",
    "title": "3  Strings",
    "section": "3.4 String Methods",
    "text": "3.4 String Methods\nA method is a function that works only with a specific type of object. String methods only work on strings, and they don’t work on other types of objects, like floats or ints. If it helps you, you can just think of a method as a function.\nOne example of a string method is the capitalize() function which returns a string with the first letter capitalized. To use a method (referred to as calling the method), the method name is appended to the variable you want it to operate on. For example, below is an Albert Einstein quote that needs capitalized.\n\nquote = \"i want to know God's thoughts. The rest are details.\"\nquote.capitalize()\nprint(quote)\n\ni want to know God's thoughts. The rest are details.\n\n\nNotice that the original variable (quote) remains unchanged. This particular method does not change the value of the original string but rather returns a capitalized version of it. If we want to save the capitalized version, we can assign it to a new variable, or overwrite the original.\n\nquote = \"i want to know God's thoughts. The rest are details\"\nquote = quote.capitalize()\nprint(quote)\n\nI want to know god's thoughts. the rest are details\n\n\nIn the cell below you will find a list of commonly-used string methods.\n\na = \"spdfgssfpggg\"\na.capitalize()\na.center(10)\na.count(\"s\")\na.find(\"d\")\na.isalnum()\na.isalpha()\na.isdigit()\na.lstrip(\"s\")\na.rstrip(\"g\")\na.split(\"s\")\na.startswith(\"s\")\na.endswith(\"p\")\n\nFalse\n\n\n\nTo Do:\n\nUse well-placed print statements to determine what each string method does.\nAdd comments next to each method for future reference.\n\n\n# Python Code Here!"
  },
  {
    "objectID": "chapters/strings.html#flash-cards",
    "href": "chapters/strings.html#flash-cards",
    "title": "3  Strings",
    "section": "3.5 Flash Cards",
    "text": "3.5 Flash Cards\n\nWhat is the index value of the sixth character in a string?\nWhat happens when you “add” two strings together?\nWhat happens when you multiply two strings together?\nWhat happens when you multiply a string by an integer?\nWhat happens when you multiply a string by a float?\nWhat function will tell you how many characters are in a string?\nGive two ways that you could slice out the first 4 characters in a string.\nGive two ways that you could slice out the last 4 characters in a string.\nWhat string method would you use to see if a string contains only numbers and characters, but no symbols?\nWhat does the string method split() do?\nWhat does the string method find() do?\nExplain how to print a sentence with a variable inserted in the middle?\nWhat format code should be used to display a variable as a float with 8 total spaces and 2 numbers after the decimal?\nWhat format code should be used to display a variable in scientific notation with 6 total spaces and 2 numbers after the decimal?\nWhere is the parable of the wheat and the tares found?"
  },
  {
    "objectID": "chapters/strings.html#exercises",
    "href": "chapters/strings.html#exercises",
    "title": "3  Strings",
    "section": "3.6 Exercises",
    "text": "3.6 Exercises\n\nIn the cell below you will find a string containing the name of a PNG file. (i.e. name always ends in “.png”).\n\nRemove the “.png” extension from the string using a string method.\nRemove the “.png” extension from the string using slicing.\n\n\nfile = \"physics.png\"\n\n(Lightning Strike) The dielectric strength of air determines how likely it is for lightning to strike and this value varies with the humidity (moisture content) of the air. In the cell below, you will find a string that contains the dielectric strength of air for three different humidity levels. Use string methods to extract the three dielectric constant values. Then calculate\n\nthe difference between the largest and smallest values.\nThe average of the three values.\n\n\ndielectricBreakdownAir = \"dry:15847,moderate:8523,wet:7864\"\n\nBelow you will find a string containing all experimentally known alloys (compounds formed by combining two or more elements on the periodic table) represented using the elements first discovered to exhibit that crystal structure (or “prototypes”).\n\nUse string methods to find the number of alloys containing Aluminum (symbol: Al).\nIs there a crystal structure with the designation “CaC2” (Calcium Carbide) in the list? How about “Fe2Ag”?\nUse string methods to calculate the percentage of the alloys listed that have gold in them (symbol Au).\n\n\nalloys = \"Cu,W,Mg,betaSn,Indium,alphaAs,alphaHg,Cu,AuCu,CuPt,AB2,MoPt2,AB2,AB3,AB3,A2B2,AB3,A2B2,AB3,A2B2,Al3Ti,AuCu3,AB3,A2B2,W,W,gamma-IrV,CsCl,AB2,AB2,MoSi2,AB3,AB3,A2B2,AB3,A2B2,AB3,gamma-CuTi,AB3,A2B2,CuTi3,AlFe3/BiF3,NaTl,Mg,WC,AB3,CuTe,AuCd,A2B2,AB3,AB3,A2B2,AB5,A4B2,A4B2,A4B2,A2B4,A3B3,A3B3,AB5,A4B2,A4B2,A4B2,A2B4,A3B3,A3B3,AB5,A2B4,A2B4,AB5,A2B4,A2B4,A3B3,AB5,A2B4,A3B3,A2B4,A2B4,A3B3,MgZn2,Fe3C,Cu2Mg,Cr3Si,Ni3Sn,ZrSi2,CrB,ITl,FeSi,CdTi,InTh,SeTl,NaCl,BaAl4,CaCu5,ThMn12,Fe2P,Co2Si,Th3P4,AlB2,ZnS,ZnS,NiAs,Mn5Si3,Cr3Si,Cu2Sb,MoSi2,Al2Cu,Cd58Y13,Co3V,Pu3Al,CrFe,NbPd3,Ni3Ti,CaIn2,ThSi2,CaC2,AuBe5,W5Si3,La2O3,BFe,FeS2,Bi2Te3,Ti3Cu4,FeS2,CdI2,Cd3Y,Ni2In,Ni2Si,betaCu3Ti,Al3Zr,FeS2,GdSi2(1.4),MoNi4,CuZr2,alphaReO3,PbO/PbS,Indium,betaSn,alphaAs,CuPt7,NbNi8,V4Zn5,MgNi2,alphaGa,alphaMn,betaMn,gammaSe,graphite,alphaPa,betaU,alphaNp,betaNp,alphaHg,Ga4Ti5,Al2Zr3,Al3Zr4,Al3Zr2,NaZn13,CaB6,Al3Ni2,Ga4Ni(Ga3.62Ni0.97),Ga3Pt5,Ga9Ni13,Ga4Ni3,Ga2Hf,C6Mn23,Cu8Hf3,Ni10Zr7,Hg2Pt,B4Mg,B7Mg,Ge3Rh5,In4Ti3,V7.49Sb9,Li3B14,LiB3,LiB-MS1,LiB-MS2,Re24Ti5,Ni7Zr2,Pt11Zr9,Au4Zr,Hf54Os17,CrSi2,Ag51Gd14.o3.t0,Ag51Gd14.o3.t1,Ag51Gd14.o3.t2,Ag51Gd14.o2.t3,Ag51Gd14.o2.t4,Ag51Gd14.o2.t5,Ag51Gd14.o2.t6,Ag51Gd14.o1.t7,Ag51Gd14.o1.t8,Ag51Gd14.o1.t9,Zn22Zr,As2Ti,Ge10Ho11,Ir3Zr5,CaCl2,CFe4,C2Mn5,C3Mn7,Fe3Th7,F3Fe,F3Fe,NiTi,Ag2O,etaAg2Zn,AlCl3,AlF3,alphaAl2O3,Al12W,Ag2Se,AlPd,AlSb,Cu5Zn8,BaPb3,Hf3Sc*-h321,Hf5Sc-h51,BiHf2-134,Hf5Pb-f63,HfPd5,Re25Zr21,B11_3,B11_3',Z3,Z3',Al13Co4,eta,D8_11,Al9Co2,Pd4Se,NaCd2,Er3Ru2,Pt3Sr7,Ir4Sc11,Ru25Y44,RuZn6,NbRu-Beta'',delta(CdNi),Cd2Ce,Hg2U,InMg2,Cd3Er,CdMg3,CeNi3,CoSc3,Pb3Sr,PuNi3,YZn3,Co2Y2*,Sc2Zr*,Mo3Ti*-81,MoTi*-80,ReTi2*-81,Hf2Tl*-6,Be2Zn*-65,Re3Ru*-124,Cu2.82P,Mg2Au,BiF3,Al12Mg17,MgAu3-x,MgAu3+x,Mg2Cu,Mg2Ga,MgGa2,Mg5Ga2,Mg2Ga5,MgGa,Mg3Hg,Mg3In,Mg44Rh7,CaF2,Al3Ir,Mn23Th6,Mg2Zn11,Mg4Zn7,Mg3Ru2,Au2V,Sr9Mg38,CrFe,Rh13Sc57,Fe7W6,AuSn2,Bi2Pd,Bi2Pd5,Bi3Ni,Bi3Y5,Bi4Rh,BiMn3,BiPd3,BiTi2,CoSb2,Cu7Hg6,Hg2K,Ir2Zn11,Ni3P,KP15,Pu28Zr,B12U,TiZn16,Rh2Y3,Rh3Pu5,alpha-SV3,IrTa,Ge4Sm5,Cl2Pb,NbPt3,Hg4Pt,Pd4Pu3,Er3Ni2,Pd2Ti,Pd5Ti3,Pd3Ti2,Hg5Mn2,Pu3Pd5,Ga2Zr,FeP4_mP30,FeP4_mS40,In3Ir,Fe6Ge5,Fe3Ga4,Al6Mn,AsFe,CoSn,As3Co,Im-3m,Pm-3m,P6/mmm,Pm-3n,Fe6.5Ge4-ideal(Fe14Ge8),Fe6.5Ge4-part(Fe13Ge8),Al8Cr5,Co5Ge7,E2_1,beta-NW2,alpha-MoS2,D8_5r,Na13Cl12v7,alpha-N2,alpha-N2p,beta-N2,epsilon-N2,gamma-N2,WN2_194af,Ag2Te,C1,C19,C4,C7,WN2_187fg,WN2_194de,Hagg_N4W6,MoO3,O3W,P3Tc,WN4_164ad,B4W,P4Re,B8_1v2,B8_1v2p,Na4Cl3v1,C4W3,S3U4,O5Nb2,B8_1v3,Na7Cl6_v3,Na7Cl8v1,B8_1v1,B8_1v1p,Na1Cl1v2,Na3Cl3v2,B8_1v2pp,B3v2,Na7Cl7v2,B1,NTa,NbO,NbS,Hagg_NW2,Mo2N,NV2,NW2_Pearson,beta-W,Ge8Mn11,NaTe3,NaTe,Sb3Sr2,SrAs3,La2Sb,Ga5Tm3,B6Si1,B2Zr1,B12Y1,B2Mg1,B4La1,B1Ni1,B1Mo2,As1B1,B4Cr3,B1Pu1,B2V3,B2Zr1,B3V2,B4Ce1,B6Fe23,B1Tc1,B1Pt1,B2Re1,B2Ru1,B5W2,B1Fe1,B1Mo1,B1Re3,B3Ru2,B1Ni3,B3Ru7,B1Tc1,B1Be2,B2Nb1,B1Rh1,B1Tc1,B1Tc1,B2Li2,B4Cr1,B4Mn1,B1Fe2,B1Fe2,B1Fe2,B1Pd2,B1Pt2,B1Ti2,B2Mo1,B2Sc1,B4Mo2,B4Mn3,B4Nb3,B5W2,B1Co1,B1Fe3,B1Li1,B1Mn1,B2Li2,B3Mo1,B3Re1,B3Ru2,B4Cr1,B4Fe1,B4Mo1,B6Ta5,B11Li1,B11Li1,B11Li1,B11Li1,B11Li1,B1Cr2,B1Rh2,B2Fe1,B2W1,B12Sc1,B2Pd5,B3Ni4,B3Ni4,B5Mo2,B5W2,B12Si3,B1Co3,B1Pd3,B4Mn4,B2Mo1,B4Rh5,B4W1,B4W1,B9Li1,B20Na3,B3Ni4,B3Si1,B8Ru11,Cu,Cu,W,W,Mg,Mg,NaCl,CsCl,ZnS,ZnS,WC,C1Ti1,C1Si1,C2U1,C3Pr2,C1W1,C1Sc1,C60K6,C1Y2,C2Ca1,C1Fe3,C4Sc3,Ba1C2,C1Nb2,C1Mo2,C2Th1,C2Rb2,C5Y4,C19Sc15,Be2C1,C2Os1,C2Li2,C2Os1,C1V2,C7Ho4,C6Cr23,Ba1C2,C1Mo2,C1Sc2,C2Re1,C2Re1,C1Nb1,C1Nb1,C1Os1,C1Ru1,C1Sc1,C1Si1,C1Fe4,C1Fe4,B1C5,B1C5,C1Co2,C1Fe2,C1Fe2,C1Re2,C2Ca1,C2Ca1,C2Ir1,C2Ir1,C2Mg1,C2Re1,C2Si1,C2Th1,C2Th1,C2Th1,Al4C3,As4C3,C3Nb4,B1C7,B1C7,B1C7,B1C7,B1C7,C1Fe3,C1Fe3,C1Mo1,C1Ni3,C1Os1,C1Re1,C1Si1,C1W2,C8Cs1,C1Fe4,C1Si1,C1Si1,C2Cr3,C3Mg2,C4Ir1,C4Ir1,C4Ir1,C5Nb6,B1C5,B1C5,C1Fe2,C1Mo1,C1Mo2,C1Nb2,C1Nb2,C1Si1,C1Ti2,C2Ca1,C2Ca1,C2Ca1,C2Cs2,C2Na1,C5Ti8,C1Si1,C2Fe5,C2Fe5,C2Fe5,C2Mn5,C2Mn5,C3Sc4,C6Eu1,C6Yb1,B13C2,B4C1,C1Cr3,C1Fe3,C1Fe3,C1Fe3,C1Si1,C1Si1,C1Ti1,C2Cs2,C2K2,C2Na2,C3Ir1,C3Ir5,C1Si1,C8K1,C8Rb1,C1Si1,C2Cr3,C2Cr3,C3Fe7,C3Os2,C4Ir1,C7Ir3,C7Lu4,Ba1C2,C1Mn6,C1Si1,C6Mn23,C1Si1,C2K2,C5V6,C1Si1,C5Ir4,C1Si1,C3Os2,C1Si1,C7Ho4,C0.88V1,C7V8,C7V8,C7V8,C19Er15,Ba3C60,C60Sr3,AlCu2Mn-Heusler,AlCu2Mn-Heusler-tet*%,Cu1Li2Sn1-antiHeusler,Cu1Li2Sn1-antiHeusler-tet*%,AlCu2Mn-Heusler,AlCu2Mn-Heusler-tet*%,Cu1Li2Sn1-antiHeusler,Cu1Li2Sn1-antiHeusler-tet*%,C1b,C1b,Co1Ge1Mn1_ICSD_52968,Co1Ge1Mn1_ICSD_623495,Co3Ge1Mn2_ICSD_52972,Cl1La1Se1_ICSD_425686,Co2Si1_ICSD_44858,C15b,As2Ce1Pd2,SQS_L12,Al1F6K2Na1_ICSD_6027,Cf,Te,Po,C,alpha-Pu,C,beta-Pu,O2,P,Se,Se,H,C,alpha-Np,alpha-U,alpha-Ga,P,I2,S,gamma-Pu,Si,beta-Np,B,beta-U,N2,CrFe,C,Cl2,In,Pa,Si,C,Sn,S,Se,S,B,B,Po,Hg,As,C,O2,Sm,Sc,C,gamma-HgSn6-10,Mg,La,C,C,C,N2,C,C,N2,Si,Mn,Mn,Li,Po,Si,Cu,Si,C,W,FeS2,P2I4,H2S,SiO2,Mo8P5,FeNi,H2S,As2Ba,epsilon-WO3,Rh2Ga9,SiO2,alpha-P3N5,H3Cl,delta-PdCl2,H3Cl,LiSn,NiTi,Au5Mn2,AuTe2,AlCl3,H2S,ZrO2,gamma-PdCl2,alpha-C7H8,B2Pd5,SiO2,H3Cl,CuO,alpha-Ag2Se,BaS3,Ag2Se,H3Cl,SiO2,Ta2H,FeS,H3S,CdTe,H2S,beta-SeO2,TlP5,AuTe2,ZrO2,FeS2,kappa-Al2O3,CoAs,FeSb2,HgBr2,HCl,Au2V,Ta3S2,CeTe3,PdSn2,PtSn4,W3O10,BN,GeS2,AsGa,beta-Ta2O5,AuCd,GaCl2,Sr2Bi3,GeAs2,Rh5Ge3,Sb2O3,TlF,alpha-PdCl2,CaCl2,etaFe2C,FeS2,TiCu3,CuTe,Rh2S3,WO3,beta-C7H8,TiO2,CdSb,Benzene,Cr3C2,Co2Si,HgCl2,PbCl2,SrH2,Sb2S3,C3Cr7,epsilon-NiAl3,MgB4,MoO3,Fe3C,GeS,MnP,FeB,SnS,FeAs,ZrSi2,MnAl6,CrB,H2S,Ga3Pt5,CdPt3,alpha-IrV,H3S,beta-ThI3,alpha-FeSe,alpha-PbO,PdSn4,TlF,TiSi2,Mn2B,Ta3B4,MoPt2,ReSi2,SiS2,KHg2,Al4U,Cs3P7,H2S,beta-NbO2,GeSe2,Ni3P,Ti2Ge3,PdS,SrBr2,Ti3P,Ti5Te4,Ni4Mo,ThCl4,alpha-NbO2,SiO2,SiO2,CdAs2,Gd3Al2,NbTe4,Co5Ge7,GeP,Sr5Si3,NbAs,MnF2,VN,BaS3,SeO3,Pd4Se,Rh3P2,HgI2,Ru2Sn3,beta-Bi2O3,RuIn3,Ir3Ga5,RbGa3,GaSb,CuTi3,CuAu,NbTe4,PtPb4,Si2U3,ThB4,Cu2Sb,PbO,gamma-CuTi,Ba5Si3,PtS,beta-V3S,SeO2,TiO2,beta-BeO,Zn3P2,ZrO2,HgI2,Mn12Th,ThH2,Al3Zr,Al3Ti,V4Zn5,Al4Ba,Pt8Ti,MoSi2,Hg2Cl2,Al2Cu,W5Si3,Cr5B3,SiU3,SeTl,In2S3,TiO2,alpha-ThSi2,Ga2Hf,Mn3O4,MoB,NbP,MoS2,IrGe4,ZnTe,AgZn,beta-PdCl2,BiI3,C8H8,PdAl,Ti3O,Fe2P,CrCl3,SiO2,CrCl3,HgS,Ni3S2,AlF3,CdI2,CuI,beta-CuI,beta-RuCl3,Bi2O3,alpha-Si3N4,H3S,Cr5Al8,SiC,CSi,NiS,NV2,La2O3,Al3Ni2,CdI2,deltaH^II-NW2,H3Ho,Cu3P,Bi2Te3,Al4C3,B5Mo2,CaC6,Fe7W6,CuPt,Al2O3,alpha-Al2S3,Al2S3,PI3,beta-Si3N4,Er3Ru2,UCl3,SiO2,AuF3,AuF3,Mg2Ni,SiO2,CrSi2,beta-SiO2,Fe3C,CrFe3NiSn5,Cu3P,beta-RuCl3,Na3As,Fe3Th7,SiC,BN,ZnS,SiC,Re3N,WC,Fe2P,Li2Sb,alpha-Sm3Ge5,FeS,Cu2Te,Li3N,AlB2,CaCu5,CoSn,AlPO4,Mn5Si3,SiO2,Ni3Ti,Ni3Sn,W2B5,Co2Al5,MgZn2,MgNi2,CaIn2,Ni2In,MoS2,Na3As,CMo,CuS,NiAs,BN,AsTi,Ga4Ni,NH3,CO,FeSi,CoU,Mg2Zn11,Al12W,CoAs3,FeS2,CuCl,Pd17Se15,PH3,SiO2,SrSi2,gamma-Cu9Al4,Fe4C,AuBe5,ZnS,SiF4,Cu5Zn8,Cu15Si4,Pu2C3,Th3P4,ReO3,CaB6,BaHg11,Cu3Au,CsCl,NbO,Cr3Si,Cu2O,UB12,Th6Mn23,Cr23C6,Ca7Ge,CaF2,BiF3,NaCl,NaZn13,SiO2,Cu2Mg,Co3O4,CTi2,NiTi2,NaTl,TeO6H6,Sb2Tl7,gamma-Fe3Zn10,H3S,Pt3O4,beta-Hg4Pt,Ir3Ge7,Ga4Ni3,AsKSe2,Pb(Zr0.52Ti0.48)O3,AuAgTe2,KClO3,[Sc,Y]2Si2O7,AgAuTe4,AlPS4,CeRu2B2,NaFeS2,BPS4,CoAsS,Bi5Nb3O15,CuBrSe3,AsCu3S4,Re2O5[SO4]2,AsK3S4,TiAl2Br8,V2MoO8,Li2Si2O5,C2CeNi,VPCl9,K2CdPb,MnGa2Sb2,TiFeSi,La2NiO4,alpha-Tl2TeO3,TaNiTe2,CuBrSe3,BiGaO3,CNCl,FeOCl,Mg2SiO4,CuFe2S3,CuSbS2,CaTiO3,BaSO4,KFe2S3,La43Ni17Mg5,SrCuO2,MgSiO3,MgO4S,CaSO4,MgB2C2,SrAl2Se4,Al2CuIr,HoCuP2,NbPS,LaRhC2,Sr2As2O7,TlZn2Sb2,CdAl2S4,BPO4,ThBC,Na5Fe3F14,Li2MoF6,ThBC,Ta2Se8I,Pb(Zr0.52Ti0.48)O3,Ce3Si6N11,gamma-MgNiSn,Ba5In4Bi5,Tl4HgI6,BaGe2As2,LaPtSi,Be[BH4]2,alpha-CuAlCl4,KAu4Sn2,CuFeS2,HoCoGa5,CaCuO2,Nb4CoSi,KCeSe4,BiAl2S4,K2SnCl6,FeCu2Al7,PbFCl,CuBi2O4,AgUF6,ZnSb2O4,CeCo4B4,(La,Ba)2CuO4,ZrSiO4,PPrS4,Ta3Al4O13[OH],ScRh6P4,gamma-Ag3SI,FePSe3,Be2SiO4,FeTiO3,Ag5Pb2O6,COS,LiNbO3,CuNiSb2,CrNiS2,SmSI,PrNiO3,KBO2,LiNbO3,CaCO3,K2Ta4O9F4,Al[PO4],Sr[S2O6][H2O]4,Sr[S2O6][H2O]4,Fe12Zr2P7,GdSI,Nb7Ru6B8,Mg[NH],Fe3Te3Tl,AuCN,Al[PO4],KNiCl3,Al5C3N,BaPtSb,LiScI3,BaSi4O9,AlB4Mg,Al9Mn3Si,AlN3Ti4,AlCCr2,LiBC,PrRu4P12,Cu2Fe[CN]6,NaClO3,NiSSb,KSbO3,KB6H6,Rb3AsSe16,Mg32(Al,Zn)49,Ca3Al2O6,AlLi3N2,(Mn,Fe)2O3,F6KP,Te[OH]6,Ca3PI3,Ag3AuTe2,Cu3S4V,Cu3AsS4,AgAsMg,Ag3[PO4],Ca3Al2O6,CaTiO3,Ce5Mo3O16,K2PtCl6,Cr9Fe16Ni7,CrFe18Ni8,AlCu2Mn,Eu2Ir2O7,Al2MgO4,Fe3W3C,CrFe12Ni3,CrFe4Ni3,CaFeO6Si2,Na2MgAlF7,Ca4Al6O16S,YBa2Cu3O7-x,alpha-RbPr[MoO4]2,CsPr[MoO4]2,KCNS,KAg[CO3],BaCr2Ru4O12,MgB2O(OH)6,C17FeO4Pt,Na4Ti2Si8O22[H2O]4,NaGdCu2F8,Ba2TiSi2O8,NaZn[OH]3,Ca2MgSi2O7,Cu2FeS4Sn,CaRbFe4As4,AsCuSiZr,Rb2TiCu2Se4,YbBaCo4O7,KAg(CN)2,pi-FeMg3Al8Si6,pi-FeMg3Al9Si5,Be3Al2Si6O18,MgB12H12[H2O]12,LiMgAuSn,Mg3B7ClO13,CrFe11MoNi3,CrFe2525Ni6,CuCrCl5[NH3]6,Co3Al2Si3O12,Cu8(Fe,Zn)3Sn2S12,BaCu4[VO][PO4]4,AsPh4CeS8P4Me8,NaCa3[CO3]2F3[H2O],Na3Co(CO3)2Cl,Na6Mg2(SO4)(CO3)4,Cs2ZnFe[CN]6,AB,A5B11,AB3,AB3,A3B13,A3B5,AB7,Cu2(Zn,Fe)SnS4\""
  },
  {
    "objectID": "chapters/booleans.html",
    "href": "chapters/booleans.html",
    "title": "4  Boolean Variables and Conditional Execution",
    "section": "",
    "text": "Jupyter Notebook"
  },
  {
    "objectID": "chapters/booleans.html#boolean-variables",
    "href": "chapters/booleans.html#boolean-variables",
    "title": "4  Boolean Variables and Conditional Execution",
    "section": "4.1 Boolean Variables",
    "text": "4.1 Boolean Variables\nWe have learned about three types of variables in Python: ints, floats, and strings. Another variable type is a boolean, which can be one of two values: True or False. You can assign a boolean variable in the same way that you assign numbers or string, using =\nmyBool = True\nTrue must be capitalized so don’t try true or it won’t be a boolean\nmyBool = true\n\n4.1.1 Boolean Logic\nOften you will want to check to see if some condition is true. For example, maybe you want to know if the radius of a certain satellite’s orbit is bigger or smaller than Mercury’s orbit. To perform this check, there are several boolean operators that will return True or False. Take note of the boolean operators shown in the cell below along with the comments added to explain what they do.\n\nr1 = 3.5e8\nr2 = 2.7e6\n\nr1 > r2 # Is r1 greater than r2\nr1 < r2 # Is r1 less than r2\nr1 >= r2 # Is r1 greater than or equal to r2\nr1 <= r2 # Is r1 less than or equal to r2\nr1 != r2 # Is r1 not equal to r2\nr1 == r2 # Is r1 equal to r2\n\nFalse\n\n\nA word of caution about comparing Python floats using == is in order here. Python floats are stored as a 53-digit, base-2 binary number(that’s a mouthful). If you’re interested in what that means, we can talk more. If you’re not that interested, just know that when you define a float in Python, the number that is stored in the computer is not exactly the number that you think it is. This can cause problems when you are comparing two numbers that you think should be equal but actually aren’t equal in the computer.1 The code below illustrates this problem.\n\na = 0.1\nb = 3 * a\nc = 0.3\nprint(b==c)  # Are they the same number?  You would think they would\n             # be right?\nprint(\" {:.5f} \".format(b))     # They sure look the same.\nprint(\" {:.5f} \".format(c))     # They sure look the same.\nprint(\" {:.45f} \".format(b))  #b--- out to 45 decimal places\nprint(\" {:.45f} \".format(c))  #c--- out to 45 decimal places\n\nFalse\n 0.30000 \n 0.30000 \n 0.300000000000000044408920985006261616945266724 \n 0.299999999999999988897769753748434595763683319 \n\n\nThe first two print statements display the value of b and c to five decimal places. The second two print statements force Python to display the value of b and c out to 45 decimal places. Notice that the true value of b is not exactly equal to 0.3. This is why the statement print(b==c) returns False. The take home message here is that comparing two floats to see if they are equal is always a bad idea. A better way to check to see if two floats are equal (or close enough that we can say they are equal) is to check if the absolute value of their difference is very small, like this:\n\na = 0.1\nb = 3 * a\nc = 0.3\nprint(abs(b - c) < 1e-10)\n\nTrue\n\n\n\n\n4.1.2 Compound Comparisons (Logical Operators)\nComparisons like those shown above can be chained together to make compound comparisons using the and, or, and not operators.\n\n\n\nOperator\nDescription\n\n\n\n\nand\nTests for both being True\n\n\nor\nTests for either being True\n\n\nnot\nTests for False\n\n\n\nThe and operator requires both inputs to be True in order to return True while the or operator requires only one input to be True in order to evaluate at True. The not operator is different in that it only takes a single input value and returns True if and only if the input is False. It is a test for False.\nTruth tables are a good way to visualize the output from compound comparisons.\n\n\n\np\nq\np and q\np or q\n\n\n\n\nTrue\nTrue\nTrue\nTrue\n\n\nTrue\nFalse\nFalse\nTrue\n\n\nFalse\nTrue\nFalse\nTrue\n\n\nFalse\nFalse\nFalse\nFalse\n\n\n\nAs a simple example, suppose you know the density (\\(\\rho\\)) and speed of light (c) for two materials and you’d like to know if both values are bigger for material 1 or material 2.\n\nTo Do:\n\nPredict the output for each compound comparison given below. Add your guess as a comment.\nNow add appropriately-placed print statements to check your guesses.\nModify your guess as needed and discuss any questions with a neighbor.\n\n\n\nc1 = 2.5e8\nc2 = 2.48e8\nρ1 = 450\nρ2 = 580\n\nc1 > c2 and ρ1 > ρ2\nc1 < c2 and ρ1 < ρ2\nc1 > c2 and ρ1 < ρ2\nc1 < c2 and ρ1 > ρ2\n\nc1 > c2 and not ρ1 > ρ2\nc1 < c2 and not ρ1 < ρ2\n\nc1 > c2 or ρ1 > ρ2\nc1 < c2 or ρ1 < ρ2\n\nTrue\n\n\n\n\n4.1.3 Tests for Inclusion\nYou can check for inclusion using the Python in operator. This provides an easy way to see if a character (or word) is present in a long string. Let’s say you have a long string that contains the names of Jupyter’s moons (there are 79 of them!!) and you want to see if a certain moon is included in the list. The in statement let’s us quickly test to see if it is in the list. (see example below)\n\njupytermoons = \"Metis,Adrastea,Amalthea,Thebe,Io,Europa,Ganymede,Callisto,Themisto,Leda,Himalia,Lysithea,Elara,Dia,Carpo,Euporie,Thelxinoe,Euanthe,Helike,Orthosie,Iocaste,Praxidike,Harpalyke,Mneme,Hermippe,Thyone,Ananke,Herse,Aitne,Kale,Taygete,Chaldene,Erinome,Aoede,Kallichore,Kalyke,Carme,Callirrhoe,Eurydome,Pasithee,Kore,Cyllene,Eukelade,Pasiphae,Hegemone,Arche,Isonoe,Sinope,Sponde,Autonoe,Megaclite\"\n\n\"Cyllene\" in jupytermoons\n\nTrue"
  },
  {
    "objectID": "chapters/booleans.html#conditions",
    "href": "chapters/booleans.html#conditions",
    "title": "4  Boolean Variables and Conditional Execution",
    "section": "4.2 Conditions",
    "text": "4.2 Conditions\nConditions allow the user to specify if and when certain lines or blocks of code are executed. Specifically, when a condition is true, the block of indented code directly below it will run.\n\n4.2.1 if statement\nThe if statement is used to control when a block of code runs. Its usage is shown below ending in a colon and the block of code below indented with four spaces. Using the Tab key will also produce four spaces.\n\njupytermoons = \"Metis,Adrastea,Amalthea,Thebe,Io,Europa,Ganymede,Callisto,Themisto,Leda,Himalia,Lysithea,Elara,Dia,Carpo,Euporie,Thelxinoe,Euanthe,Helike,Orthosie,Iocaste,Praxidike,Harpalyke,Mneme,Hermippe,Thyone,Ananke,Herse,Aitne,Kale,Taygete,Chaldene,Erinome,Aoede,Kallichore,Kalyke,Carme,Callirrhoe,Eurydome,Pasithee,Kore,Cyllene,Eukelade,Pasiphae,Hegemone,Arche,Isonoe,Sinope,Sponde,Autonoe,Megaclite\"\n\nif \"Cyllene\" in jupytermoons:\n    found = True\n    print(\"Found Cyllene in the list\")\n    \nif \"Matis\" in jupytermoons:\n    found = True\n    print(\"Found Matis in the list\")\n\nFound Cyllene in the list\n\n\nIf the boolean statement after if is true, the indented code below it will run. If the statement is false, Python just skips the indented lines below. The end of an if code block is determined by the indentation; to signal the end of the block, simply step back the indentation.\n\n\n4.2.2 else Statement\nSometimes there will be an alternate block of code that you want to run if the if statement evaluates to False. The else statement is used to specify this block of code, as shown below.\n\njupytermoons = \"Metis,Adrastea,Amalthea,Thebe,Io,Europa,Ganymede,Callisto,Themisto,Leda,Himalia,Lysithea,Elara,Dia,Carpo,Euporie,Thelxinoe,Euanthe,Helike,Orthosie,Iocaste,Praxidike,Harpalyke,Mneme,Hermippe,Thyone,Ananke,Herse,Aitne,Kale,Taygete,Chaldene,Erinome,Aoede,Kallichore,Kalyke,Carme,Callirrhoe,Eurydome,Pasithee,Kore,Cyllene,Eukelade,Pasiphae,Hegemone,Arche,Isonoe,Sinope,Sponde,Autonoe,Megaclite\"\n\nif \"Cyllene\" in jupytermoons:\n    found = True\n    print(\"Found Cyllene in the string\")\nelse:\n    found = False\n    print(\"Did not find Cyllene in the string\")\n\n    \nif \"Matis\" in jupytermoons:\n    found = True\n    print(\"Found Matis in the string\")\nelse:\n    found = False\n    print(\"Did not find Matis in the string\")\n\nFound Cyllene in the string\nDid not find Matis in the string\n\n\nNotice that the else statement must be followed by a colon and the block of code to be executed is indented, just as in the if block.\nThere is an additional statement called the elif statement, short for “else if”, which is used to add extra conditions below the initial if statement. The block of code below the elif statement only runs if the if statement is false and the elif statement is true. An example is given below.\n\njupytermoons = \"Metis,Adrastea,Amalthea,Thebe,Io,Europa,Ganymede,Callisto,Themisto,Leda,Himalia,Lysithea,Elara,Dia,Carpo,Euporie,Thelxinoe,Euanthe,Helike,Orthosie,Iocaste,Praxidike,Harpalyke,Mneme,Hermippe,Thyone,Ananke,Herse,Aitne,Kale,Taygete,Chaldene,Erinome,Aoede,Kallichore,Kalyke,Carme,Callirrhoe,Eurydome,Pasithee,Kore,Cyllene,Eukelade,Pasiphae,Hegemone,Arche,Isonoe,Sinope,Sponde,Autonoe,Megaclite\"\n\nif \"Matis\" in jupytermoons:\n    foundMatis = True\n    print(\"Found Matis in the string\")\nelif \"Cyllene\" in jupytermoons:\n    foundCyllene = True\n    print(\"Found Cyllene in the string.\")\nelse:\n    foundCyl = False\n    foundMatis = False\n    print(\"Did not find Cyllene or Matis in the string\")\n\nFound Cyllene in the string.\n\n\nIt is worth noting that else statements are not required. If you leave the else statement off and the if statement is false, no code block will execute."
  },
  {
    "objectID": "chapters/booleans.html#flash-cards",
    "href": "chapters/booleans.html#flash-cards",
    "title": "4  Boolean Variables and Conditional Execution",
    "section": "4.3 Flash Cards",
    "text": "4.3 Flash Cards\n\nHow do you check to see if one value is greater than or equal to another one?\nWhich boolean operators should never be used to compare floats?\nWhat is the correct way to determine if two floats are equal to each other (or very close)?\nWhen will the statement p and q evaluate to True?\nWhen will the statement p or q evaluate to True?\nHow do you check to see if a certain sequence of characters is present in a string?\nWhen constructing an if block how does Python know what code to execute if the condition is True?\nRecite Helaman 5:12."
  },
  {
    "objectID": "chapters/booleans.html#exercises",
    "href": "chapters/booleans.html#exercises",
    "title": "4  Boolean Variables and Conditional Execution",
    "section": "4.4 Exercises",
    "text": "4.4 Exercises\n\n(Escape Velocity) The escape velocity is the speed needed for an object to completely escape the gravitational pull of a planet. The expression for escape velocity is \\[ v_\\text{escape} = \\sqrt{2 G M_p \\over r}\\] where \\(G = 6.67 \\times 10^{-11}\\), \\(M_p\\) is the mass of the planet you are trying to escape from, and \\(r\\) is the radius of the planet.\n\nConstruct an if-else code block that checks to see if a guessed speed is bigger or smaller than the escape velocity of Jupiter. The code block should print an appropriate message about the guessed velocity. Jupiter has a mass of \\(M = 1.90 \\times 10^{27}\\) kg and a radius of \\(r = 6.99 \\times 10^7\\) meters.\nModify your guess until both branches of your if-else trigger.\nRepeat for Earth. Earth has a mass of \\(M = 5.98 \\times 10^{24}\\) kg and a radius of \\(r = 6.37 \\times 10^6\\) meters.\n\nG = 6.67e-11\n(Thermoelectrics) A thermoelectric is a material that converts thermal energy into electrical energy and much research is devoted to finding new materials that exhibit this behavior. Good thermoelectrics tend to be materials with high electrical conducitivity (\\(\\sigma > 7 \\times 10^5~\\Omega^{-1} \\text{m}^{-1}\\) ) and low thermal conductivity (\\(\\kappa< 2.0\\) W/ m K ). Write an if-else code block that checks to see if a material’s electrical conductivity is above the threshold and its thermal conductivity is below the threshold. Then choose some values for the conductivities and test your if-else block.\nsigma = 0     # Electrical Conductivity\nkappa = 0    # Thermal Conductivity\nAlloys are often represented by a string containing the elements in the alloy and the relative number of atoms for each element. For example, “Cu2Au” (Copper-2-Gold) means that the alloy is made of copper and gold and there are two copper atoms for every gold atom. Write some python code that calculates the total number of atoms in an alloy. The code should include a print statement to display the result. Then check your code on the alloys in the table below. You can assume that all elements have two-character symbols even though that isn’t true; we won’t consider any one-character symbols in this problem.\n\nHints:\n\nThe possible lengths for the strings are 4 (one atom per element), 5 (one atom for one element and more for the other), or 6 (more than one atom for both elements).\nMy code for this problem was about 15 lines long and it required a nested if-else block (an if-else inside of an if block).\n\nYou may find the isdigit() function to be helpful. Do you remember how to use it and what it does?\n\n\n\n\n\n\nAlloy\n\n\n\n\n\n\n“Cr3Si”\n“Al2Cu”\n“NbPd3”\n“CaIn2”\n“Al3Zr4”\n\n\n\nalloy = \"CaIn2\"  \n\nThe quadratic equation has two solutions and they can be positive, negative, or complex. Often the complex and/or negative solutions are not relavant/meaningful. Write an if/elif/else block of code that checks what type of solutions will result and only displays the real, positive solution(s) if they exist. If there is no positive solution, the code should display a message indicating such. Then check your code with the values given below. As a reminder, here is the quadratic equation: \\[ x = {- b \\pm \\sqrt{b^2 - 4 a c} \\over 2a}  \\]\n\na = 2, b = 3, c = 8 (no real solutions)\na = 1, b = -3, c = 2 (two positive solutions)\na = 1, b = -3, c = -2 (one positive solution and one negative solution)\n# Python code here.\n\n(Triangle Classification) There is a simple criteria to determine whether a triangle can be formed from a set of specified side lengths. The criteria states that the sum of any two sides must be larger than the third side. This criteria must be satisified for all possible combinations of two sides if the triangle is to be valid. If the triangle is valid, the angles can be found by first using the law of cosines to find the first two angles \\[c^2 = a^2 + b^2 - 2 a b \\cos(C)\\] and then choosing the third angle so that the sum of the three angles add up to \\(180^\\circ\\).\n\nWrite some code that checks to see if a valid triangle can be formed from the given side lengths.\n\nIf a triangle can be formed, use the law of cosines to calculate the triangle’s angles. Print the angles in degrees. Check your code for several choices of side lengths to verify that it is working.\nAll valid triangles are classified according to the largest angle present (acute, obtuse, and right) and also according to their side lengths (scalene - no sides equal, isoscelese - two sides equal and equilateral - all sides equal). Modify your code to determine the classification of a triangle (i.e. obtuse scalene) and print that classification to screen.\n\n\nfrom numpy import arccos,pi\n\n#a = # Side length 1\n#b = # Side length 1\n#c = # Side length 1"
  },
  {
    "objectID": "chapters/listsAndTuples.html",
    "href": "chapters/listsAndTuples.html",
    "title": "5  Lists and Tuples",
    "section": "",
    "text": "Jupyter Notebook\nUp to this point, we have only worked with single numerical values or strings (multiple characters). Often we will want to work with collections of values (perhaps the orbital period of all of the planets in our solar system.) and it will be quite inconvenient to store each value into its own variable. Instead, the values can be stored in a list or tuple. Lists and tuples are both collections of elements , like numbers or strings. The key difference between them is that tuples are immutable, which means they cannot be modified after their initial creation. On the other hand, lists are mutable, or able to be modified."
  },
  {
    "objectID": "chapters/listsAndTuples.html#creating-lists",
    "href": "chapters/listsAndTuples.html#creating-lists",
    "title": "5  Lists and Tuples",
    "section": "5.1 Creating Lists",
    "text": "5.1 Creating Lists\nThe easiest way to create a list is by putting the list elements inside of square brackets. Below, we create a list containing the masses of all of the planets in our solar system.\nmass = [1.8986e27,5.6846e26,10.243e25,8.6810e25,5.9736e24,4.8685e24,6.4185e23,3.3022e23]\nNote that square brackets ([]) must be used when creating the list. If you accidentally use parenthesis (())1 or curly brackets ({})2 you’ll end up creating something other than a list.1 Use parenthesis to create a tuple, which is just like a list but cannot be modified.2 Use curly brackets to create a dictionary, which is like a list but can be indexed on any data type, not just integers.\nLists can contain any type of data and the type of data doesn’t have to be the same for all of the elements. Below, we create a list of the electron configurations for the first 10 elements on the periodic table.\nelectrons = [\"1s1\",\"1s2\", \"1s2-2s1\",\"1s2-2s2\",\"1s2-2s2-2p1\",\"1s2-2s2-2p2\",\"1s2-2s2-2p3\",\"1s2-2s2-2p4\",\"1s2-2s2-2p5\",\"1s2-2s2-2p6\"]\nLists can contain mixed data types. Below we construct a list of the electrical conductivities of three metals.\nconductivity = [\"Gold\",4.10e7,\"Copper\",5.96e7,\"Aluminum\",3.5e7]\nIf the elements of a list are also lists, we call it a nested list.\nconductivity = [[1,2,3],[4,5,6],[7,8,9]]\n\n5.1.1 The range function\nOften it will be necessary to generate a (possibly very long) list of integers. Instead of constructing the list by typing these numbers one by one, Python has a built-in function called range() that will do it for you. The range() function requires at least one argument to tell it how high the range should be.\n\na = range(10)  # Generate a list of integers up to 10\na\n\nrange(0, 10)\n\n\nThis output probably wasn’t what you expected. Instead of generating the full list of numbers, Python generates a range object that stands in place of it because it requires less memory. (Consider what might happen to your computer’s memory if you did range(1000000000000).) To force Python to generate the list, you can convert the range object into a list using the list() function.\n\na = range(10)  # Generate a list of integers up to 10\nlist(a)\n\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\nThe range function can be called with up to three arguments: range(start,end,stepsize). Consistent with indexing, the range includes the start value and excludes the end value. Below we generate a list of integers starting at 5, ending at 100 with a step size of 5.\n\nmyList = range(5,100,5)\nlist(myList)\n\n[5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95]\n\n\n\nTo Do:\nUse the range function to generate a list of even numbers from 8 to 88. (the list should include 88!)\n\n# Python Code Here!"
  },
  {
    "objectID": "chapters/listsAndTuples.html#indexing-and-slicing-lists",
    "href": "chapters/listsAndTuples.html#indexing-and-slicing-lists",
    "title": "5  Lists and Tuples",
    "section": "5.2 Indexing and Slicing Lists",
    "text": "5.2 Indexing and Slicing Lists\nIndexing is used to access individual elements of a list, and it is similar to indexing strings. The index is the position of the desired element in the list and the index numbering starts at zero. Accessing an element of a list is done by placing the numerical index of the element we want in square brackets behind the list name. For example, if we want the electron configuration of the first element in our list from above, we use electrons[0] and the electron configuration for the second element would be electrons[1] and so on. Just as with string, negative indices can be used to access list elements counting from the back of the list forward.\nelectrons = [\"1s1\",\"1s2\", \"1s2-2s1\",\"1s2-2s2\",\"1s2-2s2-2p1\",\"1s2-2s2-2p2\",\"1s2-2s2-2p3\",\"1s2-2s2-2p4\",\"1s2-2s2-2p5\",\"1s2-2s2-2p6\"]\n\nelectrons[1]\nelectrons[-2]\nelectrons[5]\nelectrons[-1]\n\nTo Do:\n\nPredict the output for each of the indexes performed in the cell above.\nUse print statements to check your answers.\nDiscuss any misunderstandings with a peer.\n\n\n# Python Code Here!\nAccessing elements of nested lists requires multiple sets of parenthesis.\nconductivity = [[1,2,3],[4,5,6],[7,8,9]]\n\nx = conductivity[1][0]\ny = conductivity[0][2]\n\nTo Do:\n\nPredict the output for each of the indexes performed in the cell above.\nUse print statements to check your answers.\nDiscuss any misunderstandings with a peer.\n\n\n# Python Code Here!\nSince lists are mutable, we can modify the value of an element in a list using the = operator.\n\nconductivity = [\"Gold\",4.10e7,\"Copper\",5.96e7,\"Aluminum\",3.5e7]\n\nconductivity[1] = 4.15e7\nconductivity\n\n['Gold', 41500000.0, 'Copper', 59600000.0, 'Aluminum', 35000000.0]\n\n\n\nTo Do:\n\nUse a print statement to verify that the conductivity list was indeed modified as expected.\nModify the third element to be “Platinum” and the fourth to be the conductivity of Platinum (9.43e6).\n\n\n# Python Code Here!\nMultiple list elements can be retrieved at once (called slicing) by including the start and stop indices separated by a colon: [start:stop:step]. A convention that occurs throughout python is that the first index is included in the slice but the second is not. (i.e. [included: excluded: step]) Default values for the start location, stop location, and step sizes will be used if these values are omitted. Below we give some examples of slicing.\nelectrons = [\"1s1\",\"1s2\", \"1s2-2s1\",\"1s2-2s2\",\"1s2-2s2-2p1\",\"1s2-2s2-2p2\",\"1s2-2s2-2p3\",\"1s2-2s2-2p4\",\"1s2-2s2-2p5\",\"1s2-2s2-2p6\"]\n\nelectrons[1:]\nelectrons[1:3]\nelectrons[:3]\nelectrons[1:8:2]\nelectrons[5:2:-1]\n\nTo Do:\n\nPredict the output for the five slices in the cell above.\nUse print statements to check your answers.\nDiscuss any misunderstandings with a peer.\nNow use list slicing to extract every third element of the list in the cell above starting at the beginning.\n\n\n# Python Code Here!"
  },
  {
    "objectID": "chapters/listsAndTuples.html#tests-for-inclusion",
    "href": "chapters/listsAndTuples.html#tests-for-inclusion",
    "title": "5  Lists and Tuples",
    "section": "5.3 Tests for Inclusion",
    "text": "5.3 Tests for Inclusion\nJust as with strings, the in operator can be used with lists to determine if a list element is present. Suppose you have a list of all the known radioactive elements on the periodic table and you’d like to know if Iridium is in the list. The in statement let’s us quickly test to see if it is in the list. (see example below)\n\nradioactiveElements = [\"Technetium\",\"Promethium\",\"Polonium\",\"Astatine\",\"Radon\",\"Francium\",\"Radium\", \"Actinium\", \"Thorium\", \"Protactinium\",\"Uranium\",\"Neptunium\",\"Plutonium\",\"Americium\",\"Curium\",\"Berkelium\",\"Californium\",\"Einsteinium\",\"Fermium\",\"Mendelevium\",\"Nobelium\",\"Lawrencium\",\"Rutherfordium\",\"Dubnium\",\"Seaborgium\",\"Bohrium\",\"Hassium\",\"Meitnerium\",\"Darmstadtium\",\"Roentenium\",\"Copernicium\",\"Nihonium\",\"Flerovium\",\"Moscovium\",\"Livermorium\",\"Tennessine\", \"Oganesson\"]\n\n\"Iridium\" in radioactiveElements\n\nFalse\n\n\nThe in operator will work with numerical data as well.\n\nnumbers = [5,6,3,1,2]\n\n4 in numbers\n\nFalse"
  },
  {
    "objectID": "chapters/listsAndTuples.html#list-methods",
    "href": "chapters/listsAndTuples.html#list-methods",
    "title": "5  Lists and Tuples",
    "section": "5.4 List Methods",
    "text": "5.4 List Methods\nLists have a collection of methods (or functions) for accomplishing routine tasks. Some of the more common list methods are given below. All of the methods given will modify the original list (except copy()). As a reminder, methods only work on the object type that they were designed for (lists in this case) and they are called by appending the method name to the variable you want it to operate on. (e.g. myList.clear())\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\nappend(element)\nAdds a single element to the end of the list.\n\n\nclear()\nRemoves all elements from a list.\n\n\ncopy()\nCreates an independent copy of the list.\n\n\ncount(element)\nCounts the number of occurrences of element in the list.\n\n\nextend([a,b,c,...])\nAdds multiple elements to the end of the list.\n\n\nindex(element)\nReturns the index of the first occurrence of element.\n\n\ninsert(index,element)\nInserts the given element at the specified index.\n\n\npop(index)\nRemoves and returns the element given at index. If no index is provided, it defaults to the last element.\n\n\nremove(element)\nRemoves the first occurrence of element in the list.\n\n\nreverse()\nReverses the order of the entire list.\n\n\nsort()\nSorts the list in place.3\n\n\n\n3 It modifies the original list. In contrast, the function sorted() will leave the original list unchanged.\nTo Do:\nIn the cell below you will find a list containing the speed of sound for several materials and at different temperatures. (in meters/second) Use the list methods in the table above to perform the following:\n\nThe speed of sound in Aluminum is \\(6420\\) m/s. Add two elements to the end of this list: the string “Aluminum” and its speed of sound. Do it two ways, first with append and then with extend.\nRemove the first two elements from this list.\nInsert the removed elements so they appear just after the entry for Helium.\nFind the index location for “Ethyl Alcohol”.\nUse the remove method twice to remove the entry for “Granite” and its associated speed.\nUse the extend method twice to append an entry for the speed of sound for “Steel”, which is 5790 m/s.\n\n\na = [\"Air 0C\",331,\"Air 30C\",343, \"Helium 0C\",970,\"Ethyl Alcohol\",1170,\"Water 20C\",1480, \"Granite\",6000]"
  },
  {
    "objectID": "chapters/listsAndTuples.html#built-in-functions-for-lists",
    "href": "chapters/listsAndTuples.html#built-in-functions-for-lists",
    "title": "5  Lists and Tuples",
    "section": "5.5 Built-in functions for Lists",
    "text": "5.5 Built-in functions for Lists\nPython has several built-in functions that will work with lists. Functions are called by placing the arguments to the function in parenthesis and prepending the name of the function to the parenthesis. Here are a few common functions that are used with lists: (the zip and enumerate functions will be explained in greater detail next chapter.)\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\nlen(list)\nReturns the number of elements in the list.\n\n\nmax(list)\nFinds the largest element in the list.\n\n\nmin(list)\nFinds the smallest element in the list.\n\n\nsum(list)\nReturns the sum of the elements in the list.4\n\n\nlistOne + listTwo\nJoins listOne with listTwo to form one list.\n\n\n2 * list\nRepeat list and concatenate to itself, making the list twice as long.\n\n\ndel list[index]\nDeletes list elements located at index. Can also specify a range of values.\n\n\nzip(listOne,listTwo)\nZips two lists together. (Creates [(a1,b1),(a2,b2),...] from [a1,a2,a3...] and [b1,b2,b3...]\n\n\nenumerate(list)\nZips a list to the index value for that list (Creates [(0,a1),(1,a2),(2,a3)...] from [a1,a2,a3...]\n\n\n\n4 Only works if the list contains only ints and floats.\nTo Do:\nThe cell below contains two lists with strings in them and a third list that contains numbers. Use these lists to evaluate all of the functions from the table above, printing the result so that you can see what action was performed. Specifically, seek to answer the following questions:\n\nWhat happens when you find the max or min of a list of strings? (list of numbers?)\nWhat happens when you add two lists together? Does it matter if one list contains strings and the other numbers?\nWhat happens when you multiply a list by an integer? Does it matter if the list contains numbers vs strings?\nWhat happens when you zip two lists together? Does it matter if the list contains numbers or strings?\n\n\na = [\"l\",\"j\",\"n\"]\nb = [\"r\",\"s\",\"t\"]\nc = [4,7,8]"
  },
  {
    "objectID": "chapters/listsAndTuples.html#tuples",
    "href": "chapters/listsAndTuples.html#tuples",
    "title": "5  Lists and Tuples",
    "section": "5.6 Tuples",
    "text": "5.6 Tuples\nTuples are another object type similar to lists except that they are immutable… that is to say, they cannot be modified once created. They look similar to lists except that they are created using parenthesis instead of brackets. Because you can’t change the elements of a tuple, they are often used so that you don’t inadvertently modify (and lose) critical data. You can think of it as locking a file on your computer to avoid inadvertently modifying it and losing the original content.\nBelow is a tuple containing the Balmer series, which are the wavelengths of visible light emitted by Hydrogen gas. These values are well known and you most likely wouldn’t want to make any modifications to this list which makes them a prime candidate for a tuple. Storing them in a tuple will help prevent you from inadvertently modifying the list. Indexing and slicing work exactly the same as with lists and strings, so we can still use the values inside of a tuple to perform simple calculations. There are only two methods associated with tuples: count(element) and index(element). Their usage is identical to the list methods.\n\nbalmer = (383.5384,388.9049,397.0072,410.174,434.047,486.133,656.272,656.2852)\nbalmer.index(410.174)\nlen(balmer)\n\n8\n\n\nYou can transform a list into a tuple using the tuple function.\nbalmer = [383.5384,388.9049,397.0072,410.174,434.047,486.133,656.272,656.2852]\n\nbalmerTup = tuple(balmer)"
  },
  {
    "objectID": "chapters/listsAndTuples.html#flash-cards",
    "href": "chapters/listsAndTuples.html#flash-cards",
    "title": "5  Lists and Tuples",
    "section": "5.7 Flash Cards",
    "text": "5.7 Flash Cards\n\nWhat is the difference between a list and a tuple?\nWhat is it called when the elements of a list are also lists?\nWhat is the index value of the first element in a list?\nHow do you access elements of a list counting from the back of the list forward? (Give an example.)\nWhat does it mean to “slice” a list?\nHow do you extract every third element of a list, starting at the second element and stopping at (but including) the 11th element?\nHow can you check to see if an element is present in a list? (Give an example)\nWhat does the range function do? (Give an example of how to use it.)\nWhat happens when you multiply a list and an integer?\nWhat happens when you add two lists together?\nExplain the usage of the extend list method.\nExplain the usage of the insert list method.\nExplain the usage of the remove list method.\nExplain the usage of the pop list method.\nWhere is the record of Jesus calming the storm?"
  },
  {
    "objectID": "chapters/listsAndTuples.html#exercises",
    "href": "chapters/listsAndTuples.html#exercises",
    "title": "5  Lists and Tuples",
    "section": "5.8 Exercises",
    "text": "5.8 Exercises\n\nUse the range function and list slicing techniques to generate a list of every other multiple of 3 starting at 3 and going up to and including 201.\n\n# Python code here.\n\nThe code in the cell below will generate a list of 200 random integers in the range \\(0 \\rightarrow 15\\).\n\nPrint the list and inspect it to verify that you understand what it contains.\nVerify that there indeed are 200 numbers in the list (Use a function, don’t count them one by one.)\nHow many 7’s appear in the list? (Use a function, don’t count them by hand)\nWhat is the largest and smallest numbers that appear in the list?\nFind the index of the first occurrence of the number 1.\nSort the list and use a print statement to verify that you were successful.\n\n\nfrom random import randint\n\ndata = [randint(0,15) for x in range(200)]\n\nThe cell below contains a string containing some elementary particles in physics, with the names of the particles separated by commas.\n\nUse the split method to generate a list of particles.\nUse the len function to determine how many particles are in the list.\nsort the list and use a print statement to verify that the sort worked.\n\n\nparticles = \"up quark,down quark,charm quark,top quark,strange quark,bottom quark,electron,muon,tau,electron-neutrino,muon-neutrino,tau-neutrino,gluon,photon,z boson,w boson,higgs boson\"\n\n(Fibonacci Series) The Fibonacci series is a very famous sequence of numbers that appears repeatedly in nature. In the cell below you will find a list that contains the first seven Fibonacci numbers.\n\nStudy the sequence of numbers until you identify the pattern.\nOnce you know the pattern, use extend to add the next 10 Fibonacci numbers to the list.\nThe Fibonacci sequence has some very interesting properties (listed below). Add some code in the cell below to verify each of them.\n\nThe ratio of the last two numbers in the sequence gets closer and closer to the ‘Golden Ratio’ (1.618…) as the sequence gets longer. Calculate this ratio for short sequences and then increase the length of the sequence and watch the ratio approach 1.618…\nThe sum of any ten consecutive Fibonacci numbers is divisible by 11. Check this for at least three different length-ten slices.\nThe sum of the first \\(n\\) Fibonacci numbers is equal to the \\((n + 2)\\)-th Fibonacci number minus 1. Check this for at least three different values of \\(n\\).\n\n\n\nfibonacci = [1,1,2,3,5,8,13]\n\n(Projectile Motion) Below you will find a nested list containing the x-y coordinates for a home run baseball hit. Answer the following questions about the baseball’s trajectory:\n\nHow many x-y pairs are in the list?\nFind the horizontal distance between the launch and landing point for the projectile.\nHow far had the baseball traveled horizontally when it reached its max height? To answer this question, follow the steps below:\n\nUse list comprehension to extract the x and y coordinates of the baseball into separate lists. Call these lists x and y.\nUse the index and max functions to find the index corresponding to the maximum value in the list of y-coordinates. This is the max height of the baseball.\nNow use the index found in part 2 to find the x-coordinate of the baseball when it is at max height.\n\n\n\ncoords = [(0.0, 0.0), (0.19505076661811682, 0.11248986724462198), (0.39010153323623364, 0.22473424375326276), (0.5851522998543505, 0.33673312952592227), (0.7802030664724673, 0.4484865245626006), (0.975253833090584, 0.5599944288632976), (1.170304599708701, 0.6712568424280134), (1.3653553663268179, 0.7822737652567482), (1.5604061329449346, 0.8930451973495016), (1.7554568995630513, 1.0035711387062738), (1.950507666181168, 1.1138515893270646), (2.145558432799285, 1.2238865492118742), (2.340609199417402, 1.3336760183607028), (2.535659966035519, 1.4432199967735502), (2.7307107326536357, 1.5525184844504163), (2.9257614992717524, 1.661571481391301), (3.120812265889869, 1.7703789875962046), (3.315863032507986, 1.8789410030651268), (3.5109137991261026, 1.987257527798068), (3.7059645657442193, 2.095328561795028), (3.901015332362336, 2.2031541050560066), (4.096066098980454, 2.310734157581004), (4.29111686559857, 2.4180687193700203), (4.486167632216687, 2.525157790423055), (4.681218398834804, 2.632001370740109), (4.87626916545292, 2.738599460321182), (5.071319932071038, 2.8449520591662734), (5.266370698689155, 2.951059167275383), (5.4614214653072715, 3.0569207846485122), (5.656472231925388, 3.1625369112856596), (5.851522998543505, 3.267907547186826), (6.046573765161622, 3.3730326923520115), (6.241624531779738, 3.477912346781215), (6.436675298397855, 3.5825465104744376), (6.631726065015972, 3.686935183431679), (6.826776831634088, 3.791078365652939), (7.021827598252205, 3.894976057138219), (7.216878364870322, 3.9986282578875167), (7.411929131488439, 4.102034967900833), (7.606979898106555, 4.205196187178169), (7.802030664724672, 4.308111915719523), (7.99708143134279, 4.410782153524895), (8.192132197960907, 4.513206900594287), (8.387182964579024, 4.6153861569276975), (8.58223373119714, 4.717319922525127), (8.777284497815257, 4.819008197386575), (8.972335264433374, 4.920450981512041), (9.16738603105149, 5.021648274901527), (9.362436797669607, 5.122600077555031), (9.557487564287724, 5.223306389472555), (9.75253833090584, 5.323767210654097), (9.94758909752396, 5.423982541099658), (10.142639864142076, 5.523952380809237), (10.337690630760193, 5.623676729782836), (10.53274139737831, 5.723155588020452), (10.727792163996426, 5.822388955522088), (10.922842930614543, 5.921376832287743), (11.11789369723266, 6.020119218317416), (11.312944463850776, 6.118616113611108), (11.507995230468893, 6.216867518168819), (11.70304599708701, 6.314873431990549), (11.898096763705126, 6.4126338550762965), (12.093147530323243, 6.510148787426064), (12.28819829694136, 6.60741822903985), (12.483249063559477, 6.704442179917654), (12.678299830177593, 6.801220640059478), (12.87335059679571, 6.89775360946532), (13.068401363413827, 6.99404108813518), (13.263452130031943, 7.09008307606906), (13.45850289665006, 7.185879573266959), (13.653553663268177, 7.281430579728876), (13.848604429886294, 7.376736095454812), (14.04365519650441, 7.471796120444768), (14.238705963122527, 7.56661065469874), (14.433756729740644, 7.661179698216734), (14.62880749635876, 7.7555032509987445), (14.823858262976877, 7.849581313044776), (15.018909029594994, 7.943413884354824), (15.21395979621311, 8.037000964928891), (15.409010562831227, 8.130342554766976), (15.604061329449344, 8.223438653869083), (15.799112096067462, 8.316289262235207), (15.99416286268558, 8.40889437986535), (16.189213629303698, 8.501254006759511), (16.384264395921814, 8.59336814291769), (16.57931516253993, 8.68523678833989), (16.774365929158048, 8.776859943026107), (16.969416695776165, 8.868237606976345), (17.16446746239428, 8.959369780190599), (17.359518229012398, 9.050256462668875), (17.554568995630515, 9.140897654411166), (17.74961976224863, 9.231293355417478), (17.944670528866748, 9.321443565687808), (18.139721295484865, 9.411348285222157), (18.33477206210298, 9.501007514020525), (18.529822828721098, 9.590421252082912), (18.724873595339215, 9.679589499409317), (18.91992436195733, 9.768512255999742), (19.11497512857545, 9.857189521854185), (19.310025895193565, 9.945621296972647), (19.50507666181168, 10.033807581355129), (19.7001274284298, 10.121748375001626), (19.89517819504792, 10.209443677912146), (20.090228961666035, 10.296893490086681), (20.285279728284152, 10.384097811525239), (20.48033049490227, 10.471056642227811), (20.675381261520386, 10.557769982194406), (20.870432028138502, 10.644237831425016), (21.06548279475662, 10.730460189919649), (21.260533561374736, 10.816437057678296), (21.455584327992852, 10.902168434700966), (21.65063509461097, 10.987654320987652), (21.845685861229086, 11.072894716538359), (22.040736627847203, 11.157889621353084), (22.23578739446532, 11.242639035431827), (22.430838161083436, 11.327142958774589), (22.625888927701553, 11.41140139138137), (22.82093969431967, 11.49541433325217), (23.015990460937786, 11.579181784386988), (23.211041227555903, 11.662703744785825), (23.40609199417402, 11.745980214448682), (23.601142760792136, 11.829011193375555), (23.796193527410253, 11.91179668156645), (23.99124429402837, 11.99433667902136), (24.186295060646486, 12.076631185740293), (24.381345827264603, 12.158680201723243), (24.57639659388272, 12.240483726970211), (24.771447360500837, 12.322041761481199), (24.966498127118953, 12.403354305256205), (25.16154889373707, 12.48442135829523), (25.356599660355187, 12.565242920598275), (25.551650426973303, 12.645818992165335), (25.74670119359142, 12.726149572996416), (25.941751960209537, 12.806234663091518), (26.136802726827653, 12.886074262450634), (26.33185349344577, 12.965668371073773), (26.526904260063887, 13.04501698896093), (26.721955026682004, 13.124120116112106), (26.91700579330012, 13.202977752527298), (27.112056559918237, 13.281589898206512), (27.307107326536354, 13.359956553149743), (27.50215809315447, 13.438077717356993), (27.697208859772587, 13.515953390828262), (27.892259626390704, 13.59358357356355), (28.08731039300882, 13.670968265562859), (28.282361159626937, 13.748107466826182), (28.477411926245054, 13.825001177353526), (28.67246269286317, 13.901649397144887), (28.867513459481287, 13.978052126200271), (29.062564226099404, 14.054209364519672), (29.25761499271752, 14.13012111210309), (29.452665759335638, 14.205787368950528), (29.647716525953754, 14.281208135061986), (29.84276729257187, 14.356383410437461), (30.037818059189988, 14.431313195076955), (30.232868825808104, 14.505997488980466), (30.42791959242622, 14.580436292148), (30.622970359044338, 14.65462960457955), (30.818021125662455, 14.72857742627512), (31.01307189228057, 14.802279757234707), (31.208122658898688, 14.875736597458317), (31.40317342551681, 14.948947946945944), (31.598224192134925, 15.021913805697588), (31.79327495875304, 15.09463417371325), (31.98832572537116, 15.16710905099293), (32.18337649198928, 15.239338437536635), (32.378427258607395, 15.311322333344354), (32.57347802522551, 15.383060738416091), (32.76852879184363, 15.454553652751848), (32.963579558461745, 15.525801076351627), (33.15863032507986, 15.596803009215419), (33.35368109169798, 15.667559451343232), (33.548731858316096, 15.738070402735064), (33.74378262493421, 15.808335863390914), (33.93883339155233, 15.878355833310787), (34.133884158170446, 15.948130312494673), (34.32893492478856, 16.01765930094258), (34.52398569140668, 16.086942798654505), (34.719036458024796, 16.155980805630453), (34.91408722464291, 16.224773321870416), (35.10913799126103, 16.293320347374397), (35.304188757879146, 16.361621882142398), (35.49923952449726, 16.42967792617442), (35.69429029111538, 16.49748847947046), (35.889341057733496, 16.565053542030515), (36.08439182435161, 16.63237311385459), (36.27944259096973, 16.69944719494269), (36.474493357587846, 16.766275785294802), (36.66954412420596, 16.832858884910934), (36.86459489082408, 16.899196493791084), (37.059645657442196, 16.965288611935257), (37.25469642406031, 17.031135239343445), (37.44974719067843, 17.09673637601565), (37.64479795729655, 17.162092021951878), (37.83984872391466, 17.227202177152122), (38.03489949053278, 17.29206684161639), (38.2299502571509, 17.35668601534467), (38.42500102376901, 17.42105969833697), (38.62005179038713, 17.485187890593295), (38.81510255700525, 17.54907059211363), (39.01015332362336, 17.61270780289799), (39.20520409024148, 17.676099522946366), (39.4002548568596, 17.73924575225876), (39.59530562347772, 17.802146490835177), (39.79035639009584, 17.86480173867561), (39.985407156713954, 17.92721149578006), (40.18045792333207, 17.98937576214853), (40.37550868995019, 18.051294537781022), (40.570559456568304, 18.11296782267753), (40.76561022318642, 18.174395616838055), (40.96066098980454, 18.2355779202626), (41.155711756422654, 18.296514732951167), (41.35076252304077, 18.35720605490375), (41.54581328965889, 18.417651886120353), (41.740864056277005, 18.477852226600973), (41.93591482289512, 18.537807076345608), (42.13096558951324, 18.597516435354272), (42.326016356131355, 18.656980303626945), (42.52106712274947, 18.71619868116364), (42.71611788936759, 18.775171567964357), (42.911168655985705, 18.833898964029093), (43.10621942260382, 18.892380869357844), (43.30127018922194, 18.950617283950614), (43.496320955840055, 19.008608207807402), (43.69137172245817, 19.066353640928213), (43.88642248907629, 19.12385358331304), (44.081473255694405, 19.181108034961884), (44.27652402231252, 19.238116995874748), (44.47157478893064, 19.294880466051634), (44.666625555548755, 19.351398445492535), (44.86167632216687, 19.407670934197455), (45.05672708878499, 19.463697932166397), (45.251777855403105, 19.519479439399355), (45.44682862202122, 19.575015455896335), (45.64187938863934, 19.63030598165733), (45.836930155257456, 19.685351016682343), (46.03198092187557, 19.74015056097138), (46.22703168849369, 19.79470461452443), (46.422082455111806, 19.8490131773415), (46.61713322172992, 19.90307624942259), (46.81218398834804, 19.9568938307677), (47.007234754966156, 20.010465921376827), (47.20228552158427, 20.063792521249972), (47.39733628820239, 20.11687363038714), (47.592387054820506, 20.169709248788322), (47.78743782143862, 20.222299376453527), (47.98248858805674, 20.274644013382748), (48.177539354674856, 20.326743159575987), (48.37259012129297, 20.378596815033248), (48.56764088791109, 20.430204979754524), (48.762691654529206, 20.481567653739823), (48.95774242114732, 20.532684836989134), (49.15279318776544, 20.583556529502474), (49.347843954383556, 20.634182731279825), (49.54289472100167, 20.684563442321195), (49.73794548761979, 20.734698662626585), (49.932996254237906, 20.784588392195996), (50.12804702085602, 20.834232631029423), (50.32309778747414, 20.883631379126868), (50.51814855409226, 20.932784636488336), (50.71319932071037, 20.98169240311382), (50.90825008732849, 21.030354679003324), (51.10330085394661, 21.078771464156844), (51.29835162056472, 21.126942758574383), (51.49340238718284, 21.174868562255945), (51.68845315380096, 21.222548875201525), (51.88350392041907, 21.26998369741112), (52.07855468703719, 21.317173028884735), (52.27360545365531, 21.364116869622368), (52.468656220273424, 21.410815219624023), (52.66370698689154, 21.457268078889697), (52.85875775350966, 21.503475447419383), (53.053808520127774, 21.54943732521309), (53.24885928674589, 21.595153712270825), (53.44391005336401, 21.64062460859257), (53.638960819982124, 21.685850014178335), (53.83401158660024, 21.73082992902812), (54.02906235321836, 21.775564353141924), (54.224113119836474, 21.820053286519745), (54.41916388645459, 21.864296729161588), (54.61421465307271, 21.908294681067446), (54.809265419690824, 21.952047142237326), (55.00431618630894, 21.995554112671222), (55.19936695292706, 22.03881559236914), (55.394417719545174, 22.081831581331073), (55.58946848616329, 22.12460207955703), (55.78451925278141, 22.167127087047), (55.979570019399524, 22.209406603800993), (56.17462078601764, 22.251440629819005), (56.36967155263576, 22.293229165101028), (56.564722319253875, 22.334772209647078), (56.75977308587199, 22.376069763457146), (56.95482385249011, 22.41712182653123), (57.149874619108225, 22.457928398869335), (57.34492538572634, 22.498489480471452), (57.53997615234446, 22.538805071337595), (57.735026918962575, 22.57887517146776), (57.93007768558069, 22.618699780861935), (58.12512845219881, 22.658278899520134), (58.320179218816925, 22.697612527442352), (58.51522998543504, 22.736700664628586), (58.71028075205316, 22.77554331107884), (58.905331518671275, 22.81414046679311), (59.10038228528939, 22.852492131771406), (59.29543305190751, 22.890598306013715), (59.490483818525625, 22.928458989520042), (59.68553458514374, 22.96607418229039), (59.88058535176186, 23.003443884324764), (60.075636118379975, 23.040568095623144), (60.27068688499809, 23.07744681618555), (60.46573765161621, 23.114080046011967), (60.660788418234326, 23.150467785102414), (60.85583918485244, 23.186610033456876), (61.05088995147056, 23.22250679107535), (61.245940718088676, 23.25815805795785), (61.44099148470679, 23.293563834104365), (61.63604225132491, 23.328724119514902), (61.831093017943026, 23.36363891418946), (62.02614378456114, 23.39830821812803), (62.22119455117926, 23.432732031330623), (62.416245317797376, 23.46691035379724), (62.6112960844155, 23.500843185527863), (62.80634685103362, 23.534530526522516), (63.00139761765173, 23.567972376781178), (63.19644838426985, 23.60116873630387), (63.39149915088797, 23.634119605090568), (63.58654991750608, 23.666824983141293), (63.7816006841242, 23.69928487045604), (63.97665145074232, 23.731499267034792), (64.17170221736043, 23.763468172877577), (64.36675298397856, 23.795191587984377), (64.56180375059667, 23.82666951235519), (64.75685451721479, 23.85790194599003), (64.9519052838329, 23.88888888888888), (65.14695605045102, 23.919630341051757), (65.34200681706913, 23.95012630247865), (65.53705758368726, 23.98037677316956), (65.73210835030537, 24.01038175312449), (65.92715911692349, 24.04014124234344), (66.1222098835416, 24.069655240826407), (66.31726065015972, 24.09892374857339), (66.51231141677783, 24.127946765584394), (66.70736218339596, 24.15672429185942), (66.90241295001407, 24.185256327398466), (67.09746371663219, 24.213542872201522), (67.2925144832503, 24.241583926268603), (67.48756524986842, 24.2693794895997), (67.68261601648653, 24.29692956219482), (67.87766678310466, 24.32423414405396), (68.07271754972277, 24.35129323517711), (68.26776831634089, 24.378106835564285), (68.462819082959, 24.404674945215483), (68.65786984957712, 24.43099756413069), (68.85292061619523, 24.457074692309924), (69.04797138281336, 24.482906329753163), (69.24302214943147, 24.508492476460436), (69.43807291604959, 24.533833132431724), (69.6331236826677, 24.558928297667027), (69.82817444928583, 24.583777972166352), (70.02322521590393, 24.6083821559297), (70.21827598252206, 24.632740848957056), (70.41332674914017, 24.656854051248438), (70.60837751575829, 24.680721762803834), (70.8034282823764, 24.704343983623254), (70.99847904899453, 24.727720713706695), (71.19352981561264, 24.750851953054145), (71.38858058223076, 24.77373770166562), (71.58363134884887, 24.79637795954112), (71.77868211546699, 24.818772726680624), (71.9737328820851, 24.84092200308416), (72.16878364870323, 24.862825788751703), (72.36383441532134, 24.884484083683272), (72.55888518193946, 24.905896887878864), (72.75393594855757, 24.927064201338467), (72.94898671517569, 24.947986024062093), (73.1440374817938, 24.96866235604974), (73.33908824841193, 24.989093197301397), (73.53413901503004, 25.00927854781708), (73.72918978164816, 25.029218407596776), (73.92424054826627, 25.048912776640496), (74.11929131488439, 25.068361654948237), (74.3143420815025, 25.087565042519987), (74.50939284812063, 25.106522939355767), (74.70444361473874, 25.12523534545556), (74.89949438135686, 25.143702260819367), (75.09454514797497, 25.161923685447203), (75.2895959145931, 25.179899619339047), (75.4846466812112, 25.19763006249492), (75.67969744782933, 25.215115014914808), (75.87474821444744, 25.23235447659871), (76.06979898106556, 25.249348447546637), (76.26484974768367, 25.266096927758586), (76.4599005143018, 25.282599917234542), (76.6549512809199, 25.298857415974524), (76.85000204753803, 25.31486942397852), (77.04505281415614, 25.330635941246545), (77.24010358077426, 25.346156967778583), (77.43515434739237, 25.361432503574637), (77.6302051140105, 25.376462548634713), (77.8252558806286, 25.3912471029588), (78.02030664724673, 25.40578616654692), (78.21535741386485, 25.42007973939905), (78.41040818048296, 25.434127821515197), (78.60545894710108, 25.44793041289537), (78.8005097137192, 25.461487513539556), (78.99556048033732, 25.474799123447763), (79.19061124695544, 25.487865242619993), (79.38566201357355, 25.50068587105623), (79.58071278019167, 25.513261008756498), (79.77576354680978, 25.525590655720777), (79.97081431342791, 25.537674811949078), (80.16586508004602, 25.5495134774414), (80.36091584666414, 25.561106652197733), (80.55596661328225, 25.572454336218094), (80.75101737990038, 25.58355652950247), (80.94606814651848, 25.59441323205086), (81.14111891313661, 25.605024443863275), (81.33616967975472, 25.615390164939704), (81.53122044637284, 25.625510395280156), (81.72627121299095, 25.63538513488463), (81.92132197960908, 25.645014383753114), (82.11637274622719, 25.654398141885622), (82.31142351284531, 25.66353640928215), (82.50647427946342, 25.67242918594269), (82.70152504608154, 25.681076471867254), (82.89657581269965, 25.689478267055833), (83.09162657931778, 25.697634571508438), (83.28667734593589, 25.705545385225058), (83.48172811255401, 25.713210708205693), (83.67677887917212, 25.72063054045035), (83.87182964579024, 25.727804881959024), (84.06688041240835, 25.73473373273172), (84.26193117902648, 25.741417092768437), (84.45698194564459, 25.747854962069166), (84.65203271226271, 25.754047340633917), (84.84708347888082, 25.75999422846269), (85.04213424549894, 25.765695625555473), (85.23718501211705, 25.77115153191228), (85.43223577873518, 25.776361947533108), (85.62728654535329, 25.781326872417953), (85.82233731197141, 25.78604630656682), (86.01738807858952, 25.790520249979696), (86.21243884520764, 25.794748702656598), (86.40748961182575, 25.798731664597522), (86.60254037844388, 25.802469135802458), (86.79759114506199, 25.80596111627142), (86.99264191168011, 25.809207606004392), (87.18769267829822, 25.812208605001388), (87.38274344491634, 25.814964113262405), (87.57779421153445, 25.81747413078743), (87.77284497815258, 25.819738657576487), (87.96789574477069, 25.821757693629557), (88.16294651138881, 25.823531238946646), (88.35799727800692, 25.825059293527755), (88.55304804462504, 25.826341857372874), (88.74809881124315, 25.827378930482023), (88.94314957786128, 25.82817051285519), (89.13820034447939, 25.828716604492367), (89.33325111109751, 25.829017205393573), (89.52830187771562, 25.829072315558797), (89.72335264433374, 25.82888193498803), (89.91840341095185, 25.82844606368129), (90.11345417756998, 25.827764701638564), (90.30850494418809, 25.82683784885986), (90.50355571080621, 25.825665505345178), (90.69860647742432, 25.824247671094508), (90.89365724404244, 25.82258434610786), (91.08870801066055, 25.820675530385234), (91.28375877727868, 25.818521223926616), (91.47880954389679, 25.81612142673203), (91.67386031051491, 25.81347613880145), (91.86891107713302, 25.8105853601349), (92.06396184375114, 25.807449090732366), (92.25901261036925, 25.804067330593845), (92.45406337698738, 25.800440079719348), (92.64911414360549, 25.79656733810887), (92.84416491022361, 25.792449105762408), (93.03921567684172, 25.78808538267997), (93.23426644345984, 25.783476168861544), (93.42931721007795, 25.77862146430714), (93.62436797669608, 25.773521269016758), (93.81941874331419, 25.768175582990388), (94.01446950993231, 25.76258440622804), (94.20952027655042, 25.756747738729707), (94.40457104316854, 25.750665580495397), (94.59962180978665, 25.74433793152511), (94.79467257640478, 25.737764791818833), (94.98972334302289, 25.730946161376583), (95.18477410964101, 25.723882040198347), (95.37982487625912, 25.716572428284127), (95.57487564287725, 25.709017325633933), (95.76992640949535, 25.701216732247747), (95.96497717611348, 25.69317064812559), (96.16002794273159, 25.684879073267453), (96.35507870934971, 25.676342007673327), (96.55012947596782, 25.667559451343223), (96.74518024258595, 25.65853140427714), (96.94023100920406, 25.64925786647507), (97.13528177582218, 25.639738837937024), (97.33033254244029, 25.629974318662995), (97.52538330905841, 25.61996430865299), (97.72043407567652, 25.609708807906994), (97.91548484229465, 25.59920781642502), (98.11053560891276, 25.588461334207068), (98.30558637553088, 25.577469361253137), (98.50063714214899, 25.566231897563217), (98.69568790876711, 25.554748943137323), (98.89073867538522, 25.543020497975437), (99.08578944200335, 25.53104656207758), (99.28084020862146, 25.518827135443743), (99.47589097523958, 25.506362218073917), (99.67094174185769, 25.493651809968114), (99.86599250847581, 25.480695911126332), (100.06104327509392, 25.467494521548566), (100.25609404171205, 25.454047641234816), (100.45114480833016, 25.440355270185087), (100.64619557494828, 25.42641740839938), (100.84124634156639, 25.41223405587769), (101.03629710818451, 25.397805212620014), (101.23134787480262, 25.383130878626368), (101.42639864142075, 25.36821105389673), (101.62144940803886, 25.353045738431113), (101.81650017465698, 25.33763493222952), (102.01155094127509, 25.321978635291934), (102.20660170789321, 25.306076847618378), (102.40165247451132, 25.289929569208837), (102.59670324112945, 25.27353680006331), (102.79175400774756, 25.256898540181815), (102.98680477436568, 25.240014789564327), (103.18185554098379, 25.22288554821086), (103.37690630760191, 25.205510816121418), (103.57195707422002, 25.187890593295982), (103.76700784083815, 25.170024879734576), (103.96205860745626, 25.151913675437193), (104.15710937407438, 25.133556980403817), (104.35216014069249, 25.114954794634464), (104.54721090731061, 25.096107118129126), (104.74226167392872, 25.077013950887817), (104.93731244054685, 25.057675292910517), (105.13236320716496, 25.03809114419723), (105.32741397378308, 25.018261504747983), (105.52246474040119, 24.998186374562742), (105.71751550701931, 24.977865753641517), (105.91256627363742, 24.95729964198432), (106.10761704025555, 24.936488039591126), (106.30266780687366, 24.915430946461967), (106.49771857349178, 24.894128362596824), (106.69276934010989, 24.87258028799569), (106.88782010672801, 24.850786722658583), (107.08287087334612, 24.828747666585492), (107.27792163996425, 24.806463119776417), (107.47297240658236, 24.78393308223137), (107.66802317320048, 24.761157553950333), (107.86307393981859, 24.738136534933318), (108.05812470643671, 24.714870025180325), (108.25317547305482, 24.69135802469134), (108.44822623967295, 24.667600533466384), (108.64327700629106, 24.64359755150545), (108.83832777290918, 24.619349078808526), (109.03337853952729, 24.59485511537563), (109.22842930614542, 24.570115661206735), (109.42348007276352, 24.545130716301877), (109.61853083938165, 24.519900280661027), (109.81358160599976, 24.4944243542842), (110.00863237261788, 24.468702937171393), (110.20368313923599, 24.44273602932261), (110.39873390585412, 24.416523630737828), (110.59378467247222, 24.390065741417082), (110.78883543909035, 24.363362361360345), (110.98388620570846, 24.336413490567637), (111.17893697232658, 24.309219129038937), (111.37398773894469, 24.28177927677425), (111.56903850556282, 24.254093933773596), (111.76408927218093, 24.22616310003697), (111.95914003879905, 24.19798677556434), (112.15419080541716, 24.169564960355736), (112.34924157203528, 24.140897654411162), (112.54429233865339, 24.11198485773059), (112.73934310527152, 24.08282657031404), (112.93439387188963, 24.053422792161527), (113.12944463850775, 24.023773523273007), (113.32449540512586, 23.993878763648517), (113.51954617174398, 23.963738513288057), (113.71459693836209, 23.933352772191604), (113.90964770498022, 23.902721540359167), (114.10469847159833, 23.871844817790745), (114.29974923821645, 23.84072260448636), (114.49480000483456, 23.809354900445975), (114.68985077145268, 23.777741705669612), (114.88490153807079, 23.745883020157287), (115.07995230468892, 23.713778843908955), (115.27500307130703, 23.68142917692466), (115.47005383792515, 23.648834019204386), (115.66510460454326, 23.615993370748114), (115.86015537116138, 23.582907231555865), (116.0552061377795, 23.54957560162765), (116.25025690439762, 23.515998480963432), (116.44530767101574, 23.482175869563243), (116.64035843763385, 23.448107767427082), (116.83540920425197, 23.413794174554923), (117.03045997087008, 23.379235090946786), (117.22551073748821, 23.344430516602664), (117.42056150410632, 23.309380451522586), (117.61561227072444, 23.27408489570651), (117.81066303734255, 23.23854384915444), (118.00571380396067, 23.202757311866414), (118.20076457057878, 23.16672528384239), (118.39581533719691, 23.13044776508238), (118.59086610381502, 23.093924755586407), (118.78591687043314, 23.057156255354442), (118.98096763705125, 23.020142264386493), (119.17601840366937, 22.98288278268258), (119.37106917028748, 22.945377810242668), (119.56611993690561, 22.90762734706678), (119.76117070352372, 22.86963139315492), (119.95622147014184, 22.83138994850706), (120.15127223675995, 22.792903013123222), (120.34632300337807, 22.7541705870034), (120.54137376999618, 22.715192670147616), (120.73642453661431, 22.67596926255584), (120.93147530323242, 22.63650036422807), (121.12652606985054, 22.596785975164345), (121.32157683646865, 22.55682609536462), (121.51662760308677, 22.51662072482892), (121.71167836970488, 22.476169863557246), (121.90672913632301, 22.435473511549574), (122.10177990294112, 22.394531668805925), (122.29683066955924, 22.353344335326312), (122.49188143617735, 22.3119115111107), (122.68693220279548, 22.27023319615911), (122.88198296941358, 22.228309390471537), (123.07703373603171, 22.186140094047992), (123.27208450264982, 22.14372530688845), (123.46713526926794, 22.101065028992934), (123.66218603588605, 22.058159260361457), (123.85723680250418, 22.01500800099398), (124.05228756912229, 21.97161125089052), (124.24733833574041, 21.927969010051086), (124.44238910235852, 21.884081278475662), (124.63743986897664, 21.839948056164253), (124.83249063559475, 21.795569343116888), (125.02754140221289, 21.750945139333517), (125.222592168831, 21.706075444814168), (125.41764293544912, 21.66096025955884), (125.61269370206723, 21.615599583567544), (125.80774446868536, 21.569993416840248), (126.00279523530347, 21.524141759376974), (126.19784600192159, 21.478044611177715), (126.3928967685397, 21.4317019722425), (126.58794753515782, 21.385113842571286), (126.78299830177593, 21.33828022216408), (126.97804906839406, 21.291201111020918), (127.17309983501217, 21.243876509141757), (127.36815060163029, 21.196306416526618), (127.5632013682484, 21.148490833175508), (127.75825213486652, 21.1004297590884), (127.95330290148463, 21.052123194265313), (128.14835366810274, 21.003571138706263), (128.34340443472087, 20.954773592411215), (128.538455201339, 20.905730555380188), (128.73350596795711, 20.85644202761319), (128.9285567345752, 20.806908009110195), (129.12360750119333, 20.75712849987122), (129.31865826781146, 20.70710349989627), (129.51370903442958, 20.65683300918535), (129.70875980104768, 20.606317027738427), (129.9038105676658, 20.55555555555553), (130.09886133428392, 20.504548592636667), (130.29391210090205, 20.453296138981813), (130.48896286752014, 20.401798194590967), (130.68401363413827, 20.35005475946415), (130.8790644007564, 20.29806583360135), (131.07411516737452, 20.24583141700257), (131.2691659339926, 20.19335150966782), (131.46421670061073, 20.140626111597072), (131.65926746722886, 20.08765522279034), (131.85431823384698, 20.034438843247642), (132.04936900046508, 19.980976972968946), (132.2444197670832, 19.92726961195428), (132.43947053370132, 19.87331676020363), (132.63452130031945, 19.819118417717), (132.82957206693754, 19.764674584494387), (133.02462283355567, 19.709985260535788), (133.2196736001738, 19.65505044584122), (133.41472436679192, 19.599870140410665), (133.60977513341, 19.54444434424412), (133.80482590002813, 19.488773057341618), (133.99987666664626, 19.432856279703103), (134.19492743326438, 19.37669401132863), (134.38997819988248, 19.320286252218168), (134.5850289665006, 19.26363300237172), (134.78007973311873, 19.2067342617893), (134.97513049973685, 19.149590030470883), (135.17018126635494, 19.09220030841651), (135.36523203297307, 19.034565095626135), (135.5602827995912, 18.976684392099784), (135.75533356620932, 18.918558197837463), (135.9503843328274, 18.86018651283915), (136.14543509944554, 18.801569337104844), (136.34048586606366, 18.74270667063459), (136.53553663268178, 18.683598513428322), (136.73058739929988, 18.624244865486084), (136.925638165918, 18.564645726807875), (137.12068893253613, 18.504801097393674), (137.31573969915425, 18.44471097724349), (137.51079046577237, 18.384375366357332), (137.70584123239047, 18.32379426473519), (137.9008919990086, 18.26296767237706), (138.09594276562672, 18.201895589282948), (138.29099353224484, 18.140578015452874), (138.48604429886294, 18.0790149508868), (138.68109506548106, 18.01720639558475), (138.87614583209918, 17.95515234954673), (139.0711965987173, 17.892852812772716), (139.2662473653354, 17.83030778526272), (139.46129813195353, 17.767517267016757), (139.65634889857165, 17.70448125803479), (139.85139966518977, 17.64119975831685), (140.04645043180787, 17.57767276786295), (140.241501198426, 17.513900286673042), (140.43655196504412, 17.449882314747157), (140.63160273166224, 17.385618852085308), (140.82665349828034, 17.321109898687453), (141.02170426489846, 17.256355454553642), (141.21675503151658, 17.191355519683825), (141.4118057981347, 17.126110094078044), (141.6068565647528, 17.06061917773627), (141.80190733137093, 16.99488277065852), (141.99695809798905, 16.928900872844807), (142.19200886460717, 16.862673484295087), (142.38705963122527, 16.79620060500939), (142.5821103978434, 16.729482234987728), (142.77716116446152, 16.66251837423006), (142.97221193107964, 16.59530902273643), (143.16726269769774, 16.52785418050682), (143.36231346431586, 16.46015384754122), (143.55736423093398, 16.39220802383963), (143.7524149975521, 16.324016709402073), (143.9474657641702, 16.25557990422854), (144.14251653078833, 16.186897608319015), (144.33756729740645, 16.117969821673498), (144.53261806402458, 16.048796544292017), (144.72766883064267, 15.979377776174545), (144.9227195972608, 15.909713517321109), (145.11777036387892, 15.83980376773168), (145.31282113049704, 15.769648527406261), (145.50787189711514, 15.699247796344878), (145.70292266373326, 15.628601574547517), (145.89797343035139, 15.55770986201415), (146.0930241969695, 15.486572658744805), (146.2880749635876, 15.415189964739511), (146.48312573020573, 15.343561779998197), (146.67817649682385, 15.27168810452092), (146.87322726344198, 15.19956893830765), (147.06827803006007, 15.127204281358416), (147.2633287966782, 15.054594133673191), (147.45837956329632, 14.981738495251989), (147.65343032991444, 14.908637366094808), (147.84848109653254, 14.835290746201636), (148.04353186315066, 14.761698635572486), (148.23858262976879, 14.687861034207373), (148.4336333963869, 14.613777942106253), (148.628684163005, 14.539449359269156), (148.82373492962313, 14.464875285696095), (149.01878569624125, 14.390055721387043), (149.21383646285938, 14.314990666341998), (149.40888722947747, 14.23968012056099), (149.6039379960956, 14.16412408404399), (149.79898876271372, 14.088322556790999), (149.99403952933184, 14.012275538802044), (150.18909029594994, 13.93598303007711), (150.38414106256806, 13.859445030616186), (150.5791918291862, 13.78266154041927), (150.7742425958043, 13.705632559486403), (150.9692933624224, 13.628358087817531), (151.16434412904053, 13.550838125412682), (151.35939489565865, 13.473072672271854), (151.55444566227678, 13.39506172839505), (151.74949642889487, 13.316805293782252), (151.944547195513, 13.238303368433492), (152.13959796213112, 13.159555952348725), (152.33464872874924, 13.080563045527981), (152.52969949536734, 13.001324647971288), (152.72475026198546, 12.921840759678574), (152.9198010286036, 12.842111380649897), (153.1148517952217, 12.762136510885227), (153.3099025618398, 12.681916150384595), (153.50495332845793, 12.60145029914797), (153.70000409507605, 12.520738957175368), (153.89505486169418, 12.439782124466802), (154.09010562831227, 12.35857980102223), (154.2851563949304, 12.277131986841681), (154.48020716154852, 12.195438681925154), (154.67525792816664, 12.113499886272635), (154.87030869478474, 12.031315599884152), (155.06535946140286, 11.948885822759678), (155.260410228021, 11.866210554899226), (155.4554609946391, 11.783289796302796), (155.6505117612572, 11.70012354697036), (155.84556252787533, 11.61671180690199), (156.04061329449345, 11.533054576097598), (156.23566406111158, 11.449151854557229), (156.4307148277297, 11.365003642280897), (156.62576559434783, 11.280609939268572), (156.82081636096592, 11.195970745520256), (157.01586712758404, 11.111086061035977), (157.21091789420217, 11.02595588581572), (157.4059686608203, 10.94058021985947), (157.6010194274384, 10.854959063167243), (157.7960701940565, 10.769092415739053), (157.99112096067464, 10.682980277574842), (158.18617172729276, 10.596622648674668), (158.38122249391088, 10.51001952903853), (158.57627326052898, 10.423170918666386), (158.7713240271471, 10.336076817558265), (158.96637479376523, 10.248737225714166), (159.16142556038335, 10.161152143134103), (159.35647632700145, 10.073321569818049), (159.55152709361957, 9.985245505766002), (159.7465778602377, 9.896923950977978), (159.94162862685582, 9.808356905453977), (160.1366793934739, 9.719544369193983), (160.33173016009204, 9.63048634219804), (160.52678092671016, 9.541182824466091), (160.72183169332828, 9.45163381599815), (160.91688245994638, 9.361839316794246), (161.1119332265645, 9.271799326854364), (161.30698399318263, 9.18151384617849), (161.50203475980075, 9.090982874766638), (161.69708552641885, 9.000206412618809), (161.89213629303697, 8.909184459734988), (162.0871870596551, 8.817917016115175), (162.28223782627322, 8.726404081759412), (162.4772885928913, 8.634645656667658), (162.67233935950944, 8.542641740839912), (162.86739012612756, 8.450392334276202), (163.06244089274568, 8.357897436976486), (163.25749165936378, 8.265157048940807), (163.4525424259819, 8.17217117016915), (163.64759319260003, 8.078939800661502), (163.84264395921815, 7.985462940417875), (164.03769472583625, 7.891740589438271), (164.23274549245437, 7.797772747722675), (164.4277962590725, 7.703559415271087), (164.62284702569062, 7.60910059208355), (164.8178977923087, 7.514396278160021), (165.01294855892684, 7.4194464735005), (165.20799932554496, 7.324251178105001), (165.40305009216308, 7.228810391973525), (165.59810085878118, 7.133124115106071), (165.7931516253993, 7.037192347502625), (165.98820239201743, 6.941015089163216), (166.18325315863555, 6.844592340087814), (166.37830392525365, 6.747924100276421), (166.57335469187177, 6.651010369729065), (166.7684054584899, 6.553851148445716), (166.96345622510802, 6.45644643642639), (167.1585069917261, 6.358796233671086), (167.35355775834424, 6.26090054017979), (167.54860852496236, 6.162759355952517), (167.74365929158049, 6.0643726809892655), (167.93871005819858, 5.965740515290037), (168.1337608248167, 5.866862858854816), (168.32881159143483, 5.7677397116836175), (168.52386235805295, 5.668371073776456), (168.71891312467105, 5.568756945133302), (168.91396389128917, 5.468897325754156), (169.1090146579073, 5.368792215639047), (169.30406542452542, 5.268441614787932), (169.49911619114351, 5.167845523200839), (169.69416695776164, 5.067003940877797), (169.88921772437976, 4.965916867818748), (170.08426849099789, 4.864584304023708), (170.27931925761598, 4.763006249492719), (170.4743700242341, 4.661182704225709), (170.66942079085223, 4.55911366822275), (170.86447155747035, 4.456799141483799), (171.05952232408845, 4.3542391240088705), (171.25457309070657, 4.25143361579795), (171.4496238573247, 4.148382616851052), (171.64467462394282, 4.04508612716819), (171.83972539056091, 3.9415441467493224), (172.03477615717904, 3.837756675594477), (172.22982692379716, 3.733723713703668), (172.4248776904153, 3.629445261076853), (172.61992845703338, 3.524921317714089), (172.8149792236515, 3.4201518836153184), (173.01002999026963, 3.3151369587805704), (173.20508075688775, 3.2098765432098446), (173.40013152350585, 3.104370636903141), (173.59518229012397, 2.99861923986046), (173.7902330567421, 2.892622352081773), (173.98528382336022, 2.7863799735671364), (174.18033458997832, 2.679892104316508), (174.37538535659644, 2.573158744329888), (174.57043612321456, 2.46617989360729), (174.7654868898327, 2.3589555521487284), (174.96053765645078, 2.251485719954161), (175.1555884230689, 2.1437703970236157), (175.35063918968703, 2.035809583357107), (175.54568995630515, 1.9276032789546065), (175.74074072292325, 1.819151483816114), (175.93579148954137, 1.710454197941658), (176.1308422561595, 1.6015114213312245), (176.32589302277762, 1.492323153984799), (176.52094378939572, 1.3828893959023816), (176.71599455601384, 1.2732101470840007), (176.91104532263196, 1.1632854075296137), (177.1060960892501, 1.0531151772392633), (177.30114685586818, 0.9426994562129494), (177.4961976224863, 0.8320382444506293), (177.69124838910443, 0.7211315419523316), (177.88629915572255, 0.6099793487180705), (178.08134992234065, 0.4985816647478032), (178.27640068895877, 0.3869384900415582), (178.4714514555769, 0.2750498245993498), (178.66650222219502, 0.16291566842114946), (178.86155298881312, 0.05053602150695724)]"
  },
  {
    "objectID": "chapters/dictionarySet.html",
    "href": "chapters/dictionarySet.html",
    "title": "6  Dictionaries and Sets",
    "section": "",
    "text": "Jupyter Notebook"
  },
  {
    "objectID": "chapters/dictionarySet.html#dictionaries",
    "href": "chapters/dictionarySet.html#dictionaries",
    "title": "6  Dictionaries and Sets",
    "section": "6.1 Dictionaries",
    "text": "6.1 Dictionaries\n\n6.1.1 Creating a Dictionary\nA dictionary is a multi-element object just like a list or tuple but instead of connecting each element to an integer index value, a keyword is used. Dictionaries allow you to access data without knowing anything about the order of the items. For example, maybe you want to store the orbital radius of all the planets in the solar system. Using a dictionary you can associate the name of the planet with its orbital radius. A string containing the planet’s name could serve as the key and the associated radius as the value.\nDictionaries are built using curly braces ({}) instead of square brackets (lists) or parentheses (tuples). Each item in the dictionary is a key:value pair and the items are separated by commas just like lists. Below is an example\norbitalRadii = {\"Mercury\":0.39, \"Venus\":0.72, \"Earth\":1.0, \"Mars\":1.5,\"Jupiter\":5.2,\"Saturn\":9.5, \"Uranus\":19.2,\"Neptune\":30.1, \"Pluto\": 39.5}\nThe keys don’t have to be strings, but can be any data type. For example, maybe you’d like the keys to be the orbital radii of the planets and the values to be the associated orbital period (in Earth days).\nradiiandPeriod = {0.39: 88, 0.72: 224.7 , 1.0: 365.2 , 1.5: 687 ,5.2: 4331 ,9.5: 10_747 , 19.2: 30_589 ,30.1: 59_800 ,39.5: 90_560 }\nAccessing an element of a dictionary is done with square brackets ([]) just like lists, but instead of placing an integer index the key value is used.\norbitalRadii = {\"Mercury\":0.39, \"Venus\":0.72, \"Earth\":1.0, \"Mars\":1.5,\"Jupiter\":5.2,\"Saturn\":9.5, \"Uranus\":19.2,\"Neptune\":30.1, \"Pluto\": 39.5}\n\njupiterRadius = orbitalRadii[\"Jupiter\"]\n\nTo Do:\n\nUse a print statement to verify that the correct orbital radius was extracted.\nCan you extract the orbital radius of Pluto from the list?\n\n\nAdditional key:value pairs can be added to an existing dictionary by calling the key and assigning it to a value\norbitalRadii = {\"Mercury\":0.39, \"Venus\":0.72, \"Earth\":1.0, \"Mars\":1.5,\"Jupiter\":5.2,\"Saturn\":9.5, \"Uranus\":19.2,\"Neptune\":30.1, \"Pluto\": 39.5}\n\norbitalRadii[\"Moon\"] = 0.384  \n\n\n6.1.2 keys, items and values methods\nThree dictionary methods are so heavily used that they are worth mentioning here. The keys method will return a list1 of all keys that are present in the dictionary. The values method will return a list of all values present in the list and the items method will return a nested list containing all key:value pairs.1 Actually it produces an iterator that can be used in conjunction with a loop. If you want a list you must use the list function.\norbitalRadii = {\"Mercury\":0.39, \"Venus\":0.72, \"Earth\":1.0, \"Mars\":1.5,\"Jupiter\":5.2,\"Saturn\":9.5, \"Uranus\":19.2,\"Neptune\":30.1, \"Pluto\": 39.5}\n\nvals = orbitalRadii.values()\nkeys = orbitalRadii.keys()\nitems = orbitalRadii.items()\n\nTo Do:\n\nUse print statements in the cell above to see what the keys, items, and values methods produce.\nAsk questions as needed.\n\n\n\n\n6.1.3 Other useful dictionary methods\nThere are a few other useful dictionary methods worth mentioning and I’ll place them in the cell below so that you can investigate what they do.\n\norbitalRadii = {\"Mercury\":0.39, \"Venus\":0.72, \"Earth\":1.0, \"Mars\":1.5,\"Jupiter\":5.2,\"Saturn\":9.5, \"Uranus\":19.2,\"Neptune\":30.1, \"Pluto\": 39.5}\n\nradii = {\"Moon\":0.384, \"Venus\": 0.71}\norbitalRadii.pop(\"Mercury\")\norbitalRadii.popitem()\noRadii = dict.fromkeys([\"Mercury\", \"Venus\", \"Earth\"])\nprint(oRadii)\norbitalRadii.update(radii)\n\n{'Mercury': None, 'Venus': None, 'Earth': None}\n\n\n\nTo Do:\n\nUse print statements to determine what each dictionary method in the cell above does.\nAdd comments next to each line explaining the method."
  },
  {
    "objectID": "chapters/dictionarySet.html#sets",
    "href": "chapters/dictionarySet.html#sets",
    "title": "6  Dictionaries and Sets",
    "section": "6.2 Sets",
    "text": "6.2 Sets\nA set is another python data type that is used occasionally. They are multi-element objects similar to lists and tuples with one key difference: there can be no repeated elements in a set.\n\n6.2.1 Creating a Set\nSets are created using curly braces ({}) just like dictionaries but instead of placing key:value pairs inside, single values are used. Any repeated elements will be automatically deleted when the set is created.\nmySet = {1,2,4,2,1,3,4}\n\nTo Do:\n\nPredict what the set defined above will contain.\nUse a print statement to check yourself and adjust your thinking as needed.\n\n\nThe set function can be used to turn a list or tuple into a set and any repeated elements will be deleted. This can be a handy way to remove unwanted duplicates from a list.\n\nelements = [\"H\", \"He\", \"Ne\", \"He\", \"N\", \"Ag\", \"Pt\", \"Ag\"]\n\nmySet = set(elements)\n\nprint(mySet)\n\n{'N', 'Ag', 'Ne', 'He', 'Pt', 'H'}\n\n\n\n\n6.2.2 Modifying a set\nElements can be added to a set using the add and/or update methods. The add method will add a single element to the set and update will allow you to add more than one element.\nelements = {\"H\", \"He\", \"Ne\", \"He\", \"N\", \"Ag\", \"Pt\", \"Ag\"}\n\nelements.add(\"Au\")\n\nelements.update([\"In\",\"Cu\",\"Os\",\"He\"])\n\nTo Do:\n\nPredict what the set will look like after the add method executes. Then add a print statement to verify that you’re correct.\n\nWhat happens if you try to add an element that is already in the set?\nPredict what the set will look like after the update method executes. Then add a print statement to verify that you’re correct.\n\n\nElements can be removed from a set using the remove and/or discard methods. The difference between these methods is very subtle. They will both remove an element, but the remove method will throw an error if the element you are attempting to remove isn’t in the set. discard won’t throw an error even if the element isn’t present. The clear method will remove all entries from the set.\nelements = {\"H\", \"He\", \"Ne\", \"He\", \"N\", \"Ag\", \"Pt\", \"Ag\"}\n\nelements.remove(\"H\")\nelements.discard(\"He\")\nelements.discard(\"Cu\")\nelements.remove(\"Cu\")\nelements.clear()\n\nTo Do:\nPredict what the set will look like after each statement in the cell above. Then add a print statement to verify that you’re correct.\n\n\n\n6.2.3 Mathematical Set Operations\nSets are a well-known mathematical idea and there are four mathematical operations that are commonly used with sets. They are: union, intersection, difference, and symmetric difference. We’ll investigate them one at a time.\n\n6.2.3.1 Union\nThe union of two sets is the set of all unique elements between both sets. The union of two sets can be found using the | operator.\nfibonacci = {1,1,2,3,5,8,13,21,34,55,89,147,236}\ntriangles = {1, 3, 6, 10, 15, 21, 28, 36, 45, 55, 66, 78, 91, 105, 120, 136, 153, 171, 190}\n\nunion = fibonacci|triangles\n\n\n6.2.3.2 Intersection\nThe intersection of two sets is the set of elements that are common to both sets. The intersection of two sets can be found using the & operator\nfibonacci = {1,1,2,3,5,8,13,21,34,55,89,147,236}\ntriangles = {1, 3, 6, 10, 15, 21, 28, 36, 45, 55, 66, 78, 91, 105, 120, 136, 153, 171, 190}\n\nintersect = fibonacci&triangles\n\n\n6.2.3.3 Difference and Symmetric Difference\nAnd finally, the difference of two sets is the set of elements that are found in one set but not in the other. The difference of two sets can be found using the - operator. Note that A - B will produce a different set than B - A. A- B will produce a set with all of the elements from set A that are not in set B. B - A will do just the opposite, forming a set with all the elements from set B that are not in set A. If you want the set of elements that are in A and B but not in both (kind of like the opposite of intersection) then you want the symmetric difference operator (^)\nfibonacci = {1,1,2,3,5,8,13,21,34,55,89,147,236}\ntriangles = {1, 3, 6, 10, 15, 21, 28, 36, 45, 55, 66, 78, 91, 105, 120, 136, 153, 171, 190}\n\n\ndiff = fibonacci - triangles\ndiffTwo = triangles - fibonacci\nsymdiff = fibonacci ^ triangles\n\nTo Do:\n\nPredict what the set will look like after each statement in the cells above.\nAdd print statements to check yourself.\n\n\nAs a final point you should note that set elements cannot be extracted using square brackets like you can with lists and tuples. It’s just not allowed. However, you can iterate over sets even though there is no guarantee about the order they will come in. We’ll see what it means to iterate when we study loops.\nelements= {\"Li\",\"Be\",\"B\", \"C\",\"N\", \"O\",\"F\", \"Ne\"}\n\nprint(elements[2])"
  },
  {
    "objectID": "chapters/dictionarySet.html#flashcards",
    "href": "chapters/dictionarySet.html#flashcards",
    "title": "6  Dictionaries and Sets",
    "section": "6.3 Flashcards",
    "text": "6.3 Flashcards\n\nDescribe all of the ways that you can make a dictionary.\nDescribe all of the ways that you can make a set.\nHow do you add a new key:value pair to a dictionary?\nHow do you add a new value to a set?\nWhat does the keys dictionary method produce?\nWhat does the values dictionary method produce?\nWhat does the items dictionary method produce?\nWhat does the union operator (|) do?\nWhat does the intersection operator (&) do?\nWhat does the difference operator (-) do?\nWhat does the symmetric difference operator (^) do?\nWhere is the record of The Savior’s visit to the American continent?"
  },
  {
    "objectID": "chapters/dictionarySet.html#exercises",
    "href": "chapters/dictionarySet.html#exercises",
    "title": "6  Dictionaries and Sets",
    "section": "6.4 Exercises",
    "text": "6.4 Exercises\n\n(Physical Constants) The field of physics is filled with experimental constants. In fact, you’ll use some of them so frequently throughout your undergraduate experience that you’ll end up memorizing them. Until then it could be useful to store some of these constants in a dictionary for easy reference. Choose at least 15 constants from the following website and build a dictionary of them. Make sure that the following constants are in your list: \\(k_B\\), \\(\\hbar\\), \\(c\\), \\(e\\), and \\(\\epsilon_0\\). You are free to choose the names of the keys to be anything that makes good sense to you.\nThen use your dictionary to calculate the following values \\[\\sigma = {\\pi^2 k_B^4 \\over 60 \\hbar^3 c^2} \\text{ (Stefan-Boltzmann constant)}\\] \\[\\alpha = {e^2 \\over 4 \\pi \\epsilon_0 \\hbar c}  \\text{ (fine-structure constant)}\\]\n\n# Python code here.\n\n(Unit Conversions) Unit conversions show up all over in physics and if you don’t have the conversion factors memorized you may find yourself constantly looking them up. Construct a dictionary that contains many of the most useful unit conversions, including those shown below. You are free to choose the key names to be whatever makes most sense to you. I’ve given a few examples in the code cell below to get you started. \\[ 1 \\text{ kilometer} = 1000 \\text{ meters}\\] \\[ 1 \\text{ inch} = 2.54 \\text{ centimeters}\\] \\[ 1 \\text{ mile} = 1.609 \\text{ kilometers}\\] \\[ 1 \\text{ mph} = 0.447 \\text{ m/s}\\] \\[ 1 \\text{ u} = 1.661 \\times 10^{-27} \\text{ kg}\\] \\[ 1 \\text{ electron-volt} = 1.602 \\times 10^{-19} \\text{ Joules}\\] \\[ 1 \\text{ day} = 24 \\text{ hours}\\] \\[ 1 \\text{ radian} = 57.3^\\circ\\] \\[ 1 \\text{ rev} = 2\\pi \\text{ radians}\\]\n\nOnce the dictionary is created use it to perform the following conversions:\n\n\\(5\\) miles to meters.\n\\(250^\\circ\\) to radians.\n\\(562\\) Joules to electron-volts.\n\\(3500\\) inches to meters.\n\\(5.8\\) m\\(^3\\) to cm\\(^3\\).\n\nconversions = {\"km-to-m\": 1000, \"in-to-cm\": 2.54 }\n\nHere you will find a table containing planetary information. Pick your top three favorite planets and make one dictionary for each planet. The keys in the dictionary should be the row label from the table (or a shortened version of that label) and the item value should be the number in the table. Once the dictionaries are created, verify that you can extract values from them as you would expect.\n\n# Python code here.\n\nHere you will find a table containing planetary information. Pick a row from the table and make a dictionary that holds the values in that row. The keys to the dictionary should be the planets and the values are the value from the table. Once the dictionary is created, use it to calculate the following:\n\nThe average of the property that you chose.\nThe largest values.\nThe smallest value.\n\n\n# Python code here.\n\nIn the cell below you will find the first 15 numbers for several important mathematical sequences. Answer the following questions:\n\nFind all of the numbers that are in the fibonacci sequence and the triangles sequence. (intersection)\nFind all of the numbers that are in the pentagonal sequence but not in the hexagonal sequence. (difference)\nFind the union of the fibonacci sequence and the hexagonal sequence and report how many numbers there are.\nDetermine how many numbers are in the caterer sequence but not in the hexagonal sequence.\n\n\nfibonacci = {1,1,2,3,5,8,13,21,34,55,89,147,236,383,619}\nsquares= {1,4,9,16,25,36,49,64,81,100,121,144,169,196,225}\ntriangles = {1, 3, 6, 10, 15, 21, 28, 36, 45, 55, 66, 78, 91, 105, 120, 136, 153, 171, 190}\npentagonal = {1, 5, 12, 22, 35, 51, 70, 92, 117, 145, 176, 210, 247, 287, 330}\nhexagonal = {1, 6, 15, 28, 45, 66, 91, 120, 153, 190, 231, 276, 325, 378, 435}\ncaterer = {2, 4, 7, 11, 16, 22, 29, 37, 46, 56, 67, 79, 92, 106, 121}"
  },
  {
    "objectID": "chapters/loops.html",
    "href": "chapters/loops.html",
    "title": "7  Loops",
    "section": "",
    "text": "Jupyter Notebook\nLoops allow programs to rerun the same block of code multiple times. This might seem like a funny thing to want to do but it turns out that there are many important tasks that are repetitive in nature (perhaps with small changes for each successive repetition). A loop provides a succinct and efficient way to perform tasks of this nature."
  },
  {
    "objectID": "chapters/loops.html#for-loops",
    "href": "chapters/loops.html#for-loops",
    "title": "7  Loops",
    "section": "7.1 for loops",
    "text": "7.1 for loops\nThe for loop is probably the most common loop you will encounter and is a good choice when you know beforehand exactly what things you want to loop over. Here is an example of a for loop that is used to add up the elements of a list.\nthesum = 0\nfor i in [3,2,1,9.9]: \n    thesum += i\nThis would be equivalent to the following code:\nthesum = 0\n\nthesum = thesum + 3\nthesum = thesum + 2\nthesum = thesum + 1\nthesum = thesum + 9.9\nwhich isn’t that much longer than using a loop. However, as the list gets longer and/or the mathematical operations being performed get more complex the second method would get unreasonably long.\nThe correct language is to say that we are iterating over the list [3,2,1,9.9]. This means that the loop variable (i in this case but you can choose it to be whatever you want) gets assigned the values of the list elements, one by one, until it reaches the end of the list. You can use for loops to iterate over any multi-element object like lists or tuples. Python uses indentation to indicate where the loop ends. In this case there was only one statement inside to loop, but if you wanted more than one each line should be indented.\n\nTo Do:\n\nAdd a print statement inside of the loop above to display the value of the variable thesum.\nPredict what the output will be and then run the code and verify that you were correct.\nNow change the loop variable to be named physics and verify that the loop still works as expected.\n\n\nYou can iterate over range objects and strings using for loops.\n\nfor i in ['Physics', 'is','so','fun']: # Iterate over a list of strings\n    print(i)\n\nPhysics\nis\nso\nfun\n\n\n\nfor i in range(5,50,3):  #Generates a list from 5 -> 50 with a step size of 3\n    print(i)\n\n5\n8\n11\n14\n17\n20\n23\n26\n29\n32\n35\n38\n41\n44\n47\n\n\nThese examples are so simple that you might wonder when a loop might actually be useful to you. Let’s see if we can build a loop to calculate the following sum\n\\[ \\sum_{n=1}^{1000} {1\\over n^2} \\tag{7.1}\\]\n\ntheSum = 0\nfor n in range(1,1000):\n    theSum = theSum + 1/n**2\nprint(theSum)\n\n1.6439335666815615\n\n\nHere, n is being assigned the values 1,2,3,4....1000, one by one, until it gets all the way to 1000. Each time through the loop, n is different and the expression 1/n**2 evaluates to a new value. The variable theSum is updated each time through to be the running total of all calculations performed thus far. Here’s another example of a loop used to calculate the value of \\(20!\\):\n\ntheProduct = 1\nfor n in range(1,21):\n    theProduct = theProduct * n #Multiply theProduct by n\nprint(theProduct)\n\n2432902008176640000\n\n\nRemember that the range function creates a list starting at \\(1\\), going up to \\(21\\) but not including it. The math library has a function called factorial that does the same thing. Let’s use it to check our answer:\n\nfrom math import factorial\nfactorial(20)\n\n2432902008176640000\n\n\n\n7.1.1 Boolean Logic Inside Loops\nOften when using loops, we only want a block of code to execute when some condition is satisfied. We can use boolean logic inside of the loop to accomplish this. For example, let’s write a loop to compute the following sum:\n\\[ \\sum_{{n\\over 5} \\in \\text{ Int and } {n\\over 3} \\in \\text{ Int}} {1\\over n^2} \\]\nwhich is similar to the one we did above, but this time we only want to include terms where \\(n\\) is a perfect multiple of both 5 and 3. To check to see if n is a perfect multiple of a number we can calculate the modulo (remainder after division) using the % operator and check that it is equal to zero.\n\ntheSum = 0\nfor n in range(1,1000):\n    if n % 5 == 0 and n % 3 == 0:\n        theSum = theSum + 1/n**2\nprint(theSum)\n\n0.007243985583159138\n\n\n\nTo Do:\nPerform the following modifications to the loop above.\n\nIncrease the upper bound of the sum to go up to and include \\(5000\\).\nOnly include the terms where n is a multiple of 5 and 3 or is a multiple of 7.\nReplace the statement that updates theSum to its shorthand version.\n\n\n\n\n7.1.2 Zipping and Enumerating\nThere are times when it is necessary to iterate over two lists simultaneously. For example, let us say that we have a list of atomic numbers (AN) and a list of approximate atomic masses (mass) of the most abundant isotopes for the first six elements on the periodic table.\nAN = [1,2,3,4,5,6]\nmass = [1,4,7,9,11,12]\nIf we want to calculate the number of neutrons in each isotope, we need to subtract each atomic number from the atomic mass. To accomplish this, it would be nice to iterate over both lists simultaneously\n\n7.1.2.1 Zipping\nThe simplest way to iterate over two lists simultaneously is to combine both lists into a single, iterable object and iterate over it once. The zip function does just that by merging two lists or tuples into a nested list\n\nAN = [1,2,3,4,5,6]\nmass = [1,4,7,9,11,12]\n\nzipped = zip(AN,mass)\n\nfor pair in zipped:\n    print(pair[1] - pair[0])\n\n0\n2\n4\n5\n6\n6\n\n\nThe zip objects are “single use” so you can’t reuse zipped in a later loop. If the two lists being zipped are not the same length, zip stops zipping when it reaches the end of the shorter list.\n\nTo Do:\n\nPrint the variable zipped and inspect closely. Was the output what you expected?\n\nNow do print(tuple(zipped)) and inspect closely. Draw a conclusion.\nAdd a few more entries to the list named AN, but don’t add the corresponding entries to the other list. Now the lists being zipped aren’t the same length. Inspect the output of the print statement to determine what zip does in this scenario.\n\n\n\n\n7.1.2.2 Enumeration\nA close relative to zip is enumerate which zips a list to the index value for that list (read that last statement again). It also returns a “single use” object that can be iterated over.\n\nAN = [1,2,3,4,5,6]\nmass = [1,4,7,9,11,12]\n\nenum = enumerate(mass)\n\nfor idx,val in enum:\n    print(val - AN[idx])\n\n0\n2\n4\n5\n6\n6\n\n\n\nTo Do:\n\nRepeat the previous To-Dos for the cell above.\n\n\n\n\n\n7.1.3 List Comprehension\nIt is fairly common to use a for loop to populate a list with a sequence of numbers.\n\nmyList = []\n\nfor i in range(10):\n    myList.append(i**2)\n\nprint(myList)\n\n[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n\n\nThis entire process can be compressed down into a single line by expressing the for loop in square brackets. This is known as list comprehension. The code below will generate the list as above.\n\nmyList = [i**2 for i in range(10)]\nprint(myList)\n\n[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n\n\nList comprehension can take a little time to get used to but it is well worth it. It saves both time and space and makes code less cluttered. You can even add boolean expressions to your conditionals for further control of the final result.\n\nmyList = [i**2 for i in range(10) if i %2 == 0]  # Include only the evens.\nprint(myList)\n\n[0, 4, 16, 36, 64]\n\n\n\nTo Do:\nThink of your favorite mathematical function and modify the code above to generate a few samples from it."
  },
  {
    "objectID": "chapters/loops.html#while-loops",
    "href": "chapters/loops.html#while-loops",
    "title": "7  Loops",
    "section": "7.2 while Loops",
    "text": "7.2 while Loops\nLogic can be combined with loops using something called a while loop. A while loop is a good choice when you don’t know beforehand exactly how many iterations of the loop will be executed but rather want the loop to continue to execute until some condition is met. As an example, notice that in Equation 7.1, the terms in the sum get progressively smaller as \\(n\\) gets bigger. It doesn’t make sense to continue adding to the sum once the terms get very small. Let’s compute this sum by looping until the fraction \\({1 \\over n^2}\\) become smaller than \\(1 \\times 10^{-2}\\).\nterm = 1  # Load the first term in the sum\ns = term  # Initialize the sum\nn = 1     # Set a counter\nwhile term > 1e-2:  # Loop while term is bigger than 1e-2\n    n = n +  1        #Add 1 to n so that it will count: 2,3,4,5\n    term = 1./n**2    # Calculate the next term to add\n    s = s +  term     # Add 1/n^2 to the running total\nThis loop will continue to execute until term<1e-2. Note that unlike the for loop, here you have to do your own counting if you need to know how many iterations have been performed. Be careful about what value n starts at and when it is incremented (n = n + 1). Also notice that term must be assigned prior to the start of the loop. If it wasn’t the loop’s first logical test would fail and the loop wouldn’t execute at all.\n\nTo Do:\n\nDecrease the threshold on the termination condition and observe any changes in the final result and how many more iterations are performed.\n\nAfter toying around with it for a while pick a termination condition that you feel will produce a result that is accurate.\n\n\nwhile loops should be used with caution because you can easily write a faulty termination condition and inadvertently write a loop that runs forever. This happens because your termination condition was never met. An example of this is given below.\nWarning: Do not execute the code block below!!\nx = 0\n\nwhile x != 10:\n    x = x + 3\nprint(\"Done\")\nThe loop above is intended to end after a few iterations when the value of x is equal to 10. However, closer inspection reveals that the value of x will never be equal to 10. After the first iteration x is equal to 3, then 6,9,12,15 and so on… but never 10. This loop will run forever because the termination condition is never met (x != 10 never produces a False)!! If you choose to use a while loop, triple check your termination condition to make sure you haven’t made a mental error. Avoiding the use of != or == in your termination condition will help too. Use <= or >= instead.\n\nTo Do:\n\nModify the termination condition in the loop above so that it terminates when x gets larger than 15.\nRun the code and verify that you did it correct."
  },
  {
    "objectID": "chapters/loops.html#continue-break-and-pass-commands",
    "href": "chapters/loops.html#continue-break-and-pass-commands",
    "title": "7  Loops",
    "section": "7.3 continue, break, and pass Commands",
    "text": "7.3 continue, break, and pass Commands\nThe continue, break, and pass commands are used to control the flow of code execution in loops. Here is a description of their usage:\n\n\n\n\n\n\n\nOperator\nDescription\n\n\n\n\nbreak\nExits a for/while loop.\n\n\ncontinue\nSkips the remaining loop block and begins the next iteration.\n\n\npass\nNo action; code contiues on\n\n\n\nThe break statement is useful when you want to completely stop a loop early. Here is our sum loop rewritten with a break statement added to stop the loop after 1000 iterations.\n\nterm = 1  # Load the first term in the sum\ns = term  # Initialize the sum\nn = 1     # Set a counter\nwhile term > 1e-10:  # Loop while term is bigger than 1e-10\n    n +=  1        #Add 1 to n so that it will count: 2,3,4,5\n    term = 1./n**2    # Calculate the next term to add\n    s += term     # Add 1/n^2 to the running total\n    if n > 1000:\n        print('This is taking too long. I''m outta here...')\n        break\n\nThis is taking too long. Im outta here...\n\n\nThe continue statement is similar to break except that instead of stopping the loop, it only stops the current iteration of the loop. All code below the continue statement will be skipped and the next iteration will begin. For example, if you wanted to do the sum from equation ?? but only include those terms for which n is a multiple of 3, it could be done like this:\nterm = 1  # Load the first term in the sum\ns = term  # Initialize the sum\nn = 1     # Set a counter\nwhile term > 1e-10:  # Loop while term is bigger than 1e-10\n    n +=  1        #Add 1 to n so that it will count: 2,3,4,5\n    if n % 3 != 0:\n        continue\n    term = 1./n**2    # Calculate the next term to add\n    s += term     # Add 1/n^2 to the running total\nNow, when the value of n is not a multiple of 3, the sum will not be updated and the associated terms are effectively skipped.\nFinally, the pass statement does nothing. Seriously!! It is merely a place holder for code that has not bee written yet. Usually, you’ll use the pass statement to run and test code without errors due to missing code."
  },
  {
    "objectID": "chapters/loops.html#flash-cards",
    "href": "chapters/loops.html#flash-cards",
    "title": "7  Loops",
    "section": "7.4 Flash Cards",
    "text": "7.4 Flash Cards\n\nExplain the basic structure and key elements of a for loop.\nExplain the basic structure and key elements of a while loop.\nWhat does the break statement do?\nWhat does the continue statement do?\nWhat does the pass statement do?\nWhat does the zip function do? Give an example.\nWhat does the enumerate function do? Give an example.\nWhat is list comprehension? Give an example.\nWhere is the account of Jesus walking on the water?"
  },
  {
    "objectID": "chapters/loops.html#exercises",
    "href": "chapters/loops.html#exercises",
    "title": "7  Loops",
    "section": "7.5 Exercises",
    "text": "7.5 Exercises\n\nUse a loop to construct a list containing the first 10 fibonacci numbers that are multiples of \\(5\\). (The modulo operator (%) is a good and efficient way to see if a number is a multiple of another.)\n\nHint/Answer: The 10th fibonacci number that is a multiple of 5 is: 12,586,269,025\n# Python code here.\n\nSummations appear often in science and mathematics. One such summation is called the Riemann Zeta function and is given by \\[ \\zeta(n) = \\sum_{k=1}^\\infty {1\\over k^n} = {1\\over 1^n} + {1\\over 2^n} + {1\\over 3^n} + \\dots\\]\n\nUse a for loop to evaluate \\(\\zeta(2)\\) and \\(\\zeta(4)\\) and verify that \\(\\zeta(2) = {\\pi^2 \\over 6}\\) and \\(\\zeta(4) = {\\pi^4 \\over 90}\\). This summation is called an infinite sum and we surely don’t want our loop to continue forever!! Instead, an infinite sum like this one can be approximated with a for loop with a large number of iterations. To determine if you have included enough terms, increase the number of terms steadily and watch for the final result to stop changing appreciably.\nNow repeat part 1 using list comprehension and the sum function?\nRepeat the exercise one final time using a while loop. Write the while loop so that it stops iterating when the value of \\({1\\over k^n}\\) gets smaller than \\(1 \\times 10^{-6}\\).\n\n\n#Python code here\n\nIn the cell below you will find three lists containing the masses, lengths, and radii for a collection of cylinders. The moment of inertia for each cylinder can be calculated as \\[ I = {1\\over 4} M R^2 + {1\\over 12} M L^2\\].\n\nUse a loop to iterate over these lists and calculate the moment of inertia for each one. Store the calculated values in a new list. You should use the enumerate function on this problem.\nCalculate the largest, smallest, and average of the calculated values\n\n\nfrom numpy.random import uniform\nmass = uniform(3,8,1000)\nradius = uniform(0.5,1.2,1000)\nlength = uniform(0.8,3,1000)\n\nAn object that is dropped/thrown from a high altitude and allowed to fall through the air will experience a drag force that is opposite its motion. Because of that drag force, the velocity of the particle will not increase forever, but instead approach a constant velocity (called terminal velocity). The function that describes the velocity of the particle as a function of time is given by \\[ v(t) = -{mg \\over c} + \\left( {m g \\over c} + v_0\\right) e^{-c t \\over m}\\] and the terminal velocity is given by \\[v_t = -{m g \\over c}\\] where \\(m\\) is the mass of the projectile, \\(c\\) is the drag constant, \\(g= 9.8\\) m/s\\(^2\\) is the acceleration due to gravity, \\(v_0\\) is the initial velocity of the particle, and \\(t\\) is time.\n\nUse a while loop to calculate the velocity of the particle at \\(0.1\\) second time intervals, starting at \\(t = 0\\).\nThe loop should terminate when the velocity of the particle achieves \\(90\\%\\) of terminal velocity.\nUse a print statement to display the amount of time that has elapsed before reaching \\(90\\%\\) of terminal velocity.\nHypothesize about what might happen if you increased or decreased the mass of the object, while leaving all other physical parameters fixed. Then modify your code and see if your guess was right.\nHypothesize about what might happen if you increased or decreased the drag constant (c) for the object, while leaving all other physical parameters fixed. Then modify your code and see if your guess was right.\n\n\nfrom math import exp,sqrt\nm = 20\ng = 9.8\nc = 0.75\nv0=0\n\nIn the cell below you will find a dictionary containing the mass(in kg) and diameter of the planets in our solar system. Use a loop to iterate over this dictionary and calculate the acceleration due to gravity at the surface of the planet. \\[ g = {G M \\over R^2}\\]. Then add this value to the list for each planet. Print the dictionary when you are done to verify that each dictionary entry is a list with three elements.\n\nplanetData = {\"Mercury\": [0.33e24,4.879e6],\"Venus\":[4.87e24,1.2104e7],\"Earth\":[5.97e24,1.2756e7],\"Mars\":[0.642e24,6.792e6],\"Jupiter\":[1.898e27,1.42984e8],\"Saturn\":[5.68e26,1.20536e8],\"Uranus\":[8.68e25,5.1118e7],\"Neptune\":[1.02e26,4.9528e7],\"Pluto\":[0.013e24,2.376e7]}\n(Extra Credit) A transcendental equation is one that cannot be solved analytically (with pencil and paper). Try solving the following equation for x to see what I mean: \\[ {\\sin x \\over x} = 1\\] One numerical method for solving an equation like this involves first rearranging it to look like this: \\[ x = \\sin x\\] and then using a loop to repeatedly evaluating the right hand side, using the result of the previous evaluation as the input, until subsequent evaluations differ very little (\\(1 \\times 10^{-3}\\) would be fine). 1 The first few iterations of this process might look something like this: \\[(x_\\text{old})_1 = 2 \\text{ (starting guess)}\\] \\[(x_\\text{new})_1 = \\sin((x_\\text{old})_1)\\] \\[(x_\\text{old})_2 = (x_\\text{new})_1\\] \\[(x_\\text{new})_2 = \\sin((x_\\text{old})_2)\\] \\[(x_\\text{old})_3 = (x_\\text{new})_2\\] \\[(x_\\text{new})_3 = \\sin((x_\\text{old})_3)\\]1 This is called successive relaxation.\n\nUse a while loop to solve this equation and report the correct value for x.\n\nPlug the answer back into the equation to verify that it indeed does satisfy the equation.\nReport how many iterations it took to solve the problem.\nDecrease the value in the termination condition and observe how the number of iterations and the accuracy of the answer change.\nHint: You’ll have to define two variables: one to hold the old guess and one to hold the updated guess. Initialize these variables to any old values but make sure that they aren’t equal or your stopping criteria will trigger on the first iteration and the loop won’t run at all.\n\nxold = 2 # starting guess"
  },
  {
    "objectID": "chapters/functions.html",
    "href": "chapters/functions.html",
    "title": "8  Functions",
    "section": "",
    "text": "Jupyter Notebook\nWe have already been using functions here and there but in this chapter we will introduce them formally and get into the details. A function encapsulates a block of code designed to perform a specific task or set of tasks. To perform the task correctly, most functions require that you provide some information (called arguments) when you call them. To call a function you type the name of the function followed by the needed arguments enclosed in parenthesis (()).\nThe number and type of arguments allowed is different for every function. As a first example, let’s consider the print function, which is the simplest (and most familiar) function that we have used so far.\nPython functions generally fall into three groups: functions that come standard with Python (called native functions), functions that you can import into Python, and functions that you write yourself."
  },
  {
    "objectID": "chapters/functions.html#native-functions",
    "href": "chapters/functions.html#native-functions",
    "title": "8  Functions",
    "section": "8.1 Native Functions",
    "text": "8.1 Native Functions\nThere are a few functions that are always ready to go whenever you run Python. They are included with the programming language. We call these functions native functions. You have already been using some of them, like these\nmyList = [5,6,2,1]\na = len(myList)  # 'len' function is native.\n\nb = float(5) # 'float' function is native.\n\nc = str(67.3)  # 'str' function is native.\nThe len, float and str functions are all native and they all take a single argument. Other native function have been mentioned in previous chapters and others will be mentioned in the future."
  },
  {
    "objectID": "chapters/functions.html#imported-functions",
    "href": "chapters/functions.html#imported-functions",
    "title": "8  Functions",
    "section": "8.2 Imported Functions",
    "text": "8.2 Imported Functions\nMany times, you will need to go beyond what Python can do by itself2. However, that doesn’t mean you have to create everything you need to do from scratch. Most likely, the function that you need has already been coded. Somebody else created the function and made it available to anyone who wants it. Groups of functions that perform similar tasks are typically bundled together into libraries ready to be imported so that the functions that they contain can be used.2 For example, Python does not include \\(\\sin()\\) or \\(\\cos()\\) as Native functions.\nIn order to use use a function correctly, you’ll need to know what information(arguments) the function expects you to give it and what information the function intends to return to you as a result. This information can be found in the library’s documentation. Most libraries have great documentation with lists of the included functions, what the functions do, the expected arguments, and examples on how to use the most common ones. You can usually find the library documentation by searching the internet for the library’s name plus “Python documentation”.\nProviding a complete list of all available libraries and function is not really the purpose of this book. Instead, we’ll illustrate how to import functions and use them. As you use Python more and more you should get in the habit of searching out the appropriate library to accomplish the task at hand. When faced with a task to accomplish, your first thought should be, “ I’ll bet somebody has already done that. I’m going to try to find that library.”\nFunctions are imported using the import statement. You’ve already seen how to perform very simple mathematical calculations (\\(5/6\\),\\(84\\), etc..), but for more complex mathematical calculations like \\(\\sin( {\\pi \\over 2} )\\) or \\(e^{2.5}\\) , you’ll need to import these functions from a library.\nimport math\n\na = math.sqrt(5.2)\nb = math.sin(math.pi)\nc = math.e**2.5\nThe math. before each function is equivalent to telling Python “Use the sqrt() function that you will find in the math book I told you to grab.” If you just type\nsqrt(5.2)\nPython won’t know where to find the sqrt function and an error message will result. Sometimes the name of the module can be long and typing module. every time you want to use one of it’s functions can be cumbersome. One way around this is to rename the module to a shorter name using the as statement.\nimport math as mt\n\na = mt.sqrt(5.2)\nb = mt.sin(mt.pi)\nc = mt.e**2.5\nInstead of importing an entire module, you can import only a selection of functions from that module using the from statement. This can make your code even more succinct by eliminating the module. prefix altogether. The trade-off is that it won’t be as clear which function belongs to which module.\nfrom math  import sqrt, sin, pi, e\n\na = sqrt(5.2)\nb = sin(pi)\nc = e**2.5\nAll of the functions belonging to a module can be imported at once using *.\nfrom math import *\n\na = sqrt(5.2)\nb = sin(pi)\nc = e**2.5"
  },
  {
    "objectID": "chapters/functions.html#user-defined-functions",
    "href": "chapters/functions.html#user-defined-functions",
    "title": "8  Functions",
    "section": "8.3 User-defined Functions",
    "text": "8.3 User-defined Functions\nAfter having programmed for a while, you will notice that certain tasks get repeated frequently. For example, maybe in your research project you need to calculate the force exerted on an atom due to many other nearby atoms. You could copy and paste your force-calculation code every time it was needed, but that would likely result in lots of extra code and become very cumbersome to work with. You can avoid this by creating your own function to calculate the force between any two atoms. Then, every time you need another force calculation, you simple call the function again. You only write the force-calculation part of the code once and then you execute it as many times as you need to.\nTo create your own function, you first need to name the function. The name should be descriptive of what it does and makes sense to you and anyone else who might use it. The first line of a function definition starts with the def statement (short for definition) followed by the name of the function with whatever information, called arguments, that needs to be fed into the function enclosed in parenthesis. The last character in this line must be a colon. Everything inside the function is indented four spaces and placed directly below the first line.\ndef functionName(arg1,arg2,arg3):\n    # Body of Function\n    # Body of Function\n    # Body of Function\nAs an example, let’s construct a function that calculates the distance between two atoms. The function will need to know the location of each atom, which means that there should be two arguments: the xyz coordinates of both atoms passed as a pair of lists or tuples.\n\nimport math\n\ndef distance(coords1,coords2):\n\n    dx = coords1[0] - coords2[0]\n    dy = coords1[1] - coords2[1]\n    dz = coords1[2] - coords2[2]\n    d = math.sqrt(dx**2 + dy**2 + dz**2)\n    print(f\"The distance is {d:5.4f}.\")\n\ndistance([1,2,3],[4,5,6])\n\ndistance([4.2,9.6,4.8],[2.9,2.6,3.4])\n\nThe distance is 5.1962.\nThe distance is 7.2560.\n\n\nThis function works just fine with integers or floats for the coordinates.\n\n8.3.1 The return statement\nThe distance function prints out the value for the distance, but what if we want to use this distance in a subsequent calculation? Maybe we want to calculate the average distance between several pairs of atoms. We can instruct the function to return the final distance using the return statement. If the arguments to the function are the inputs, the return statement specifies what the output is. Let’s modify the function above to include a return statement.\n\nimport math\ndef distance(coords1,coords2):\n    dx = coords1[0] - coords2[0]\n    dy = coords1[1] - coords2[1]\n    dz = coords1[2] - coords2[2]\n    d = math.sqrt(dx**2 + dy**2 + dz**2)\n    return d\n\ndistOne = distance([1,2,3],[4,5,6])\n\ndistTwo = distance([4.2,9.6,4.8],[2.9,2.6,3.4])\n\naverageDistance = (distOne + distTwo)/2\n\nprint(f\"The average distance is {averageDistance:5.4f}.\")\n\nThe average distance is 6.2261.\n\n\n\n\n8.3.2 Local vs Global Variable Scope\nVariables created inside of a function have local scope. This means that they are not accessible outside of the function. In our distance function the variables dx,dy,dz, and d were all local variables that are used inside the function but have no value outside of it. This is convenient because we don’t have to worry about overwriting a variable or using it twice. If someone sends you a function and you want to use it in your code, you don’t have to worry about what variable he/she chose to use inside his function; they won’t affect your code at all.\ndef distance(coords1,coords2):\n    dx = coords1[0] - coords2[0]\n    dy = coords1[1] - coords2[1]\n    dz = coords1[2] - coords2[2]\n    d = math.sqrt(dx**2 + dy**2 + dz**2)\n    return d\n\ndistOne = distance([1,2,3],[4,5,6])\n\nprint(dx)  # There is no value associated with this variable outside of the function.\nThe down side to all of this is that you don’t have access to function variables unless you pass them out of the function using the return statement.\nAny variables defined outside of a function is called a global variable, which means that Python remembers these assignments from anywhere in your code including inside of functions. Using global variables with the intention to use them inside of functions is usually considered bad form and confusing and is discouraged. One notable exception to this rule are physical constants like \\(g = 9.8\\) m/s\\(^2\\) (acceleration due to gravity on Earth) or \\(k_B = 1.38 \\times 10^{-23}\\) (Boltzmann’s constant which is used heavily in thermodynamics) because these values will never change and may be used repeatedly. Generally speaking every variable that is used in a function ought to be either i) passed in as an argument or ii) defined inside of the function. Below is an example of an appropriate use of a global variable.\ndef myFunction(a,b):\n    c=a+g # <--- Notice the reference to 'g' here \n    d = 3.0 * c\n    f = 5.0 * d**4\n    return f\n\n#The variable below are global variables. \nr = 10\nt = 15\ng = 9.8         #<--- g defined to be a global variable\nresult = myFunction(r,t)\n\n\n8.3.3 Positional vs. Keyword Arguments\nThe function arguments we have been using so far are called positional arguments because they are required to be in a specific position inside the parenthesis. To see what I mean consider the example below.\n\ndef example(a,b):\n    return a**b\n\n\nresultOne = example(5,2)\nresultTwo = example(2,5)\n\nprint(resultOne, resultTwo)\n\n25 32\n\n\nIn the first call to example the local variable a gets assigned to be 5 and the local variable b gets assigned 2. In the second call the order of the arguments is switched and the subsequent assignments to a and b switch with it. This produces a different result from the function. Positional arguments are very common but the user must know what information goes where when calling the function.33 This is another reason why you want to choose meaningful variable names for your arguments.\nThe other type of argument is the keyword argument. These arguments are attached to a keyword inside of the parenthesis. The advantage of a keyword argument is that the user does not need to be concerned about the location of the argument as long as it has the proper label.\n\ndef example(a=1,b=2):\n    return a**b\n\n\nresultOne = example(a=5,b=2)\nresultTwo = example(b=2,a=5)\n\nprint(resultOne, resultTwo)\n\n25 25\n\n\nAnother advantage to using keyword arguments is that a default value can be coded into the function. This means that we can call the function with some arguments missing and default values will be used for them. In the example above, the default value of b is 2 and if the function is called without specifying a value for that argument, the function will proceed as usual using the default value for b.\n\ndef example(a=1,b=2):\n    return a**b\n\n\nresult = example(a=5)\n\nprint(result)\n\n25\n\n\n\n\n8.3.4 Splatting\nFunctions can potentially require dozens of arguments to be passed in which can make calling the function long and difficult to look at. One way to shorten the code is to put all of the arguments in a list or tuple.\n\ndef func(a,b,c,d):\n\n    return a**b + c/d\nargs  = (5,4,6,3)\n\nresult = func(*args)\n\nprint(result)\n\n627.0\n\n\n\n\n8.3.5 Lambda Functions\nWhen the function you want to construct is very simple (one line), there is a shortcut code for making it called a lambda function. The benefit is that they occupy less lines of code than the standard def functions. A lambda function is defined as shown below with the variable immediately after the lambda statement as the independent variable in the function.\n\nf = lambda x: x**2\n\nprint(f(5))\n\n25\n\n\nAs a simple application of lambda functions let’s consider a function from the scipy.integrate library called quad which will perform a numerical integration of a function. The quad function takes three arguments: the function to be integrated, and the upper and lower bound on the integral. We can use a lambda function for the first argument rather than using several lines of code to build one in the traditional fashion.\n\nfrom scipy.integrate import quad\nfrom math import sin, pi\n\nquad(lambda x: sin(pi * x)**2,0,0.4 )\n\n(0.15322553581056808, 1.7011451781741914e-15)"
  },
  {
    "objectID": "chapters/functions.html#flash-cards",
    "href": "chapters/functions.html#flash-cards",
    "title": "8  Functions",
    "section": "8.4 Flash Cards",
    "text": "8.4 Flash Cards\n\nDescribe the basic structure and key elements of a user-defined function.\nWhat are function arguments?\nList all of the ways that a function can be imported from a module.\nWhat does the return statement do?\nWhat is the difference between a local and global variables?\nWhat is a keyword argument? Give an example.\nWhat is a lambda function? How do you make one?\nRecite Alma 32:21."
  },
  {
    "objectID": "chapters/functions.html#exercises",
    "href": "chapters/functions.html#exercises",
    "title": "8  Functions",
    "section": "8.5 Exercises",
    "text": "8.5 Exercises\n\nA wooden block is placed on a horizontal surface and pushed across the floor with an initial velocity of \\(v_0\\). The expression for the position of the block after \\(t\\) seconds have elapsed is \\[x(t) = v_0 t - {1\\over 2} \\mu g t^2\\] where \\(\\mu\\) is the coefficient of friction and \\(g = 9.8\\) m/s\\(^2\\). You can easily calculate the time it takes for the block to come to rest to be \\[ T = {v_0 \\over \\mu g}\\].\n\nWrite a function that takes the coefficient of friction and the initial velocity as arguments and returns the total distance traveled while coming to rest.\n\nCall the function for \\(v_0 = 7.2\\) m/s and the following values of \\(\\mu = 0.62,0.3,0.45,0.2\\). The answers should be: \\([4.266, 8.816, 5.878, 13.224]\\).\nUse list comprehension to put these travel distances into a list.\n\nUse the zip function to combine the list of friction coefficients with the list of travel distances.\nUse a print statement to verify that you did it correctly.\n\nIn quantum mechanics you will learn that the energy of an electron can’t just be any old value, but can only be certain discrete values. For the hydrogen atom, the allowed energy levels for the electron (in units of electron-volts) are given by \\[E(n) = {-m_e e^3 \\over 32 \\pi^2 \\epsilon_0^2 \\hbar^2 n^2}\\] where \\(n\\) must be an integer and the other constants are\n\n\\(m_e = 9.109 \\times 10^{-31}\\) kg is the mass of an electron.\n\\(e = 1.602 \\times 10^{-19}\\) C is the fundamental.\n\\(\\epsilon_0 = 8.854 \\times 10^{-12}\\) C V\\(^{-1}\\) m\\(^{-1}\\) is the electrical constant.\n\\(\\hbar = 1.054 \\times 10^{-34}\\) J s is the reduced Planck constant.\n\n\nConstruct a function that takes the quantum number (\\(n\\)) as an argument and returns the energy of the electron in units of electron-volts. All of the fundamental constants in the equation should appear as keyword arguments with default values attached. Call the function for a few values of \\(n\\) to make sure it is working. You should find that \\(E(1) = -13.6\\) eV, \\(E(2) = -3.4\\) eV, \\(E(3) = -1.5\\) eV, etc.\nWhen an electron transitions from a high energy state to a low energy state, it releases a bundle of light (called a “photon”) with an energy that is exactly equal to the energy difference. Use the function you built in part 1 to calculate the energy of a photon that is released when an electron transitions from the \\(n = 5\\) state to the \\(n = 2\\) state.\nThe wavelength (\\(\\lambda\\)) of the photon can by calculated using the following equation: \\[\\lambda = {2 \\pi \\hbar c \\over e \\Delta E}\\]. Calculate the wavelength of light released for the transition described in part 2. Go to this website and determine what color this corresponds to.\nUse list comprehension together with the function you built in part 1 to build a list containing the 15 lowest-energy levels for the hydrogen atom.\n\n\nme = 9.109e-31\n\nMax Planck discovered that all objects emit a spectrum of radiation and that the intensity of the spectrum depends on the object’s temperature. The equation for the intensity of the emitted light is \\[ I(\\lambda) = {2 \\pi h c^2 \\over \\lambda^5} {1\\over e^{hc \\over \\lambda k_BT} - 1}\\] where\n\n\\(c = 3.0 \\times 10^8\\) m/s is the speed of light.\n\\(h = 6.26 \\times 10^34\\) m\\(^2\\) kg /s is Plank’s constant.\n\\(k_B = 1.38 \\times 10^{-23}\\) m\\(^2\\)kg s\\(^{-2}\\) K\\(^{-1}\\) is the Boltzmann constant.\nT is temperature in Kelvins.\n\\(\\lambda\\) is wavelength in meters.\n\n\nWrite a function that takes two arguments: the temperature of the object and the wavelength of light. All other physical constants should appear as keyword arguments with appropriate default values attached. The function should return the corresponding light intensity given by the function above.\nThe temperature of the sun is approximately \\(5780\\) K and it emits strongly in the visible region of the spectrum. Use the function you built in part 1 to calculate the intensity of light emitted by the sun at the following wavelengths: [250 nm, 500 nm, 750 nm, 1000 nm, 1500 nm] (“nm” is short for nano-meters or \\(\\times 10^{-9}\\) meters). Use list comprehension to build a list of these intensities. Comment on the trend that you notice.\nThe coldest temperature ever measured in our solar system was \\(25\\) K at the bottom of a lunar crater during “night” time. That’s -410\\(^\\circ\\) F.. Yowza! However, during “day” time, the temperature of the moon is about \\(400\\) K. Compute the intensity of daytime light emitted by the moon for the same wavelengths given in part 2. As before, use list comprehension to put these intensities into a list. How do these intensities compare to the sun’s?\n\nThe moon emits strongest in the infrared region of the spectrum (\\(\\lambda > 750\\) nm) which our eyes are not able to see. The only reason we can see the moon is because it reflects light from the sun. Recalculate the intensity of light from the moon for the following infrared wavelengths: [6000 nm, 7500 nm, 9000 nm, 10000 nm, 12000 nm]. How do these intensities compare to the sun’s light?"
  },
  {
    "objectID": "chapters/numpy.html",
    "href": "chapters/numpy.html",
    "title": "9  The numpy module",
    "section": "",
    "text": "Jupyter Notebook\nNumpy (short for “numerical python” and pronounced “num”-“pie”) is a popular Python library that is heavily used in the scientific/mathematical community. So much so that numpy is typically included as part of the standard bundle of libraries that comes with your Python installation. The functions inside numpy will allow you to solve problems with less effort and will produce faster-executing code."
  },
  {
    "objectID": "chapters/numpy.html#numpy-arrays",
    "href": "chapters/numpy.html#numpy-arrays",
    "title": "9  The numpy module",
    "section": "9.1 Numpy Arrays",
    "text": "9.1 Numpy Arrays\nYou are already familiar with Python lists but may not have noticed that they are not suitable for mathematical calculations. For example, attempting to multiply a list by a scalar or evaluating a mathematical function like \\(\\sin()\\) on a list will not produce a mathematical result or may produce an error. For example, consider the following code.\n\nmyList = [4,5,7]\n\nnewList = 2 * myList\nprint(newList)\n\n[4, 5, 7, 4, 5, 7]\n\n\nYou probably expected newList to be [8,10,14] but multiplying a list by a number doesn’t do that. Instead it repeats the list and concatenates it to itself. To multiply each element of a list by a number you must use a for loop.\n\nmyList = [4,5,7]\n\nnewList = []\nfor i in myList:\n    newList.append(i* 2)\n\nprint(newList)\n\n[8, 10, 14]\n\n\nbut this seems overly cumbersome for such a simple task. Numpy ndarrays (short for n-dimensional arrays) or just arrays make this task much simpler. Arrays are similar to lists or nested lists except that mathematical operations and numpy functions (but not math functions) automatically propagate to each element instead of requiring a for loop to iterate over it. Because of their power and convenience, arrays are the default object type for any operation performed with NumPy."
  },
  {
    "objectID": "chapters/numpy.html#array-creation",
    "href": "chapters/numpy.html#array-creation",
    "title": "9  The numpy module",
    "section": "9.2 Array Creation",
    "text": "9.2 Array Creation\n\n9.2.1 Type Conversion from List\nYou can create an array from a list using numpy’s array function. The list that is to be converted is the argument to the array function. Mathematical operations can then be performed on the array and that operation will propagate through to all of the elements.\n\nfrom numpy import array\n\nmyArray = array([4,5,7])\n\nnewArray = 2 * myArray \n\nprint(newArray)\n\n[ 8 10 14]\n\n\nNested lists, or lists that contain lists as their elements, can be converted to multi-dimensional arrays using the array function.\n\nfrom numpy import array\nmyArray = array([[1,2,3],[4,5,6]])\n\nprint(myArray)\n\n[[1 2 3]\n [4 5 6]]\n\n\n\n\n9.2.2 The arange and linspace Functions\nNumpy has some sequence-generating functions that generate arrays by specifying start, stop, and step size values similar to the way range generates a list. The two most common ones are arange and linspace. The arange function behaves very similar to the native Python range function with a few notable exceptions:\n\narange produces an array whereas range produces a list.\nThe step size for arange does not need to be an integer.\nrange produces an iterator and arange generates a sequence of values immediately.\n\nThe arguments to arange are similar to range\narange(start,stop,step)\nThe linspace function is related to the arange function except that instead of specifying the step size of the sequence, the sequence is generated based on the number of equally-spaced points in the given span of numbers. Additionally, arange excludes the stop value while linspace includes it. The difference between these two functions is subtle and the use of one over the other often comes down to user preference or convenience.\nlinspace(start,stop,number of points)\nBelow is an example that shows the usage of linspace and arange.\n\nfrom numpy import linspace,arange\n\nmyArray = linspace(0,10,20)\nmyArray2 = arange(0,10,0.5)\nprint(myArray)\nprint(myArray2)\n\n[ 0.          0.52631579  1.05263158  1.57894737  2.10526316  2.63157895\n  3.15789474  3.68421053  4.21052632  4.73684211  5.26315789  5.78947368\n  6.31578947  6.84210526  7.36842105  7.89473684  8.42105263  8.94736842\n  9.47368421 10.        ]\n[0.  0.5 1.  1.5 2.  2.5 3.  3.5 4.  4.5 5.  5.5 6.  6.5 7.  7.5 8.  8.5\n 9.  9.5]\n\n\nWhen using linspace you may still want to know what the sequence spacing is. You can request that linspace provide this information by adding the optional argument retstep = True to the argument list. With this addition, linspace not only returns the sequence to you, but also the stepsize.\n\nfrom numpy import linspace,arange\n\nmyArray,mydx = linspace(0,10,20,retstep= True)\nprint(mydx)\nprint(myArray)\n\n0.5263157894736842\n[ 0.          0.52631579  1.05263158  1.57894737  2.10526316  2.63157895\n  3.15789474  3.68421053  4.21052632  4.73684211  5.26315789  5.78947368\n  6.31578947  6.84210526  7.36842105  7.89473684  8.42105263  8.94736842\n  9.47368421 10.        ]\n\n\nTwo other useful functions for generating arrays are zeros and ones which generate arrays populated with exclusively ones or zeros. The functions require shape arguments as a tuple or list to specify the shape of the array.\nzeros((rows,columns))\nIf the array to be created is only one dimensional, the argument can be a single number instead of a tuple.\nzeros(n)\n\nfrom numpy import zeros,ones\n\nmyArray = zeros([3,4])\nmyArray2 = ones(5)\nprint(myArray)\nprint(myArray2)\n\n[[0. 0. 0. 0.]\n [0. 0. 0. 0.]\n [0. 0. 0. 0.]]\n[1. 1. 1. 1. 1.]\n\n\nArrays of any constant (not just one or zero) can then be easily generated by performing the needed math on the original array.\n\nfrom numpy import zeros,ones\n\nmyArray = zeros([3,4]) + 5\nmyArray2 = ones(5) * 12\nprint(myArray)\nprint(myArray2)\n\n[[5. 5. 5. 5.]\n [5. 5. 5. 5.]\n [5. 5. 5. 5.]]\n[12. 12. 12. 12. 12.]\n\n\n\n\n9.2.3 Arrays from Functions\nA third approach is to generate an array from a function using the fromfunction function which generates an array of values using the array indices as the inputs. Ths function requires two arguments: the name of the function being used and the shape of the array being generated.\nfromfunction(function, shape)\nLet’s make a 3 x 3 array where each element is the product of the row and column indices:\n\nfrom numpy import fromfunction\n\ndef prod(x,y):\n    return x * y\n\nmyArray = fromfunction(prod,(3,3))\nprint(myArray)\n\n[[0. 0. 0.]\n [0. 1. 2.]\n [0. 2. 4.]]\n\n\nThe table below gives a summary of useful functions for creating numpy arrays. The required arguments are also described.\n\nCommon functions for generating arrays\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\nlinspace(start,stop,n)\nReturns an array of n evenly-spaced points begining at start and ending at stop.\n\n\narange(start,stop,dx)\nReturns an array beginning at start,ending at stop with a step size of dx.\n\n\nempty(dims)\nReturns an empty array with dimensions dim.\n\n\nzeros(dims)\nReturns an array of zeros with dimensions dim.\n\n\nones(dims)\nReturns an array of ones with dimensions dim.\n\n\nzeros_like(arr)\nReturns an array of zeros with dimensions that match the dimensions of arr.\n\n\nfromfunction(function,dims)\nReturns an array of numbers generated by evaluating function on the indices of an array with dimensions dims.\n\n\ncopy(arr)\nCreates a copy of array arr.\n\n\ngenfromtext(file)\nReads file and loads the text into an array (file must only contain numbers)."
  },
  {
    "objectID": "chapters/numpy.html#accessing-and-slicing-arrays",
    "href": "chapters/numpy.html#accessing-and-slicing-arrays",
    "title": "9  The numpy module",
    "section": "9.3 Accessing and Slicing Arrays",
    "text": "9.3 Accessing and Slicing Arrays\nAccessing and slicing arrays can be done in exactly the same way as is done with lists. However, there is some additional functionality for accessing and slicing arrays that do not apply to lists.\n\n9.3.1 One-dimensional Arrays\nElements from a one-dimensional array can be extracted using square brackets ([]) just like we have done with lists.\n\nfrom numpy import array\n\nmyArray = array([3,4,7,8])\nprint(myArray[2])\n\n7\n\n\n\n\n9.3.2 Multi-dimensional Arrays\nMulti-dimensional array can be indexed in a similar fashion to nested lists, but because we often encounter multi-dimensional arrays there is a shortcut that makes the syntax simpler and more convenient. Let’s consider a two-dimensional array as an example. To access the entire second row of the array, provide the row index in square brackets just as with one-dimensional arrays.\n\nfrom numpy import array\nmyArray = array([[1,2,3],[4,5,6], [7,8,9]])\n\nprint(myArray[1])\n\n[4 5 6]\n\n\nTo access the second element in the second row, we can add another set of square brackets with the appropriate index inside, just as we did with nested lists. However, for convenience the second set of square brackets can be omitted and the row and column indices can be placed next to each other and separated by a comma.\narray_name[row,column]\n\nfrom numpy import array\nmyArray = array([[1,2,3],[4,5,6], [7,8,9]])\n\nprint(myArray[1][1])  # This works, but is a bit hard on the eyes\nprint(myArray[1,1])  # This works also and is easier to look at.\n\n5\n5\n\n\n\n\n9.3.3 Accessing Multiple Elements\nMultiple elements of an array can be accessed using a list for the index instead of a single number.\n\nfrom numpy import array\n\nmyArray = array([1,2,3,4,5,6,7,8,9,10])\n\nprint(myArray[2])  # Extract element 2\nprint(myArray[ [3,6,9] ])  # Extract elements 3, 6, and 9.\n\n3\n[ 4  7 10]\n\n\nThis can even be done with multi-dimensional arrays. If the index is a single list, the corresponding rows will be extract. If the corresponding list of columns is added to the index list, individual elements will be extracted.\narray_name[[rows]]  # Access set of rows\narray_name[[rows], [columns]]  # Access set of elements\n\nfrom numpy import array\nmyArray = array([[1,2,3],[4,5,6], [7,8,9]])\n\nprint(myArray[[0,1]]) # Extract rows 0 and 1.\n\nprint(myArray[[1,2,0],[0,2,2]])   # Extract elements (1,0), (2,2), and (0,2)  \n\n[[1 2 3]\n [4 5 6]]\n[4 9 3]"
  },
  {
    "objectID": "chapters/numpy.html#slicing-arrays",
    "href": "chapters/numpy.html#slicing-arrays",
    "title": "9  The numpy module",
    "section": "9.4 Slicing Arrays",
    "text": "9.4 Slicing Arrays\n\n9.4.1 Multi-dimensional Arrays\nWe’ve already shown you how to slice a list using the : operator. The same can be done with arrays. However, for 2D (and higher) arrays the slicing is more powerful (intuitive). It can be helpful to visualize an array as a matrix, even if it is not being treated that way Mathematically. For example, let’s say that you define the following array:\nfrom numpy import array\nmyArray = array([[1,2,3],[4,5,6], [7,8,9]])\nwhich can be visualized as the following matrix:\n\\[\n\\begin{pmatrix}\n1&2&3\\\\\n4&5&6\\\\\n7&8&9\\\\\n\\end{pmatrix}\n\\]\nTo slice out the following \\(2\\) x \\(2\\) sub matrix:\n\\[\n\\begin{pmatrix}\n5&6\\\\\n8&9\\\\\n\\end{pmatrix}\n\\]\nwe could do\n\nfrom numpy import array\nmyArray = array([[1,2,3],[4,5,6], [7,8,9]])\n\nprint(myArray[1:3,1:3])\n\n[[5 6]\n [8 9]]\n\n\nTo include all of the elements in a given dimension, use the : alone with no numbers surrounding it.\n\nfrom numpy import array\nmyArray = array([[1,2,3],[4,5,6], [7,8,9]])\n\nprint(myArray[:,1:3])  # Extract all rows with columns 1 and 2\n\n[[2 3]\n [5 6]\n [8 9]]\n\n\n\n\n9.4.2 Boolean Slicing\nBoolean operations can be evaluated on arrays to produce corresponding arrays of booleans. The boolean array can then be used to index the original array and extract elements that meet some criteria.\n\nfrom numpy import array\n\na = array([1,2,3,4,5,6])\n\nboolArray = a > 2\n\nprint(boolArray)\n\nprint(a[boolArray])\n\n[False False  True  True  True  True]\n[3 4 5 6]\n\n\nThis also works on multi-dimensional arrays although the result is always one-dimensional regardless of the shape of the original array.\n\nfrom numpy import array\nmyArray = array([[1,2,3],[4,5,6], [7,8,9]])\n\nprint(myArray[myArray>2]) # Extract elements that are greater than 2.\n\n[3 4 5 6 7 8 9]"
  },
  {
    "objectID": "chapters/numpy.html#vectorization-and-broadcasting",
    "href": "chapters/numpy.html#vectorization-and-broadcasting",
    "title": "9  The numpy module",
    "section": "9.5 Vectorization and Broadcasting",
    "text": "9.5 Vectorization and Broadcasting\nA major advantage of numpy arrays over lists is that operations vectorize across the arrays. This means that mathematical operations propagate through the array instead of requiring a for loop. This speeds up the calculation and makes code easier to write and read. Simple mathematical operations like adding, subtracting, etc can be performed on arrays as you would expect and the operation propagates through to all elements.\n\nfrom numpy import array\n\na = array([1,2,3])\nb = array([4,5,6])\n\nc = a + b\nd = a**2\ne = 2 * b\nf = 2/b\ng = a * b\n\nprint(c,d,e,f,g)\n\n[5 7 9] [1 4 9] [ 8 10 12] [0.5        0.4        0.33333333] [ 4 10 18]\n\n\nAll of the common mathematical operations that you learned for numbers now apply to arrays. Cool!\n\n9.5.1 Numpy Functions\nThe numpy library has a massive collection of vectorized mathematical functions and these functions should be used instead of similar functions from other libraries that are not vectorized (like math).\n\nfrom numpy import array\nfrom numpy import sqrt as nsqrt\nfrom math import sqrt as mathsqrt\n\nsquares = array([1,4,9,16,25])\n\nprint(nsqrt(squares))\n#print(mathsqrt(squares))  #This will fail because it wasn't a numpy function.\n\n[1. 2. 3. 4. 5.]\n\n\n\n\n9.5.2 Arrays of same Dimensions\nIf a mathematical operation is performed between two arrays of the same dimensions, the mathematical operation is performed between corresponding elements in the two arrays. For example, if two \\(2\\) x \\(2\\) arrays are added together, element (0,0) of the first array gets added to the corresponding element in the second and so forth for all elements:\n\\[\n\\begin{pmatrix}\n1&2\\\\\n3&4\\\\\n\\end{pmatrix}+\n\\begin{pmatrix}\n5&6\\\\\n7&8\\\\\n\\end{pmatrix}=\n\\begin{pmatrix}\n6&8\\\\\n10&12\\\\\n\\end{pmatrix}\n\\]\n\nfrom numpy import array\n\na = array([[1,2],[3,4]])\nb = array([[5,6],[7,8]])\n\nc = a + b  # Add the elements of the arrays together.\nd = a * b  # Multiply the elements of the arrays together.\n\nprint(c)\nprint(d)\n\n[[ 6  8]\n [10 12]]\n[[ 5 12]\n [21 32]]\n\n\n\n\n9.5.3 Arrays of Different Dimensions\nWhen a mathematical operation between two arrays of different dimensions is attempted, Python has to figure out how to make them have the same shape before performing the operation. Broadcasting refers to the set of rules used for operations like this. To handled arrays with different dimensions, NumPy pads or clones the array with fewer dimensions to make it have the same dimensions as the larger array. For example, what would happen if you attempted this operation:\n\\[\n\\begin{pmatrix}\n1&2\\\\\n3&4\\\\\n\\end{pmatrix}+\n\\begin{pmatrix}\n2&2\\\\\n\\end{pmatrix}\n\\]\nOne array is \\(2\\) x \\(2\\) and the other is \\(1\\) x \\(2\\). Before the addition can take place, NumPy clones the smaller array and repeats it until it has the same size as the bigger array.\n\\[\n\\begin{pmatrix}\n1&2\\\\\n3&4\\\\\n\\end{pmatrix}+\n\\begin{pmatrix}\n2&2\\\\\n2&2\\\\\n\\end{pmatrix}\n\\]\n\nfrom numpy import array\n\na = array([[1,2],[3,4]])\nb = array([2,2])\nc = a + b\n\nprint(c)\n\n[[3 4]\n [5 6]]\n\n\nThere are some cases where NumPy simply cannot figure out how to broadcast one of the arrays appropriately and an error results. When broadcasting, NumPy must verify that all dimensions are compatible with each other. Two dimensions are compatible when i) they are equal or ii) one of the dimensions is 1. For example, if we tried to perform the following mathematical operation, broadcasting would fail because the first dimension of the first array is 2 and the first dimension of the second array is 3.\n\\[\n\\begin{pmatrix}\n1&2&3\\\\\n3&4&5\\\\\n\\end{pmatrix}+\n\\begin{pmatrix}\n1&1&1\\\\\n2&2&2\\\\\n3&3&3\\\\\n\\end{pmatrix}\n\\]\nfrom numpy import array\n\na = array([[1,2,3],[4,5,6]])\nb = array([[1,1,1],[2,2,2],[3,3,3]])\nc = a + b\nbut if we attempted\n\\[\n\\begin{pmatrix}\n1&2&3\\\\\n\\end{pmatrix}+\n\\begin{pmatrix}\n1&1&1\\\\\n2&2&2\\\\\n3&3&3\\\\\n\\end{pmatrix}\n\\]\nthe operation would succeed because the first dimension of the first array is 1 and the second dimension of both arrays are 3.\n\n\n9.5.4 Vectorizing user-defined functions\nStandard Python functions are often designed to perform a single calculation rather than iterate over a list to perform many calculations. For example, here is a function to calculate the average acceleration of an object given its final velocity and time of travel.\n\ndef accel(velocity, time):\n    return velocity / time\n\n\nprint(accel(52.6,5.6))\n\n9.392857142857144\n\n\nNow what if I have a list of many times that I’d like to feed into this function and get an acceleration value for each one.\ndef accel(velocity, time):\n    return velocity / time\n\n\ntimes = [4.6,7.9,3.2,8.5,9.2,4.7]\nprint(accel(52.6,times))  # Produces an error because you can't divide by a list\nAn error results here because Python does not know how to divide by a list. We can NumPy-ify this function using a function called vectorize. The resulting function will behave just like the other functions from the NumPy library, vectorizing across the list of times.\n\nfrom numpy import vectorize\ndef accel(velocity, time):\n    return velocity / time\n\n\ntimes = [4.6,7.9,3.2,8.5,9.2,4.7]\nvaccel = vectorize(accel)  # Vectorize the function!\nprint(vaccel(52.6,times))  # Succeeds because NumPy knows how to vectorize.\n\n[11.43478261  6.65822785 16.4375      6.18823529  5.7173913  11.19148936]\n\n\nOf course, we also could have just converted our times list into an array and used the original function.\n\nfrom numpy import array\ndef accel(velocity, time):\n    return velocity / time\n\n\ntimes = array([4.6,7.9,3.2,8.5,9.2,4.7])\nprint(accel(52.6,times))  # Succeeds because times is an array not a list.\n\n[11.43478261  6.65822785 16.4375      6.18823529  5.7173913  11.19148936]"
  },
  {
    "objectID": "chapters/numpy.html#manipulating-and-modifying-arrays",
    "href": "chapters/numpy.html#manipulating-and-modifying-arrays",
    "title": "9  The numpy module",
    "section": "9.6 Manipulating and Modifying Arrays",
    "text": "9.6 Manipulating and Modifying Arrays\nA wealth of functions exist to perform routine manipulation tasks on arrays once they are created. Often these tasks will involve changing the number of rows or columns or merging two arrays into one. The size and shape of an array are the number of elements and dimensions, respectively. These can be determined using the shape and size methods.\n\nfrom numpy import array\n\na = array([[1,2,3],[4,5,6]])\nprint(a.size)\nprint(a.shape)\n\n6\n(2, 3)\n\n\n\n9.6.1 Reshaping Arrays\nThe dimensions of an array can be modified using the reshape function. This methods maintains the number of elements and the order of elements but repacks them into a different number of rows and columns. Because the number of elements is maintained, the size of the new array has to be the same as the original. Let’s see an example.\n\nfrom numpy import array, reshape\n\na = array([[1,2,3],[4,5,6]])\n\nb = reshape(a,[3,2])\n\nprint(a)\nprint(b)\n\n[[1 2 3]\n [4 5 6]]\n[[1 2]\n [3 4]\n [5 6]]\n\n\nThe original array (a) was a \\(2\\) x \\(3\\) and had \\(6\\) elements and the reshaped array also has \\(6\\) elements but is a \\(3\\) x \\(2\\). You can start with a one-dimensional array and reshape it to a higher dimensional array.\n\nfrom numpy import linspace, reshape\n\na = linspace(0,10,12)\n\nb = reshape(a,[3,4])\n\nprint(a)\nprint(b)\n\n[ 0.          0.90909091  1.81818182  2.72727273  3.63636364  4.54545455\n  5.45454545  6.36363636  7.27272727  8.18181818  9.09090909 10.        ]\n[[ 0.          0.90909091  1.81818182  2.72727273]\n [ 3.63636364  4.54545455  5.45454545  6.36363636]\n [ 7.27272727  8.18181818  9.09090909 10.        ]]\n\n\n\n\n9.6.2 Flattening Arrays\nFlattening an array takes a higher-dimensional array and squishes it into a one-dimensional array. You can “flatten” an array with the flatten method, but note that flatten doesn’t actually modify the original array.\n\nfrom numpy import array\n\na = array([[1,2,3],[4,5,6]])\na.flatten()\n\nprint(a)  # 'a' remains unchanged\n\na = a.flatten() # If you want to change the definition of a, redifine it.\nprint(a)\n\n[[1 2 3]\n [4 5 6]]\n[1 2 3 4 5 6]\n\n\n\n\n9.6.3 Transposing Arrays\nTransposing an array rotates it across the diagonal and can be accomplished with the transpose function. There is also a shortcut method for this of array.T to accomplish the same thing but just as with flatten it does not modify the original array. (neither does transpose)\n\nfrom numpy import array,transpose\n\na = array([[1,2,3],[4,5,6]])\ntranspose(a)\n\nprint(a)  # 'a' remains unchanged\n\na = a.T # If you want to change the definition of a, redefine it.\nprint(a)\n\n[[1 2 3]\n [4 5 6]]\n[[1 4]\n [2 5]\n [3 6]]\n\n\n\n\n9.6.4 Merging Arrays\nSeveral function exist for combining multiple arrays into a single array. We’ll give examples for a couple and mention the others in reference tables. The most commonly used functions for this task are vstack (vertical stacking) and hstack (horizontal stacking). vstack will stack the original arrays vertically to create the new array and hstack will stack them horizontally. Here are some examples.\n\nfrom numpy import linspace, hstack, vstack\n\na = linspace(0,10,10)\nb = linspace(0,5,10)\n\nc = vstack((a,b))\nprint(c)  # 'a' remains unchanged\n\nd = hstack((a,b))\nprint(a.T)\nprint(d)\n\n[[ 0.          1.11111111  2.22222222  3.33333333  4.44444444  5.55555556\n   6.66666667  7.77777778  8.88888889 10.        ]\n [ 0.          0.55555556  1.11111111  1.66666667  2.22222222  2.77777778\n   3.33333333  3.88888889  4.44444444  5.        ]]\n[ 0.          1.11111111  2.22222222  3.33333333  4.44444444  5.55555556\n  6.66666667  7.77777778  8.88888889 10.        ]\n[ 0.          1.11111111  2.22222222  3.33333333  4.44444444  5.55555556\n  6.66666667  7.77777778  8.88888889 10.          0.          0.55555556\n  1.11111111  1.66666667  2.22222222  2.77777778  3.33333333  3.88888889\n  4.44444444  5.        ]"
  },
  {
    "objectID": "chapters/numpy.html#commonly-used-array-methods-and-functions",
    "href": "chapters/numpy.html#commonly-used-array-methods-and-functions",
    "title": "9  The numpy module",
    "section": "9.7 Commonly-used Array Methods and Functions",
    "text": "9.7 Commonly-used Array Methods and Functions\nNumPy contains an extensive listing of array methods and functions and it would be impractical to list them all here. However, below you will find some tables of some of the commonly used ones that can serve as a reference.\n\nArray Attribute Methods and Functions\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\nshape(array) or array.shape\nReturns the dimensions of the array.\n\n\nndim(array) or array.ndim\nReturns the number of dimensions (i.e. a 2D array is \\(2\\)).\n\n\nsize(array) or array.size\nReturns the number of elements in an array.\n\n\n\n\nArray Modification Methods and Functions\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\narray.flatten()\nReturns a flattened view of array.\n\n\nreshape(array,dims) or array.reshape(dims)\nReturns a view of array reshaped into an array with dimensions given by dims.\n\n\narray.resize(dims)\nModifies array to be a resized array with dimensions dims.\n\n\ntranspose(array) or array.T\nReturns a view of the transpose of array.\n\n\nsort(array)\nReturns a view of a sorted version of array.\n\n\narray.sort()\nModifies array to be sorted.\n\n\nargsort(array)\nReturns index values that will sort array.\n\n\narray.fill(x)\nModifies array so that all elements are equal to x.\n\n\nvstack(a,b)\nVertically stack arrays a and b to form the new array.\n\n\nhstack(a,b)\nHorizontally stack arrays a and b to form the new array.\n\n\nvsplit(array,n)\nSplits array vertically into n equal parts.\n\n\nhsplit(array,n)\nSplits array horizontally into n equal parts.\n\n\nappend(array,x)\nReturns a view of array with x added to the end of the array.\n\n\ninsert(array,n,x)\nReturns a view of array with x inserted at location n.\n\n\ndelete(array,n)\nReturns a view of array with element at location n removed.\n\n\nunique(array)\nReturns a view of the unique elements of array.\n\n\n\n\nArray Measurement Methods and Functions\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\nmin(array) or array.min()\nReturns the minimum value in an array.\n\n\nmax(array) or array.max()\nReturns the maximum value in an array.\n\n\nargmin(array) or array.argmin()\nReturns the location of the minimum value in an array.\n\n\nargmax(array) or array.argmax()\nReturns the location of the maximum value in an array.\n\n\nfmin(array1,array2)\nReturns the minimum between two arrays of the same size. (Arrays are compared element wise.)\n\n\nfmax(array1,array2)\nReturns the maximum between two arrays of the same size. (Arrays are compared element wise.)\n\n\nmean(array) or array.mean()\nReturns the mean of array.\n\n\nmedian(array) or array.median()\nReturns the median of array.\n\n\nstd(array) or array.std()\nReturns the standard deviation of array.\n\n\ncumprod(array) or array.cumprod()\nReturns the cumulative product of array.\n\n\ncumsum(array) or array.cumsum()\nReturns the cumulative sum of array.\n\n\nsum(array) or array.sum()\nReturns the sum of all elements in array.\n\n\nprod(array) or array.prod()\nReturns the product of all elements in array.\n\n\nfloor(array)\nReturns the floor (i.e., rounds down) of all elements in array.\n\n\nceil(array)\nReturns the ceiling (i.e., rounds up) of all elements in array."
  },
  {
    "objectID": "chapters/numpy.html#flashcards-part-i",
    "href": "chapters/numpy.html#flashcards-part-i",
    "title": "9  The numpy module",
    "section": "9.8 Flashcards Part I",
    "text": "9.8 Flashcards Part I\n\nIn what ways are arrays “better” than lists? (better might be too strong.)\nHow do you create an array from a list?\nExplain the usage of the linspace function.\nExplain the usage of the arange function.\nExplain the usage of the zeros_like function.\nHow do you access a single element from a two-dimensional array?\nHow do you access multiple array elements at once in a one-dimensional array?\nHow do you access multiple array elements at once in a two-dimensional array?\nHow do you slice a two-dimensional array?\nWhat is boolean slicing? Given an example.\nWhat is broadcasting?\nWhat has President Nelson taught us about the meaning of the word Israel?"
  },
  {
    "objectID": "chapters/numpy.html#flashcards-part-ii",
    "href": "chapters/numpy.html#flashcards-part-ii",
    "title": "9  The numpy module",
    "section": "9.9 Flashcards Part II",
    "text": "9.9 Flashcards Part II\n\nHow can you determine the shape and size of an array?\nWhat does the reshape function do? Give an example to show the usage.\nWhat does the flatten function do? Give an example to show the usage.\nWhat does the transpose function do? Give an example to show the usage.\nWhat does the vstack function do? Give an example to show the usage.\nWhat does the hstack function do? Give an example to show the usage.\nWhat do the argmax and argmin functions do?\nWhat does the cumsum function do?\nHow many temples does the church have in operation currently?"
  },
  {
    "objectID": "chapters/numpy.html#exercises",
    "href": "chapters/numpy.html#exercises",
    "title": "9  The numpy module",
    "section": "9.10 Exercises",
    "text": "9.10 Exercises\n\nHere you will find a picture of the unit circle.\n\nUse the arange function to generate all of the angles (in degrees) on the unit circle displayed in blue or black text.\nUsing a single line of code, convert all of the angle from part 1 into radians.\nUse the linspace function to generate all of the angles (in degrees) on the unit circle displayed in red or black text.\nUsing a single line of code, convert all of the angle from part 3 into radians.\nUsing a single line of code, evaluate \\(\\sin()\\) onto both sets of angles and verify that they agree with the values on the unit circle.\nUsing a single line of code, evaluate \\(\\cos()\\) onto both sets of angles and verify that they agree with the values on the unit circle.\nUsing a single line of code, evaluate \\({\\sin(\\theta)\\over \\cos(\\theta)}\\) for all of the angles in your arrays. This should be equal to \\(\\tan(\\theta)\\)\n\n\n# Python code here\n\nIn the cell below you will find three arrays containing the masses, lengths, and radii for a collection of cylinders. The moment of inertia for each cylinder can be calculated as \\[ I = {1\\over 4} M R^2 + {1\\over 12} M L^2\\].\n\nUsing a single line of code, calculate the moment of inertia for all of the values in the arrays.\nDetermine the largest, smallest, and average of the calculated values.\n\n\nfrom numpy.random import uniform\nmass = uniform(3,8,1000)\nradius = uniform(0.5,1.2,1000)\nlength = uniform(0.8,3,1000)\n\nConstruct a two-dimensional array with the following entries: \\[\\begin{bmatrix}\n1& 5 & 7 & 2\\\\\n3& 9 & 1 & 4\\\\\n4& 2 & 2 & 8\\\\\n9& 1 & 6 & 3\\\\\n\\end{bmatrix}\\]\n\nNow access the number in the third column and second row. (It’s a \\(1\\))\nSlice the array from columns \\(2 \\rightarrow 4\\) and rows \\(1 \\rightarrow 3\\).\n\nThe following temperatures are prominent on the Fahrenheit scale: [0,32,100,212,451].\n\nCreate an array that contains these temperatures.\nUsing a single line of code, convert these temperatures into degrees Celsius using the following formula \\[T_C =  {5\\over 9}(T_F - 32)\\]\nUsing a single line of code, convert the temperatures from part 2 into Kelvins using the following formula \\[T_K = T_C + 273.15\\]\n\nUsing a single line of code, convert the temperatures from part 1 into Kelvins using the following formula \\[T_K = {5\\over 9} ( T_F - 32) + 273.15\\]\n\n\n# Python code here.\n\nThe equation below defines the relationship between energy (\\(E\\)) in Joules of a photon and its wavelength (\\(\\lambda\\)) in meters. The \\(h\\) is Plank’s constant (\\(6.626 \\times 10^{-34}\\) J \\(\\cdot\\) s) and \\(c\\) is the speed of light in a vacuum (\\(2.998 \\times 10^8\\) m/s). \\[E = {h c \\over \\lambda}\\]\n\nGenerate an array of wavelength values for visible light (\\(400\\) nm \\(\\rightarrow 800\\) nm) in \\(50\\) nm increments. (“nm” stands for nanometers or \\(10^{-9}\\) m)\nGenerate a second array containing the energy of each wavelength of light from part 1. Does the energy of a photon increase or decrease with wavelength?\n\n\n# Python code here\n\nA boat is out at sea with the following location and velocity vectors: \\[x_i =\n\\begin{bmatrix}\n5 \\\\\n2\n\\end{bmatrix} \\text{ km}\\] \\[v_i =\n\\begin{bmatrix}\n-13 \\\\\n25\n\\end{bmatrix}  \\text{ m/s}\\] when a gust of wind causes the boat to accelerate for approximately \\(3\\) minutes with the following acceleration vector:\\[a =\n\\begin{bmatrix}\n-8 \\\\\n-5\n\\end{bmatrix} \\text{ m/s}^2\\] We can find the position and velocity vectors of the boat after the wind has died back down with the following equation: \\[ \\vec{x_f} = \\vec{x_i} + \\vec{v_i} \\Delta t + {1\\over 2} \\vec{a} \\Delta t^2\\] \\[ \\vec{v_f} = \\vec{v_i} + \\vec{a} \\Delta t\\]\n\nCreate arrays containing the initial position, initial velocity, and acceleration of the boat in SI units.\nUsing a single line of code, calculate the final position of the boat. (Watch out: You must convert \\(3\\) minutes to seconds before performing the calculation.)\nUsing a single line of code, calculate the final velocity of the boat. (Watch out: You must convert \\(3\\) minutes to seconds before performing the calculation.)\n\nPredict the outcome of the following operations between two arrays. Then test your prediction.\n\\[\\begin{bmatrix}\n1&8&9\\\\\n8&1&9\\\\\n1&8&1\\\\\n\\end{bmatrix}+ \\begin{bmatrix}\n1&1\\\\\n1&1\\\\\n\\end{bmatrix} \\] \\[\n\\begin{bmatrix}\n1&1\\\\\n2&2\\\\\n\\end{bmatrix}\n+ \\begin{bmatrix}\n1\\\\\n\\end{bmatrix}\\] \\[\n\\begin{bmatrix}\n1&8&9\\\\\n8&1&9\\\\\n1&8&1\\\\\n\\end{bmatrix} +  \\begin{bmatrix}\n1\\\\\n2\\\\\n3\\\\\n\\end{bmatrix}\\] \\[\n\\begin{bmatrix}\n1&8&9\\\\\n8&1&9\\\\\n1&8&1\\\\\n\\end{bmatrix}\n+     \\begin{bmatrix}\n1&2&3\\\\\n\\end{bmatrix}\\]\n\n# Python code here\n\nIn quantum mechanics you will learn that the allowed energy levels for the harmonic oscillator are given by:\\[E_n = \\hbar \\sqrt{k \\over m} (n + {1\\over 2})\\] where \\(k = 4 \\pi^2\\) and \\(m = 1\\) gram.\n\nGenerate an array of \\(n\\) values from \\(1 \\rightarrow 10\\) (inclusive).\nUsing a single line of code, calculate the first 10 allowed energies for this harmonic oscillator. (Don’t forget to convert the mass to kg so everything is in SI units.)\nCombine these two arrays into a single \\(10\\) x \\(2\\) array with the first column containing \\(n\\) values and the second column containing the corresponding energies.\n\n\n# Python code here.\n\nGenerate an array containing integers \\(0 \\rightarrow 14\\) (inclusive)\n\nReshape the array to be a \\(3\\) x \\(5\\) array.\nTranspose the array from part 1 so that it is \\(5\\) x \\(3\\).\nMake the array from part 2 one-dimensional.\n\nThe \\(\\cos()\\) function can be written as an infinite sum: \\[ \\cos(x) = 1 - {x^2 \\over 2!} + {x^4 \\over 4!} - {x^6 \\over 6!} + \\dots = \\sum_{n = 0}^\\infty {(-1)^n x^{2n} \\over (2n)!}\\]. (As it turns out, any function can be written as a sum like this.)\n\nMake an array of integer \\(n\\) values from \\(0 \\rightarrow 100\\).\nUsing a single line of code, generate the terms in the sum for \\(x = \\pi\\). Note: scipy.special has a factorial function that will work on arrays.\n\nUse cumsum to evaluate the sum.\nInterpret the results and verify that as you include more terms in the sum the approximation to \\(\\cos(x)\\) gets better and better."
  },
  {
    "objectID": "chapters/io.html",
    "href": "chapters/io.html",
    "title": "10  File I/O (Input/Output)",
    "section": "",
    "text": "Jupyter Notebook\nUp to now, we have been working with computer-generated or manually typed data sets. Often in a scientific setting your data will be stored in a file and you will need to read the contents of the file into Python so you can perform an analysis. Most data files are text files, but there is a large variety of these that differ mostly in the way the information is formatted. The file extension (i.e., the 3 or 4 letters after the period at the end of a file name) specifies the formatting of the file. For example, a .csv file (short for comma-separated values) has commas to separate the information."
  },
  {
    "objectID": "chapters/io.html#the-os-module",
    "href": "chapters/io.html#the-os-module",
    "title": "10  File I/O (Input/Output)",
    "section": "10.1 The os module",
    "text": "10.1 The os module\nBefore we learn how to read and write data files, we should first learn how to navigate our computer’s file system from within Python. For this, we will use a module called os (short for operating system). The os module allows you to perform standard operations on the files and folders on your computer. When opening files from a python script, the default search path is the directory where the current file is located. If you want to open files located in other directories, you may need to use the os module to navigate there first. The following functions are the most commonly used ones\n\n\n\n\n\n\n\nFunction\nDescription\n\n\n\n\ngetcwd()\nShort for get current working directory. Returns a string of the current directory.\n\n\nchdir(path)\nChange the current working direction to be at path.\n\n\nlistdir()\nList all of the files and folders in the current working directory.\n\n\nmkdir(path)\nMake an new directory at location path.\n\n\n\nIn the cell below, we show the usage of these functions.\nfrom os import getcwd,chdir,listdir\n\ncurrentdir = getcwd()  \nmyfiles = listdir()\n#chdir(/path/to/new/directory)\n\nTo Do:\n\nAdd print statements to the cell above and inspect the results to understand what each function does.\nModify the third statement above (the one that uses chdir) to change the current working directory to one that actually exists on your machine.\nEveryone has a “Downloads” folder on their computer. Use the chdir function to change the current working directory to the Downloads folder.\n\n\nThe os module has many, many more functions that do useful things but you will mostly use the functions mentioned above. As you get more experience using your computer at the command line, you will be better equipped to understand the usefulness of the rest of this library."
  },
  {
    "objectID": "chapters/io.html#reading-files",
    "href": "chapters/io.html#reading-files",
    "title": "10  File I/O (Input/Output)",
    "section": "10.2 Reading Files",
    "text": "10.2 Reading Files\n\n10.2.1 Reading Line by Line\nThe first way to read a file is using a for loop to iterate over the file line by line. Admittedly, this is not the most elegant or efficient way to read a file but we present it first because it always works. First, the file is opened using the open command. The file should be attached to a variable for later use. Next, the data is read one line at a time using the readlines() method. We should use a for loop for this. Finally, it is a good idea to close the file when you’re finished. Let’s see an example for reading in the following file, which will be named squares.csv. (You can download squares.csv here if you want to execute the cells below without an error.)\n1, 1\n2, 4\n3, 9\n4, 16\n5, 25\n6, 36\n7, 49\n\nfile = open(\"squares.csv\")\nfor line in file.readlines():\n    print(line)\n\nfile.close()\n\n1,1\n\n2,4\n\n3,9\n\n4,16\n\n5,25\n\n6,36\n\n7,49\n\n8,64\n\n9,81\n\n10,100\n\n\nYou can see how each line gets read separately and printed off. But this isn’t super useful yet because we’d probably like to have the numbers stored in lists for our forthcoming analysis. We can fix this by creating some empty lists and appending the appropriate values as they are read in.\n\nnumbers = []\nsquares = []\n\nfile = open(\"squares.csv\")\nfor line in file.readlines():\n    numbers.append( int(line.split(',')[0]) )\n    squares.append( int(line.split(',')[1]) )\n\nfile.close()\n\nprint(numbers)\nprint(squares)\n\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n\n\nNow the data from the file is saved in Python lists and our analysis can proceed.\nOne final note: if all you want to do is read your file in as a list of strings (one string for each line), that can be done without a for loop using the readlines function (rather than readline).\n\nfile = open(\"squares.csv\")\ndata = file.readlines()\nfile.close()\n\nprint(data)\n\n['1,1\\n', '2,4\\n', '3,9\\n', '4,16\\n', '5,25\\n', '6,36\\n', '7,49\\n', '8,64\\n', '9,81\\n', '10,100']\n\n\n\n\n10.2.2 Using NumPy’s genfromtxt function\nIf the data file is highly structured (every line looks the same, separator character is consistent across the file, etc) then NumPy’s genfromtxt function can read the data very efficiently into an array. The genfromtxt function requires only one argument (the file name) with another optional argument (delimiter) that is typically included to specify the character used to separate the data. Below is an example for using this function to read in the .csv data we have been working with.\n\nfrom numpy import genfromtxt\n\ndata = genfromtxt('squares.csv',delimiter = \",\")\n\nprint(data)\n\n[[  1.   1.]\n [  2.   4.]\n [  3.   9.]\n [  4.  16.]\n [  5.  25.]\n [  6.  36.]\n [  7.  49.]\n [  8.  64.]\n [  9.  81.]\n [ 10. 100.]]\n\n\nNotice that the data was read into a NumPy array (2D in this case because there were two columns of data), which means that we can easily slice off the individual columns if needed.\n\nfrom numpy import genfromtxt\n\ndata = genfromtxt('squares.csv',delimiter = \",\")\n\nnumbers = data[:,0]\nsquares = data[:,1]\nprint(numbers)\nprint(squares)\n\n[ 1.  2.  3.  4.  5.  6.  7.  8.  9. 10.]\n[  1.   4.   9.  16.  25.  36.  49.  64.  81. 100.]\n\n\nOther optional arguments that can be used with the genfromtxt function are given in the table below:\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\ndelimiter\nThe string used to separate value. By default, whitespace acts as the delimiter.\n\n\nskip_header\nThe number of lines to skip at the beginning of a file.\n\n\nskip_footer\nThe number of lines to skip at the end of a file.\n\n\nusecols\nSpecify which columns to read with 0 being the first. For example, usecols = (0,2,5) will read the 1st, 3rd, and 6th columns.\n\n\ncomments\nThe character used to indicate the start of a comment. Lines beginning with this character will be discarded."
  },
  {
    "objectID": "chapters/io.html#writing-files",
    "href": "chapters/io.html#writing-files",
    "title": "10  File I/O (Input/Output)",
    "section": "10.3 Writing Files",
    "text": "10.3 Writing Files\nWriting Python data to file is as simple as is reading a file. Just like when you are reading a file, determining which method to use will be determined by the type of data that you are writing. If your data is strictly numerical information stored in an array, Numpy has a function that will quickly save the data to a file. If your data is rife with inconsistencies, non-numerical data, etc, you’ll have to use Python’s native write function.\n\n10.3.1 Writing Line by Line\nSometimes the data file that you want to write includes some text or other non-numerical data. For example, what if you wanted to write the following data to file:\n\n\n\nPlanet\nAcceleration due to gravity (m/s\\(^2\\)\n\n\n\n\nEarth\n9.8\n\n\nMoon\n1.6\n\n\nMars\n3.7\n\n\nVenus\n8.83\n\n\nSaturn\n11.2\n\n\nUranus\n10.5\n\n\nNeptune\n13.3\n\n\nPluto\n0.61\n\n\nJupiter\n24.5\n\n\nSun\n275\n\n\n\nIn this case you must open the file you want to write through and write each line of the file one by one. This requires that you use a loop to iterate over the data. An example is given below.\nplanets = [\"Earth\",\"Moon\",\"Mars\",\"Venus\",\"Saturn\",\"Uranus\",\"Neptune\",\"Pluto\",\"Jupiter\",\"Sun\"]\ng=[9.8,1.6,3.7,8.83,11.2,10.5,13.3,0.61,24.5,275]\n\nf= open(\"planets.txt\",\"w\")\n\nf.write(\"Planet   g (m/s^2)\\n\")\nf.write(\"------------------\\n\")\n\nfor idx,planet in enumerate(planets):\n    f.write(f\"{planet:10s}  {g[idx]:5.2f} \\n\" )\n\nf.close()"
  },
  {
    "objectID": "chapters/io.html#the-with-statement",
    "href": "chapters/io.html#the-with-statement",
    "title": "10  File I/O (Input/Output)",
    "section": "10.4 The with statement",
    "text": "10.4 The with statement\nForgetting to close a file that you are writing to can be problematic so you should always include the close() function when you are done. If you are worried about forgetting it, you can use a with block that will automatically close the file once the block terminates. An example is given below:\nplanets = [\"Earth\",\"Moon\",\"Mars\",\"Venus\",\"Saturn\",\"Uranus\",\"Neptune\",\"Pluto\",\"Jupiter\",\"Sun\"]\ng=[9.8,1.6,3.7,8.83,11.2,10.5,13.3,0.61,24.5,275]\n\nwith open(\"planets.txt\",\"w\") as f:\n    f.write(\"Planet   g (m/s^2)\\n\")\n    f.write(\"------------------\\n\")\n\n    for idx,planet in enumerate(planets):\n        f.write(f\"{planet:10s}  {g[idx]:5.2f} \\n\" )\nEven though no close() function is called, the file planets.txt will be automatically closed once the with block is terminated.\n\n10.4.1 Using NumPy’s savetxt function\nIf the data is strictly numerical and contains no text, the savetxt function is a fast and efficient way to write the data to file. For example, maybe you have a two dimensional array containing various columns of planetary data.\n\n\n\n\n\n\n\n\nRadius ( \\(\\times 10^{6}\\) meters )\nMass ( \\(\\times 10^{23}\\) kg )\nAcceleration due to gravity (m/s\\(^2\\))\n\n\n\n\n6.37\n59.8\n9.8\n\n\n1.74\n0.736\n1.6\n\n\n3.38\n6.42\n3.7\n\n\n6.07\n48.8\n8.83\n\n\n58.2\n5680\n11.2\n\n\n23.5\n868\n10.5\n\n\n22.7\n1030\n13.3\n\n\n1.15\n0.131\n0.61\n\n\n69.8\n19000\n24.5\n\n\n696\n19890000\n275\n\n\n\nfrom numpy import savetxt\n\ndata =[[6.37,59.8,9.8],[1.74,0.736,1.6],[3.38,6.42,3.7],[6.07,48.8,8.83],[58.2,5680,11.2],[23.5,868,10.5],[22.7,1030,13.3],[1.15,.131,0.61],[69.8,19000,24.5],[696,19890000,275]]\n\nsavetxt(\"planetsData.txt\",data,fmt = \"%5.2e\")\nThe fmt keyword argument can be be added to specify how to format the data. If the data is stored in separate one-dimensional arrays, you can pack them into a single list(tuple) when using the savetxt function and it will write each data set to it’s own line in the file.\nradius = [6.37,1.74,3.38,6.07,58.2,23.5,22.7,1.15,69.8,696]\nmass = [59.8,0.736,6.42,48.8,5680,868,1030,0.131,19000,19890000]\ng = [9.8,1.6,3.7,8.83,11.2,10.5,13.3,0.61,24.5,275]\n\nsavetxt(\"planetsDataTwo.txt\",(radius,mass,g),fmt = \"%5.2e\")\nOther optional arguments that can be used with the savetxt function are given in the table below:\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\ndelimiter\nString or character to separate columns.\n\n\nnewline\nString or character to separate lines.\n\n\nheader\nString to be written at the beginning of the file.\n\n\nfooter\nString to be written at the end of the file.\n\n\ncomments\nString that will be prepended to the header and footer string to mark them as comments."
  },
  {
    "objectID": "chapters/io.html#flashcards",
    "href": "chapters/io.html#flashcards",
    "title": "10  File I/O (Input/Output)",
    "section": "10.5 Flashcards",
    "text": "10.5 Flashcards\n\nWhat does os.getcwd() do?\nWhat does os.chdir() do?\nWhat does os.mkdir() do?\nWhat does os.listdir() do?\nHow do you open a file and read all of the lines in that file using readline()?\nHow do you open a file and read all of the lines in that file using numpy.genfromtxt()?\nWhat is the delimiter keyword argument used for when reading a file with numpy.genfromtxt()?\nHow do you open and write to a file using the write function?\nHow do you write to a file using numpy.savetxt?\nWhere are the sacrament prayers located? (They are found in more than one location)"
  },
  {
    "objectID": "chapters/io.html#exercises",
    "href": "chapters/io.html#exercises",
    "title": "10  File I/O (Input/Output)",
    "section": "10.6 Exercises",
    "text": "10.6 Exercises\n\nUse all of the functions from the os library that we mentioned in the text. I’ll let you choose where to change your directory to and the name of the directory to create. I just want you to use all of them until you feel comfortable.\n\n# Python code here\n\nIn a previous homework problem you calculated the moments of inertia for a data set. In the cell below, you will find arrays containing 1000 values for for mass, length, and radius just as you did in the other homework problem.\n\nUsing a single line of code, calculate the moments of inertia for the entire data set using the familiar formula: \\[ I = {1\\over 4} M R^2 + {1\\over 12} M L^2\\]\nWrite this data to file first using the open and write functions. Mass values should be in column 1, lengths in column 2, radii in column 3, and moments of inertia in column 4. Add a header to the file to label the columns. Open the file and inspect it to verify that you did it right.\nRepeat exercise 2 but using the numpy.savetxt function. Open the file and inspect it to verify that you did it right.\n\n\nfrom numpy.random import normal\n\nmass = normal(5,.5,1000)\nlength = normal(2,.2,1000)\nradius = normal(1,.1,1000)\n\nThis file contains planetary data for all of the planets in our solar system formatted as a “.csv” file.\n\nDownload the file and move it to a location on your computer that you are familiar with.\nRead the file using the open and readlines functions.\nRepeat exercise 2 using numpy.genfromtxt().\nUsing a single line of code, calculate the average eccentricity of the planets.\nUsing a single line of code each, determine the maximum and minium acceleration due to gravity of the planets.\n\nTip: You’ll need to use the skip_header and usecols keyword arguments to tell genfromtxt to skip the first row and column.\n\n# Python code here\n\nThis file contains the output from a quantum mechanical calculation on a Cobalt-based alloy. The file is pretty large and the data is not well-structured at all even though there is valuable information inside. Reading this file is definitely a job for open and readlines rather than numpy.genfromtxt(). Periodically in this file there are lines that look like this:\nfree energy     TOTEN =             -72.3092 eV\nand you need to extract the numbers from all of these lines. Use the following steps to build a list containing these numbers:\n\nUse the open and readlines functions to read this file into a list of strings.\nIterate over this list and look for lines that contain the string “TOTEN”.\nWhen you find a line that has this string in it, split the string and extract the number. Make sure you convert the number into a float.\nAppend this number to a list that you defined initially to be empty.\n\nWhen you have built the list of energies, determine:\n\nThe number of energies in your list.\nThe average of the last 5 entries.\nThe minimum and maximum energies in your list.\n\n\n# Python code here"
  },
  {
    "objectID": "chapters/basicPlotting.html",
    "href": "chapters/basicPlotting.html",
    "title": "11  Basic Plotting",
    "section": "",
    "text": "Jupyter Notebook\nCreating plots is an important task in science and engineering. The old adage “A picture is worth a thousand words!” is wrong…. it’s worth way more than that if you do it right. When making plots of functions on a computer it is important to remember that computers don’t plot functions, rather they plot individual points. Only when you connect those points does the image look like the function you are used to seeing. In this chapter we will use a library called matplotlib for plotting. More specifically, we will import the pyplot function inside of matplotlib. It is customary to use plt as an alias for pyplot.\nThe %matplotlib inline statement is a Jupyter notebook command. It tells Jupyter to display any plots generated directly in the notebook instead of in a separate window. If you use matplotlib in another environment, you should remove this line and instead place plt.show() af the plot commands."
  },
  {
    "objectID": "chapters/basicPlotting.html#plotting-functions-of-a-single-variable",
    "href": "chapters/basicPlotting.html#plotting-functions-of-a-single-variable",
    "title": "11  Basic Plotting",
    "section": "11.1 Plotting Functions of a Single Variable",
    "text": "11.1 Plotting Functions of a Single Variable\nIn order to make a plot, matplotlib needs lists of the x and y coordinates for the points that are going to be plotted. If you want to plot a function, the list of x coordinates should be chosen to be a dense array of points spanning the function’s domain and the list of y coordinates should be the function values at those points. A good choice for generating the x-coordinates is either linspace or arange from NumPy. Let’s consider an example. The function shown below is called the Lennard-Jones equation and it gives the energy of two atoms interacting as a function of separation distance\n\\[ E = 4\\sigma\\left[ \\left({\\epsilon\\over r} \\right)^{12} - \\left({\\epsilon\\over r} \\right)^{6}\\right]\\]\nLet’s plot this function from \\(0.9\\) to \\(4.0\\).\n\nfrom matplotlib import pyplot as plt\n%matplotlib inline\nfrom numpy import linspace,sqrt\n\nsigma = 1\nepsilon = 1\nr = linspace(0.9,4,20)\nenergy = 4 * sigma* ((epsilon/r)**12 - (epsilon/r)**6)\n\nplt.figure()\nplt.plot(r,energy)\n\n\n\n\n\nTo Do:\n\nYou may have noticed that the plot doesn’t appear very smooth. Think about what modifications you might make so that the plot is smoother.\nRun the code to verify that you did it correct.\n\n\n\n11.1.1 Linestyles, Markers, and Colors\nThree optional arguments can help you control the look of the plot: marker, linestyle, and color. All of these arguments take strings. The linestyle argument determines if the line is solid or dashed and what type of dashing to use. The marker argument specifies the shape of the plot marker to be used. Below are tables listing possible options for these arguments.\n\nCommon Marker Styles\n\n\nArgument\nDescription\n\n\n\n\no\ncircle\n\n\n*\nstar\n\n\np\npentagon\n\n\n^\ntriangle\n\n\ns\nsquare\n\n\n\n\nCommon Line Styles\n\n\nArgument\nDescription\n\n\n\n\n-\nsolid\n\n\n--\ndashed\n\n\n-.\ndash-dot\n\n\n:\ndotted\n\n\n\n\nCommon Colors\n\n\nArgument\nDescription\n\n\n\n\nb\nblue\n\n\nr\nred\n\n\nk\nblack\n\n\ng\ngreen\n\n\nm\nmagenta\n\n\nc\ncyan\n\n\ny\nyellow\n\n\n\nSeveral other keyword arguments exist for helping you customize the look of your plots. They are summarized in the table below.\n\nA Few Common plot keyword arguments\n\n\nArgument\nDescription\n\n\n\n\nlinestyle or ls\nline style\n\n\nmarker\nmarker shape\n\n\nlinewidth or lw\nline width\n\n\ncolor or c\nline color\n\n\nmarkersize or ms\nmarker size\n\n\n\nHere is the plot from above with some of these keyword arguments added.\n\nfrom matplotlib import pyplot as plt\n%matplotlib inline\nfrom numpy import linspace,sqrt\n\nr = linspace(0.9,4,50)\nenergy = 4 * ((1/r)**12 - (1/r)**6)\n\nplt.figure()\nplt.plot(r,energy,linestyle = '-', marker = 'o', color = 'r')\n\n\n\n\n\n\n11.1.2 Labeling Plots\nAll good plots have axes labels and a title and you can add them to a matplotlib plot using the xlabel(), ylabel(), and title() functions which are placed on their own line after the plot command.\n\nfrom matplotlib import pyplot as plt\n%matplotlib inline\nfrom numpy import linspace,sqrt\n\nr = linspace(0.9,4,50)\nenergy = 4 * ((1/r)**12 - (1/r)**6)\n\nplt.figure()\nplt.plot(r,energy,marker = 'o')\nplt.xlabel(\"Separation Distance\")\nplt.ylabel(\"Energy\")\nplt.title(\"Lennard-Jones Potential\")\n\nText(0.5, 1.0, 'Lennard-Jones Potential')\n\n\n\n\n\n\n\n11.1.3 Greek Letters\nIn physics, Greek letters get used all the time and you may find yourself wanting to use one in a plot title or axes label. This can be accomplished by placing an r in front of the title string and then placing the name of the greek variable inside of $ with a backslash in front of it. This is better illustrated with an example.\n\nfrom matplotlib import pyplot as plt\n%matplotlib inline\nfrom numpy import linspace,sqrt\n\nr = linspace(0.9,4,50)\nenergy = 4 * ((1/r)**12 - (1/r)**6)\n\nplt.figure()\nplt.plot(r,energy,marker = 'o')\nplt.xlabel(\"Separation Distance\")\nplt.ylabel(\"Energy\")\nplt.title(r\"Lennard-Jones Potential ($\\theta$)\")\n\nText(0.5, 1.0, 'Lennard-Jones Potential ($\\\\theta$)')\n\n\n\n\n\nYou can subscript any character using the _ character followed by the subscript. \\(\\theta_1\\) can be written as \\theta_1. If the subscript is more than one character, you’ll need to enclose it in curly braces. \\(\\theta_{12}\\) is written as \\theta_{12}. Superscripts work the same way only using the ^ character instead of the underscore.\n\nLowercase greek letters\n\n\nArgument\nDescription\n\n\n\n\n\\(\\alpha\\)\n\\alpha\n\n\n\\(\\beta\\)\n\\beta\n\n\n\\(\\gamma\\)\n\\gamma\n\n\n\\(\\delta\\)\n\\delta\n\n\n\\(\\epsilon\\)\n\\epsilon\n\n\n\\(\\phi\\)\n\\phi\n\n\n\\(\\theta\\)\n\\theta\n\n\n\\(\\kappa\\)\n\\kappa\n\n\n\\(\\lambda\\)\n\\lambda\n\n\n\\(\\mu\\)\n\\mu\n\n\n\\(\\nu\\)\n\\nu\n\n\n\\(\\pi\\)\n\\pi\n\n\n\\(\\rho\\)\n\\rho\n\n\n\\(\\sigma\\)\n\\sigma\n\n\n\\(\\tau\\)\n\\tau\n\n\n\\(\\xi\\)\n\\xi\n\n\n\\(\\zeta\\)\n\\zeta\n\n\n\n\n\n11.1.4 Controlling the Axes\nBy default, matplotlib will size the plot window to include all of the points. If you want to zoom in our out, you can do so with the xlim and ylim functions. These functions should be placed after the plot command on their own line just like the label commands.\n\nfrom matplotlib import pyplot as plt\n%matplotlib inline\nfrom numpy import linspace,sqrt\n\nr = linspace(0.9,4,50)\nenergy = 4 * ((1/r)**12 - (1/r)**6)\n\nplt.figure()\nplt.plot(r,energy,marker = 'o')\nplt.xlim(0.5,3)\nplt.ylim(-1.25,5)\nplt.xlabel(\"Separation Distance\")\nplt.ylabel(\"Energy\")\nplt.title(\"Lennard-Jones Potential\")\n\nText(0.5, 1.0, 'Lennard-Jones Potential')\n\n\n\n\n\n\n\n11.1.5 Overlaying Plots\nOften you will want to plot more than one set of data on the same set of axes. This can be accomplished two ways. The first way is to call the plot function twice in the same Jupyter notebook cell. Matplotlib will automatically place the plots on the same figure and scale it appropriately. Below you will find a plot of the Lennard-Jones potential for two choices of the parameters \\(\\sigma\\) and \\(\\epsilon\\).\n\nfrom matplotlib import pyplot as plt\n%matplotlib inline\nfrom numpy import linspace,sqrt\n\nr = linspace(0.9,4,50)\n\nsigmaOne = 1\nepsilonOne = 1\nsigmaTwo = 2\nepsilonTwo = 2\nenergyOne = 4 * sigmaOne* ((epsilonOne/r)**12 - (epsilonOne/r)**6)\nenergyTwo = 4 * sigmaTwo * ((epsilonTwo/r)**12 - (epsilonTwo/r)**6)\n\nplt.figure()\nplt.plot(r,energyOne,marker = 'o')\nplt.plot(r,energyTwo,marker = '+')\nplt.xlim(0.5,3.5)\nplt.ylim(-2,5)\nplt.xlabel(\"Separation Distance\")\nplt.ylabel(\"Energy\")\nplt.title(\"Lennard-Jones Potential\")\n\nText(0.5, 1.0, 'Lennard-Jones Potential')\n\n\n\n\n\nThe other way to overlay plots is to include both sets of data into a single plot command.\n\nfrom matplotlib import pyplot as plt\n%matplotlib inline\nfrom numpy import linspace,sqrt\n\nr = linspace(0.9,4,50)\n\nsigmaOne = 1\nepsilonOne = 1\nsigmaTwo = 2\nepsilonTwo = 2\nenergyOne = 4 * sigmaOne* ((epsilonOne/r)**12 - (epsilonOne/r)**6)\nenergyTwo = 4 * sigmaTwo * ((epsilonTwo/r)**12 - (epsilonTwo/r)**6)\n\nplt.figure()\nplt.plot(r,energyOne,r,energyTwo,marker = 'o')\nplt.xlim(0.5,3.5)\nplt.ylim(-2,5)\nplt.xlabel(\"Separation Distance\")\nplt.ylabel(\"Energy\")\nplt.title(\"Lennard-Jones Potential\")\n\nText(0.5, 1.0, 'Lennard-Jones Potential')\n\n\n\n\n\n\n\n11.1.6 Plot Legends\nOften when your figure contains more than one plot, it is helpful to include a plot legend to label the plots. To add a legend, you must first use the keyword argument label to each plot command to specify each plot’s label. To add the legend, use the command pyplot.ledend(). An example is given below:\n\nfrom matplotlib import pyplot as plt\n%matplotlib inline\nfrom numpy import linspace,sqrt\n\nr = linspace(0.9,4,50)\n\nsigmaOne = 1\nepsilonOne = 1\nsigmaTwo = 2\nepsilonTwo = 2\nenergyOne = 4 * sigmaOne* ((epsilonOne/r)**12 - (epsilonOne/r)**6)\nenergyTwo = 4 * sigmaTwo * ((epsilonTwo/r)**12 - (epsilonTwo/r)**6)\n\nplt.figure()\nplt.plot(r,energyOne,marker = 'o',label = \"plot1\")\nplt.plot(r,energyTwo,marker = 'x',label = \"plot2\")\nplt.xlim(0.5,3.5)\nplt.ylim(-2,5)\nplt.xlabel(\"Separation Distance\")\nplt.ylabel(\"Energy\")\nplt.title(\"Lennard-Jones Potential\")\nplt.legend()\n\n<matplotlib.legend.Legend at 0x11d0dc890>"
  },
  {
    "objectID": "chapters/basicPlotting.html#other-plot-types",
    "href": "chapters/basicPlotting.html#other-plot-types",
    "title": "11  Basic Plotting",
    "section": "11.2 Other Plot Types",
    "text": "11.2 Other Plot Types\nBeyond the line plot that we learned about in the previous section, matplotlib can generate many other types of plots that are very useful in a scientific setting. We’ll explore some of them here.\n\n11.2.1 Logarithmic Plots\nSometimes the function being plotted increases or decreases by many orders of magnitude and a normal linear plot would not be particularly useful. Logarithmic plots can be made with the use of the semilogx, semilogy, or loglog functions depending on which axes you want to be on a logarithmic scale. Consider the first plot produced below. Notice that it rises from \\(0\\) at \\(x = 0\\) to \\(10^{45}\\) at \\(x = 100\\). Plotting this function with the y-axis scaled logarithmically will smooth out the plot and make it easier to analyze.\n\nfrom matplotlib import pyplot as plt\n%matplotlib inline\nfrom numpy import linspace,exp\n\nx = linspace(0,100,200)\ny = exp(x)\n\nplt.figure()\nplt.plot(x,y)\nplt.figure() \nplt.semilogy(x,y)\n\n\n\n\n\n\n\n\n\n11.2.2 Bar Plots\nA bar plot and a scatter plot are quite similar except that instead of a plot marker indicating the associated value, the height of the bar represents the value. You can make a bar plot using the bar function inside of pyplot.\n\nfrom matplotlib import pyplot as plt\n%matplotlib inline\nfrom numpy import linspace,sqrt\n\n#d = [5.8e10,1.9e11,1.5e11,2.3e11,7.8e11,1.4e12,2.9e12,4.5e12]\nd = [1,2,3,4,5,6,7,8]\nT = [0.241,0.615,1,1.88,11.9,29.5,84,165]\n\nplt.figure()\nplt.bar(d,T,tick_label = [\"Mercury\",\"Venus\",\"Earth\",\"Mars\",\"Jupyter\",\"Saturn\",\"Uranus\",\"Neptune\"])\nplt.xlabel(\"Planet Name\")\nplt.ylabel(\"Length of day (in earth days)\")\nplt.title(\"Length of day for planets in our solar system\")\n\nText(0.5, 1.0, 'Length of day for planets in our solar system')\n\n\n\n\n\nNotice the optional argument tick_labels used to add labels to the bars. If that were left off, the bars would be labeled using the numbers supplied. Other optional arguments that are available for the bar command are given below.\n\nA Few Common bar keyword arguments\n\n\nArgument\nDescription\n\n\n\n\nwidth\nbar width\n\n\ncolor\nbar color\n\n\nxerr\nX error bar\n\n\nyerr\nY error bar\n\n\ncapsize\nsize of caps on error bars\n\n\n\n\n\n11.2.3 Errorbar Plots\nTo make plots with error bars use matplotlilb’s errorbar function. You can choose to add error bars on the x or y axis using the keyword arguments xerr and yerr.\n\nfrom matplotlib import pyplot as plt\n\nfrom numpy import arange\n\nx = arange(0,8,0.5)\ny = x**2\n\nx_err = 0.05 # Same error for all points\ny_error = 2 # Different error for each point\n\nplt.errorbar(x,y,linestyle = '-.', marker = 'o',markersize = 3,yerr=y_error,capsize = 5)\n\n<ErrorbarContainer object of 3 artists>\n\n\n\n\n\nThe linestyle, marker, and markersize arguments work with this plot type also.\n\n\n11.2.4 Scatter Plots\nWe have already generated scatter plots using the plot function but you can also use the scatter command to do the same thing. The only other additional functionality with scatter is the ability to specify the color, shape, and size of each plot marker individually.\n\nfrom matplotlib import pyplot as plt\n%matplotlib inline\nfrom numpy import linspace,log\n\nd = [5.8e10,1.9e11,1.5e11,2.3e11,7.8e11,1.4e12,2.9e12,4.5e12]\n#d = [1,2,3,4,5,6,7,8]\nT = [0.241,0.615,1,1.88,11.9,29.5,84,165]\nmass = [3.2e23,4.9e24,6e24,6.4e23,1.9e27,5.7e26,8.7e25,1e26]\n\nplt.figure()\nplt.scatter(d,T,c = mass,s= 50)\nplt.xlabel(\"Orbital Distance from Sun\")\nplt.ylabel(\"Length of day (in earth days)\")\nplt.title(\"Length of day for planets in our solar system (color indicates mass)\")\nplt.colorbar()\n\n<matplotlib.colorbar.Colorbar at 0x11d2c3910>\n\n\n\n\n\n\n\n11.2.5 Histograms\nHistograms display bars representing the frequency of values in a given data set. Unlike bar plots, the width of the bar is meaningful since the each bar represents the number of x-values that fall within a range given by the width of the bar. A histogram can be constructed using the hist function. There is only one required argument, which is the data set. Some commonly used keyword arguments are bins which specifies how many equally-spaced groups (called bins) to generate and edgecolor which can be used to specify the color of the bar’s edges.\n\nfrom matplotlib import pyplot as plt\n%matplotlib inline\nfrom numpy import linspace,log\n\ndensities = [0.00009,0.000178,0.00125,0.001251,0.001293,0.001977,0.534,0.810,0.900,0.920,0.998,1.000,1.03,1.03,1.25,1.600,1.7,2.6,2.7,3.5,5.515,7.8,7.8,8.6,8.5,11.3,13,13.6,18.7,19.3,21.4,22.4,22.6]\n\nplt.figure()\nplt.hist(densities,bins = 5,edgecolor = 'r')\nplt.xlabel(\"Material Densities\")\nplt.title(r\"Histogram of Material Densities (g/cm$^3$)\")\n\nText(0.5, 1.0, 'Histogram of Material Densities (g/cm$^3$)')\n\n\n\n\n\nHere we have used bins = 5 which will produce a histogram with \\(5\\) equal-size bins. Alternatively, we can specify the exact locations of all the bin edges by placing them in a list.\n\nfrom matplotlib import pyplot as plt\n%matplotlib inline\nfrom numpy import linspace,log\n\ndensities = [0.00009,0.000178,0.00125,0.001251,0.001293,0.001977,0.534,0.810,0.900,0.920,0.998,1.000,1.03,1.03,1.25,1.600,1.7,2.6,2.7,3.5,5.515,7.8,7.8,8.6,8.5,11.3,13,13.6,18.7,19.3,21.4,22.4,22.6]\n\nplt.figure()\nplt.hist(densities,bins = [0,2.5,5,7.5,10,12.5,15,17.5,20,22.5],edgecolor = 'r')\nplt.xlabel(\"Material Densities\")\nplt.title(r\"Histogram of Material Densities (g/cm$^3$)\")\n\nText(0.5, 1.0, 'Histogram of Material Densities (g/cm$^3$)')\n\n\n\n\n\n\n\n11.2.6 Polar Plots\nIn a polar plot instead of providing \\((x,y)\\) coordinates, you provide \\((r,\\theta)\\) coordinates, where \\(r\\) is the radial distance from the origin and \\(\\theta\\) is the angular location on the unit circle.\n\nfrom matplotlib import pyplot as plt\n%matplotlib inline\nfrom numpy import linspace,pi,sin\n\ntheta = linspace(0,4 * pi,150)\nr = sin(2* theta)\n\nplt.figure()\nplt.polar(theta,r)"
  },
  {
    "objectID": "chapters/basicPlotting.html#multifigure-plots",
    "href": "chapters/basicPlotting.html#multifigure-plots",
    "title": "11  Basic Plotting",
    "section": "11.3 Multifigure Plots",
    "text": "11.3 Multifigure Plots\nTo generate multiple, independent plots in the same figure a few more lines of code are necessary to specify how you want the plots arranged. We start with the figure function which generates the canvas upon which the plots will appear. Assign this object to a variable so you can refer to it later. To create each subplot, the fig.add_subplot(rows,columns, plot_number) function is used. There are three arguments to this function; the first two indicate the shape of the grid and the third indicates which position on the grid this plot will be assigned.\nfig.add_subplot(rows,columns,plot_location)\nAfter the axes object has been created, we can call the plot function again, and a plot will be generated at its location. Here is an example that will generate two plots side by side.\n\nfrom matplotlib import pyplot as plt\n%matplotlib inline\nfrom numpy import linspace,sqrt\n\nr = linspace(0.9,4,50)\n\nsigmaOne = 1\nepsilonOne = 1\nsigmaTwo = 2\nepsilonTwo = 2\nenergyOne = 4 * sigmaOne* ((epsilonOne/r)**12 - (epsilonOne/r)**6)\nenergyTwo = 4 * sigmaTwo * ((epsilonTwo/r)**12 - (epsilonTwo/r)**6)\n\nfig = plt.figure()\nax1 = fig.add_subplot(1,2,1)\nax2 = fig.add_subplot(1,2,2)\n\nax1.plot(r,energyOne,marker = '+',color = 'k')\nax1.set_xlim(0.5,3.0)\nax1.set_ylim(-1.5,5)\nax1.set_xlabel(\"Separation Distance\")\nax1.set_ylabel(\"Energy\")\nax1.set_title(\"Lennard-Jones Potential\")\n\nax2.plot(r,energyTwo,marker = 'o',color = 'r')\nax2.set_xlim(0.5,4.0)\nax2.set_ylim(-2,5)\nax2.set_xlabel(\"Separation Distance\")\nax2.set_ylabel(\"Energy\")\nax2.set_title(\"Lennard-Jones Potential\")\n\nText(0.5, 1.0, 'Lennard-Jones Potential')\n\n\n\n\n\nPay close attention to the add_subplot function. ax1=add_subplot(1,2,1) will generate a \\(1\\) x \\(2\\) grid of plots and ax1 will correspond plot at the 1st location. Below is an example of a more advanced array of plots. Pay close attention to the add_subplot functions until you understand.\n\nfrom matplotlib import pyplot as plt\n%matplotlib inline\nfrom numpy import linspace,sqrt\n\nr = linspace(0.9,4,50)\n\nsigmaOne = 1\nepsilonOne = 1\nsigmaTwo = 2\nepsilonTwo = 2\nenergyOne = 4 * sigmaOne* ((epsilonOne/r)**12 - (epsilonOne/r)**6)\nenergyTwo = 4 * sigmaTwo * ((epsilonTwo/r)**12 - (epsilonTwo/r)**6)\n\nfig = plt.figure()\nax1 = fig.add_subplot(2,1,1)\nax2= fig.add_subplot(2,2,3)\nax3 = fig.add_subplot(2,2,4)\n\nax1.plot(r,energyOne,marker = '+',color = 'k')\nax1.set_xlim(0.5,3.0)\nax1.set_ylim(-1.5,5)\nax1.set_xlabel(\"Separation Distance\")\nax1.set_ylabel(\"Energy\")\nax1.set_title(\"Lennard-Jones Potential\")\n\nax2.plot(r,energyTwo,marker = 'o',color = 'r')\nax2.set_xlim(0.5,4.0)\nax2.set_ylim(-2,5)\nax2.set_xlabel(\"Separation Distance\")\nax2.set_ylabel(\"Energy\")\nax2.set_title(\"Lennard-Jones Potential\")\n\nax3.plot(r,energyTwo,marker = 'o',color = 'r')\nax3.set_xlim(0.5,4.0)\nax3.set_ylim(-2,5)\nax3.set_xlabel(\"Separation Distance\")\nax3.set_ylabel(\"Energy\")\nax3.set_title(\"Lennard-Jones Potential\")\nplt.tight_layout()\n\n\n\n\nAlso notice the set_xlim, set_ylim, set_xlabel etc methods that were used to customize each individual plot. There are a host of other methods available for further customization. This website has a comprehensive list of them."
  },
  {
    "objectID": "chapters/basicPlotting.html#flashcards",
    "href": "chapters/basicPlotting.html#flashcards",
    "title": "11  Basic Plotting",
    "section": "11.4 Flashcards",
    "text": "11.4 Flashcards\n\nDescribe how to make a simple, no frills plot of a function. Give a short example.\nHow do you modify your plot style to be a red dashed line with triangle markers?\nWhat is the ms keyword argument used for when plotting?\nHow do you add axes labels to a plot?\nHow do you add a title to a plot?\nHow do you insert greek letters into a plot title or axes label?\nHow do you control the size of the plot window (i.e. zoom in or out.)\nHow do you plot multiple plots on the same figure?\nList the other types of plots discussed in this chapter.\nHow do you make multi-figure plot? Give an example showing the functions that should be used.\nWhere can you find the account of Abinadi?"
  },
  {
    "objectID": "chapters/basicPlotting.html#exercises",
    "href": "chapters/basicPlotting.html#exercises",
    "title": "11  Basic Plotting",
    "section": "11.5 Exercises",
    "text": "11.5 Exercises\n\nIf you were to shine a laser through a very narrow slit, you would see a pattern very similar to the one shown below. The function that describes this light pattern is called a sinc function:\\[ y(x) = \\left({\\sin x\\over x}\\right)^2\\]\n\nPlot this function from \\(-20 < x < 20\\). Then make the following customizations to the plots:\n\nSet the color of the line to be green.\nAdd axes labels to the plot. The x-label should be “Location” and the y-label should by “Intensity”.\nAdd the following title to the plot: “Single-Slit diffraction pattern”\n\n\n# python code here\n\nMax Planck discovered that all objects emit a spectrum of light and the intensity of that spectrum is given by the following function (we did this in a previous homework problem) \\[ I(\\lambda) = {2 \\pi h c^2 \\over \\lambda^5} {1\\over e^{hc \\over \\lambda k_BT} - 1}\\] where\n\n\\(c = 3.0 \\times 10^8\\) m/s is the speed of light.\n\\(h = 6.26 \\times 10^{-34}\\) m\\(^2\\) kg /s is Plank’s constant.\n\\(k_B = 1.38 \\times 10^{-23}\\) m\\(^2\\)kg s\\(^{-2}\\) K\\(^{-1}\\) is the Boltzmann constant.\nT is temperature in Kelvins.\n\\(\\lambda\\) is wavelength in meters.\n\nFollow the steps below to plot this function for several different temperatures:\n\nCopy the function that you made previously into the cell below. (or build it from scratch)\nUse numpy.linspace to generate a grid of 500 \\(\\lambda\\) values from \\(0.1 \\times 10^{-6} \\rightarrow 3 \\times 10^{-6}\\) m.\nCall your vectorized function for \\(T = 5780\\) K (temperature of the sun), producing a list of intensities.\nPlot intensity vs. \\(\\lambda\\) .\n\nRepeat steps 4 and 5 for \\(T = 4500\\) K. You should have two plots on the same figure. Choose the line style and color to be different than the first plot.\nAdd a legend to the figure. Use the temperatures as the labels.\nGo here and compare your results with the plots there to make sure you did it right.\n\n\n# Python code here\n\nThis file contains telemetry data for a weather balloon that was launched by the BYU-Idaho High Altitude Research Team (HART). The 5th and 7th columns in the file contain the speed and altitude of the balloon respectively. Read the data file and extract the speed and altitude of the balloon into lists or arrays. Then make a scatter plot of speed vs. altitude. Add axes labels and plot labels to your plot.\n\n# Python code here\n\nThis file contains worldwide earthquake data from the years 1973 to 2021. Set bins = 200 to make 200, equally-spaced bins on the histogram. The fourth column in the file contains the magnitude of the earthquakes. Read the file and plot a histogram of this column. Then write a single statement summarizing what this plot is communicating to you. Note: The file is zipped so you’ll need to unzip it before you can read it in.\n\n# Python code here\n\nThe position and velocity coordinates for a projectile launched at angle \\(\\theta\\) are given by: \\[x(t) = x_i + v_i \\cos \\theta\\Delta t \\] \\[ y(t) = y_i + v_i \\sin \\theta \\Delta t + {1\\over 2} a \\Delta t^2\\] \\[v_x(t) = v_i \\cos \\theta\\] \\[v_y(t) = v_i \\sin \\theta + a \\Delta t\\] Place the following plots on a 3 x 2 grid for \\(0 < t < 5.5\\) seconds: \\(x\\) vs \\(y\\) (first row, spans both columns), \\(x\\) vs \\(t\\) (second row, first column), \\(y\\) vs \\(t\\)(second row, first column), \\(v_x\\) vs \\(t\\)(third row, first column), and \\(v_y\\) vs \\(t\\)(third row, second column). Make sure that all of the plots have titles and axes labels. Use the following initial conditions: \\[v_i = 60 \\text{ m/s}\\] \\[\\theta = 22^\\circ\\] \\[x_i = 0 \\text{ m}\\] \\[y_i = 15 \\text{ m}\\]\n\n# Python code here\n\n(Extra Credit) The 7th column in the Earthquakes data file contains the date of the earthquake. Write a code to plot the number of earthquakes that occurred each year from 1973 to 2021. (The horizontal axis is year and the vertical axis is the number of earthquakes.)\n\n# Python code here"
  },
  {
    "objectID": "chapters/advancedPlotting.html",
    "href": "chapters/advancedPlotting.html",
    "title": "12  Advanced Plotting",
    "section": "",
    "text": "Jupyter Notebook\nIn this chapter you will learn how to plot functions of more than one variable \\(F(x,y)\\). Functions like this can be visualized by making a contour plots (like a topographic map) or by displaying the function value as height above the \\(x-y\\) plane like a perspective drawing. You can also display vector-valued function \\(\\mathbf{F}(x,y)\\) using vector field plots."
  },
  {
    "objectID": "chapters/advancedPlotting.html#making-2-d-grids",
    "href": "chapters/advancedPlotting.html#making-2-d-grids",
    "title": "12  Advanced Plotting",
    "section": "12.1 Making 2-D Grids",
    "text": "12.1 Making 2-D Grids\nWhen plotting a function of one variable, recall that the first step was to use linspace or arange to construct a grid of points spanning the domain of the function. For a function of two variables the domain is two-dimensional and hence the grid will also need to be two-dimensional. In other words, we need to construct a set of x-y pairs that spans the two-dimensional domain. We can do this using numpy.meshgrid and numpy.mgrid. Let’s see an example and then explain the pieces. Below you will find some code to plot the function: \\[f(x,y) = \\cos({\\pi \\over 2} x) \\exp(-y^2)\\] (see the code comments)\n\nfrom numpy import arange,meshgrid,cos,exp,pi,mgrid\nfrom matplotlib import pyplot as plt\n#from mpl_toolkits.mplot3d import Axes3D  #<- You need this to make 3D plots\n# Define the arrays x and y\n# Don't make the step size too small or you will kill the\n# system (you have a large, but finite amount of memory)\nx=arange(-2,2,0.1)\ny=arange(-2,2,0.1)\n# Use meshgrid to convert these 1-d arrays into 2-d matrices\n# of x and y values over the plane\nX,Y=meshgrid(x,y)\n#X,Y=mgrid[-1:1:0.1,0:1.5:0.1]  # You could also do this in place of meshgrid\n# Get F(x,y) by using F(X,Y).\n# rather than with x and y\nF=cos(pi/2*X)*exp(-Y**2)\n# Plot the function\nfig = plt.figure()\nax = plt.axes(projection = '3d')\nax.plot_surface(X,Y,F)\nplt.xlabel('x')\nplt.ylabel('y')\nplt.show()\n\n\n\n\n\nTo Do:\n\nPrint out X and Y and inspect the output until you understand what meshgrid does.\nReplace the function in the cell above with one of your choosing.\n\n\nLet’s break down this block of code one piece at a time. First, notice that anytime you want a 3 dimensional plot, you have to create a three-dimensional set of axes with the following command\nax=pyplot.axes(projection='3d')  # Set the axes to be 3 dimensional\nNext, meshgrid turns the one-dimensional arrays x and y into two-dimensional arrays X and Y. As an example, inspect the output from the cell below:\n\nfrom numpy import meshgrid\nx = [1,2,3]\ny = [4,5]\n\nX,Y = meshgrid(x,y)\nprint(X)\nprint(Y)\n\n[[1 2 3]\n [1 2 3]]\n[[4 4 4]\n [5 5 5]]\n\n\nThese two arrays provide a set of x-y coordinate pair that span the domain, as illustrated in the figure.\n\n\n\nmeshgrid\n\n\nNumpy also has a command called mgrid which is similar to meshgrid but does the conversion to two dimensions the other way around. As an example, inspect the output in the cell below.\n\nfrom numpy import mgrid\n\nX,Y = mgrid[1:4,4:6]\nprint(X)\nprint(Y)\n\n\nX,Y = mgrid[1:4:0.5,4:6:0.5]  \nprint(X)\nprint(Y)\n\n\nX,Y = mgrid[1:4:10j,4:6:10j] \nprint(X)\nprint(Y)\n\n[[1 1]\n [2 2]\n [3 3]]\n[[4 5]\n [4 5]\n [4 5]]\n[[1.  1.  1.  1. ]\n [1.5 1.5 1.5 1.5]\n [2.  2.  2.  2. ]\n [2.5 2.5 2.5 2.5]\n [3.  3.  3.  3. ]\n [3.5 3.5 3.5 3.5]]\n[[4.  4.5 5.  5.5]\n [4.  4.5 5.  5.5]\n [4.  4.5 5.  5.5]\n [4.  4.5 5.  5.5]\n [4.  4.5 5.  5.5]\n [4.  4.5 5.  5.5]]\n[[1.         1.         1.         1.         1.         1.\n  1.         1.         1.         1.        ]\n [1.33333333 1.33333333 1.33333333 1.33333333 1.33333333 1.33333333\n  1.33333333 1.33333333 1.33333333 1.33333333]\n [1.66666667 1.66666667 1.66666667 1.66666667 1.66666667 1.66666667\n  1.66666667 1.66666667 1.66666667 1.66666667]\n [2.         2.         2.         2.         2.         2.\n  2.         2.         2.         2.        ]\n [2.33333333 2.33333333 2.33333333 2.33333333 2.33333333 2.33333333\n  2.33333333 2.33333333 2.33333333 2.33333333]\n [2.66666667 2.66666667 2.66666667 2.66666667 2.66666667 2.66666667\n  2.66666667 2.66666667 2.66666667 2.66666667]\n [3.         3.         3.         3.         3.         3.\n  3.         3.         3.         3.        ]\n [3.33333333 3.33333333 3.33333333 3.33333333 3.33333333 3.33333333\n  3.33333333 3.33333333 3.33333333 3.33333333]\n [3.66666667 3.66666667 3.66666667 3.66666667 3.66666667 3.66666667\n  3.66666667 3.66666667 3.66666667 3.66666667]\n [4.         4.         4.         4.         4.         4.\n  4.         4.         4.         4.        ]]\n[[4.         4.22222222 4.44444444 4.66666667 4.88888889 5.11111111\n  5.33333333 5.55555556 5.77777778 6.        ]\n [4.         4.22222222 4.44444444 4.66666667 4.88888889 5.11111111\n  5.33333333 5.55555556 5.77777778 6.        ]\n [4.         4.22222222 4.44444444 4.66666667 4.88888889 5.11111111\n  5.33333333 5.55555556 5.77777778 6.        ]\n [4.         4.22222222 4.44444444 4.66666667 4.88888889 5.11111111\n  5.33333333 5.55555556 5.77777778 6.        ]\n [4.         4.22222222 4.44444444 4.66666667 4.88888889 5.11111111\n  5.33333333 5.55555556 5.77777778 6.        ]\n [4.         4.22222222 4.44444444 4.66666667 4.88888889 5.11111111\n  5.33333333 5.55555556 5.77777778 6.        ]\n [4.         4.22222222 4.44444444 4.66666667 4.88888889 5.11111111\n  5.33333333 5.55555556 5.77777778 6.        ]\n [4.         4.22222222 4.44444444 4.66666667 4.88888889 5.11111111\n  5.33333333 5.55555556 5.77777778 6.        ]\n [4.         4.22222222 4.44444444 4.66666667 4.88888889 5.11111111\n  5.33333333 5.55555556 5.77777778 6.        ]\n [4.         4.22222222 4.44444444 4.66666667 4.88888889 5.11111111\n  5.33333333 5.55555556 5.77777778 6.        ]]\n\n\n\nTo Do:\n\nExamine all three sets of output from the cell above until you understand the differences.\nWhat happens when you add a third argument to mgrid?\nWhat happens if the third argument is imaginary (i.e. 10j)?\n\n\nAll three-dimensional plots will require that you first use meshgrid or mgrid to generate a grid over the two-dimensional domain.\nThe default viewing angle can often be less than optimal for viewing the function well. To modify the viewing angle, use the function view_init, which takes up to three arguments: the viewing altitude, the rotation angle about the z-axis, and the rotation angle above the x-y plane."
  },
  {
    "objectID": "chapters/advancedPlotting.html#surface-plots",
    "href": "chapters/advancedPlotting.html#surface-plots",
    "title": "12  Advanced Plotting",
    "section": "12.2 Surface Plots",
    "text": "12.2 Surface Plots\nYou’ve already seen an example of a surface plot above. A similar plot can be generated by replacing plot_surface with plot_wireframe. This plot looks similar to the surface plot shown above. See the cell below for an example.\n\nfrom numpy import arange,meshgrid,cos,exp,pi,mgrid\nfrom matplotlib import pyplot\n\nx=arange(-2,2,0.1)\ny=arange(-1.5,1.5,0.1)\n\nX,Y=meshgrid(x,y)\n\nF=cos(pi/2*X)*exp(-Y**2)\n\nax=pyplot.axes(projection='3d')\nax.plot_wireframe(X,Y,F)\npyplot.xlabel('x')\npyplot.ylabel('y')\npyplot.show()"
  },
  {
    "objectID": "chapters/advancedPlotting.html#contour-plots",
    "href": "chapters/advancedPlotting.html#contour-plots",
    "title": "12  Advanced Plotting",
    "section": "12.3 Contour Plots",
    "text": "12.3 Contour Plots\nPython generates contour plots very similarly to surface plots. Instead of using plot_surface or plot_wireframe, the function contour is used. Look at the example below.\n\nfrom numpy import arange,meshgrid,cos,exp,pi,mgrid\nfrom matplotlib import pyplot\n\nx=arange(-2,2,0.1)\ny=arange(-1.5,1.5,0.1)\n\nX,Y=meshgrid(x,y)\n\nF=cos(pi/2*X)*exp(-Y**2)\n\nax=pyplot.axes(projection='3d')\nax.contour(X,Y,F)\npyplot.xlabel('x')\npyplot.ylabel('y')\npyplot.show()\n\n\n\n\n\n12.3.1 The levels keyword argument\nThe keyword argument levels can be added to the function call to specify which (or how many) contours are displayed. If levels = n where n is an integer, the contour function will plot n contours. If levels = [a,b,c] then the contour function will lines of constant value equal to the values specified. The code block below gives a few examples.\n\nfrom numpy import arange,meshgrid,cos,exp,pi,mgrid\nfrom matplotlib import pyplot\n\nx=arange(-2,2,0.1)\ny=arange(-1.5,1.5,0.1)\n\nX,Y=meshgrid(x,y)\n\nF=cos(pi/2*X)*exp(-Y**2)\n\nax=pyplot.axes(projection='3d')\nax.contour(X,Y,F,levels = 5)\npyplot.xlabel('x')\npyplot.ylabel('y')\npyplot.show()\n\n\n\n\n\nfrom numpy import arange,meshgrid,cos,exp,pi,mgrid\nfrom matplotlib import pyplot\n\nx=arange(-2,2,0.1)\ny=arange(-1.5,1.5,0.1)\n\nX,Y=meshgrid(x,y)\n\nF=cos(pi/2*X)*exp(-Y**2)\n\nax=pyplot.axes(projection='3d')\nax.contour(X,Y,F,levels = [-0.5,0.25,0.75])\npyplot.xlabel('x')\npyplot.ylabel('y')\npyplot.show()"
  },
  {
    "objectID": "chapters/advancedPlotting.html#vector-field-plots",
    "href": "chapters/advancedPlotting.html#vector-field-plots",
    "title": "12  Advanced Plotting",
    "section": "12.4 Vector-Field Plots",
    "text": "12.4 Vector-Field Plots\nIn electricity and magnetism you’ll encounter functions that produce a vector (\\(\\mathbf{F}(x,y)\\)) instead of a number(\\(F(x,y)\\)) like you may be used to. In other words, instead of associating a number with every (x,y) pair, a vector \\((f_x,f_y)\\) is associated with each pair. You can plot a vector field using the quiver function, which takes four required arguments. The first two are the output from meshgrid just as with the other plots we have done. The third and fourth arguments are the components of the vectors at each (x,y) pair. Below is an example of how to plot the following vector-valued function \\[\\mathbf{B} = (-y/(x^2 + y^2),x/(x^2 + y^2))\\]\n\nfrom numpy import arange, meshgrid,sqrt,log\nfrom matplotlib import pyplot\nx = arange(-5.25,5.25,0.5) # define the x and y grids (avoid (0,0))\ny = arange(-5.25,5.25,0.5) # define the x and y grids (avoid (0,0))\nX,Y=meshgrid(x,y)\n\n# Magnetic field of a long current-carrying wire\nBx=-Y/(X**2+Y**2)\nBy=X/(X**2+Y**2)\n# make the field arrow plot\npyplot.figure()\npyplot.quiver(X,Y,Bx,By)\npyplot.axis('equal')  # make the x and y axes be equally scaled\npyplot.title('B of a long current-carrying wire')\npyplot.show()\n\n\n\n\nOften, the lengths of these vectors will be large and that makes it hard to look at the graphic. One option for improving this is to force all of the vectors to have length \\(1\\) and then color the vector according to the true length. To set the color of the arrows, add a fifth argument to the function that contains the vector lengths. You can then add the keyword argument cmap to specify the color spectrum to use. My favorite is gist_rainbow but there are other here.\n\nfrom numpy import arange, meshgrid,sqrt,log\nfrom matplotlib import pyplot\nx = arange(-5.25,5.25,0.5) # define the x and y grids (avoid (0,0))\ny = arange(-5.25,5.25,0.5) # define the x and y grids (avoid (0,0))\nX,Y=meshgrid(x,y)\n\n# Magnetic field of a long current-carrying wire\nBx=-Y/(X**2+Y**2)\nBy=X/(X**2+Y**2)\nB = sqrt(Bx**2 + By**2)  # Find the magnitude of the vectors.\n# make the field arrow plot\npyplot.figure()\npyplot.quiver(X,Y,Bx/B,By/B,B,cmap=\"gist_rainbow\")  # Divide by magnitude to make them equal to 1\npyplot.axis('equal')  # make the x and y axes be equally scaled\npyplot.title('B of a long current-carrying wire')\npyplot.show()"
  },
  {
    "objectID": "chapters/advancedPlotting.html#animations",
    "href": "chapters/advancedPlotting.html#animations",
    "title": "12  Advanced Plotting",
    "section": "12.5 Animations",
    "text": "12.5 Animations\nOften you will want to see how a plot evolves over time. Maybe you are plotting the waveform on a string and you want to see how it changes in time. Animations can be built by repeatedly constructing a new plot and then waiting before you clear the canvas and plot again. Look at the example below to see how to do this:\nfrom numpy import arange,sin,cos\nfrom matplotlib import pyplot\n%matplotlib\n\nt=0\nx = arange(0,5,0.01) #Domain over which I want to plot the function.\nwhile t < 10:\n    y=sin(5*x-3*t)*cos(2*x) #Constructarrayoffunction\n                                         # values at current time.\n    pyplot.clf()  # Clear the canvas, otherwise all plots end up on\n                  # top of each other\n    pyplot.plot(x,y,'r-',linewidth=3)\n    pyplot.xlabel('x')\n    pyplot.ylabel('f(x)')\n    pyplot.title('t = {:.4f}'.format(t))\n    pyplot.draw()\n    pyplot.pause(0.01)\n    t += .1\n# draw the plot, but don't wait for\n# someone to close the window.\n# Wait before plotting the next one.\n# Advance time."
  },
  {
    "objectID": "chapters/advancedPlotting.html#flashcards",
    "href": "chapters/advancedPlotting.html#flashcards",
    "title": "12  Advanced Plotting",
    "section": "12.6 Flashcards",
    "text": "12.6 Flashcards\n\nDescribe the use and output of meshgrid.\nWhat is the difference between meshgrid and mgrid?\nWhat are the three lines of code that must be included if you are building a three-dimensional plot?\nWhat is the difference between plot_surface and plot_wireframe?\nWhat does the levels keyword argument do when making a contour plot? (What possible values can this argument take?)\nWhat is a vector-field plot and how do you generate one in python?\nWhat keyword argument controls the color of the vectors in a vector-field plot?\nWhere can you find the parable of the laborers in the vineyard?"
  },
  {
    "objectID": "chapters/advancedPlotting.html#exercises",
    "href": "chapters/advancedPlotting.html#exercises",
    "title": "12  Advanced Plotting",
    "section": "12.7 Exercises",
    "text": "12.7 Exercises\n\nPlot the following function from \\(-5 < x,y < 5\\) \\[ f(x,y) = {\\sin (x y)\\over x^2 + y^2}\\]\n\n# Python code here\n\nMake a contour plot of the function from problem 1. The contours you plot should be where \\(f(x,y) = -0.25, 0, 0.25\\).\n\n# Python code here\n\nThe range of a projectile launched on level ground is given by: \\[ R = {v_i^2 \\sin(2 \\theta)\\over g}\\] where \\(v_i\\) is the launch speed, \\(\\theta\\) is the launch angle, and \\(g = 9.8\\) m/s\\(^2\\) is the acceleration due to gravity. Plot \\(R(v_i,\\theta)\\) for \\(0 < v_i < 50\\) m/s and \\(0 < \\theta < 90^\\circ\\). Now write a single sentence summarizing the results of the plot.\n\n# Python code here\n\n(Extra Credit) The angle of impact for a projectile launched with initial speed \\(v\\), launch angle \\(\\theta\\), and initial height \\(y_i\\) is given by: \\[ \\phi = \\tan^{-1} \\left( {\\sqrt{v^2 \\sin^2\\theta + 2 g y_0} \\over v \\cos \\theta} \\right) \\] Plot the impact angle as a function of \\(v\\) and \\(\\theta\\) (\\(\\phi(v,\\theta)\\)) for \\(0 < v_i < 50\\) m/s and \\(0 < \\theta < 90^\\circ\\) and \\(y_i = 10\\) m. Then write a single sentence summarizing the results of the plot.\n\n# Python code here"
  },
  {
    "objectID": "chapters/pandas.html",
    "href": "chapters/pandas.html",
    "title": "13  Pandas",
    "section": "",
    "text": "Jupyter Notebook\nPandas is a Python package built to work with spreadsheet-like data, and it is very good at its job. Pandas stores data in something called a “dataframe”. A dataframe is simply data stored in rows and columns. As an example, here is some sample data taken by an accelerometer sitting on an elevator floor:\ntime,gFx,gFy,gFz\n0.007,-0.0056,-0.0046,1.012\n0.008,0.0007,0.0024,1.0022\n0.008,0,0.0059,1.0039\n0.009,0.0054,-0.0022,1.0032\n0.009,-0.0015,-0.0056,1.0042\n0.009,0.0037,-0.002,0.9951\n0.01,-0.002,-0.002,1.002\n0.014,0.009,-0.0024,1.0159\n0.015,0.0012,-0.0037,1.01\n0.017,-0.0115,-0.002,1.0012\n0.019,-0.0022,-0.0015,1.001\n0.021,0.0024,-0.0022,1.0166\nand here is the same data loaded into a dataframe.\nEvery dataframe has labels attached to its columns and rows. In this example, the row labels are just the first 10 integers and the column labels are “time”, “gFx”, “gFy”, and , “gFz”. Labeling the rows and columns is nice because you can access data using the row and column labels instead of indices."
  },
  {
    "objectID": "chapters/pandas.html#creating-dataframes",
    "href": "chapters/pandas.html#creating-dataframes",
    "title": "13  Pandas",
    "section": "13.1 Creating dataframes",
    "text": "13.1 Creating dataframes\nA dataframe can be initiated in many ways but the most common are: from file, from a dictionary, and from an array or list. We’ll discuss each way separately.\n\n13.1.1 Reading from a .csv file.\nThe most-used function from the pandas module is read_csv which is used to read a csv-formatted file into a data frame. To use it, simply call the pandas.read_csv function and pass in the path to the .csv file. (Here is a link to the file.)\n\nfrom pandas import read_csv\n\nelevator_data = read_csv(\"elevator.csv\",index_col = 0)\nprint(elevator_data)\n\n    time     gFx     gFy     gFz\n0  0.007 -0.0056 -0.0046  1.0120\n1  0.008  0.0070  0.0024  1.0022\n2  0.008  0.0000  0.0059  1.0039\n3  0.009  0.0054 -0.0022  1.0032\n4  0.009 -0.0015 -0.0056  1.0042\n5  0.009  0.0037 -0.0020  0.9951\n6  0.010 -0.0020 -0.0020  1.0020\n7  0.014  0.0090 -0.0025  1.0159\n8  0.015  0.0012 -0.0037  1.0100\n9  0.017 -0.0115 -0.0020  1.0012\n\n\nThe keyword argument index_col = 0 indicates that the row labels should be taken from the first column in the csv file. There are many, many possible keyword arguments that can be used to customize the way read_csv reads a file into a dataframe. I’ll highlight just a few and refer you to the documentation for the rest:\n\ndelimiter- use this to specify the character that separates the data from each other. The default is “,” for .csv files.\nheader - use this to specify which row contains the column names. Usually this occurs on the first row (header = 0) but not always.\nusecols - use this to specify which columns from the file should be included in the dataframe.\nskiprows - line numbers to skip when building the dataframe. Can be either a single integer (skip the first n lines) or a list of integers and it will skip all rows in the list.\n\nThe rename() function can be used if you don’t like the default index values (integers if you read from file) and want to reassign them.\n\nfrom pandas import read_csv\n\nelevator_data = read_csv(\"elevator.csv\",index_col = 0)\nelevator_data = elevator_data.rename(index = {0:\"A\",1:\"B\",2:\"C\",3:\"D\",4:\"E\",5:\"F\",6:\"G\",7:\"H\",8:\"I\",9:\"J\"})\nprint(elevator_data)\n\n    time     gFx     gFy     gFz\nA  0.007 -0.0056 -0.0046  1.0120\nB  0.008  0.0070  0.0024  1.0022\nC  0.008  0.0000  0.0059  1.0039\nD  0.009  0.0054 -0.0022  1.0032\nE  0.009 -0.0015 -0.0056  1.0042\nF  0.009  0.0037 -0.0020  0.9951\nG  0.010 -0.0020 -0.0020  1.0020\nH  0.014  0.0090 -0.0025  1.0159\nI  0.015  0.0012 -0.0037  1.0100\nJ  0.017 -0.0115 -0.0020  1.0012\n\n\n\n\n13.1.2 Create from a dictionary\nIf your data is in a dictionary you can use the DataFrame function (case sensitive) to initialize the dataframe. Key values in the dictionary correspond to columns in the dataframe.\n\nfrom pandas import DataFrame\nelevator = {\"time\":[0.007,0.008,0.008,0.009,0.009,0.009,0.01,0.014,0.015,0.017],\"gFx\":[-0.0056,0.007,0,0.0054,-0.0015,0.0037,-0.002,0.009,0.0012,-0.0115],\"gFy\":[-0.0046,0.0024,0.0059,-0.0022,-0.0056,-0.002,-0.002,-0.0025,-0.0037,-0.002],\"gFz\":[1.012,1.0022,1.0039,1.0032,1.0042,0.9951,1.002,1.0159,1.01,1.0012]}\nelevator_data = DataFrame(elevator)\nprint(elevator_data)\n\n    time     gFx     gFy     gFz\n0  0.007 -0.0056 -0.0046  1.0120\n1  0.008  0.0070  0.0024  1.0022\n2  0.008  0.0000  0.0059  1.0039\n3  0.009  0.0054 -0.0022  1.0032\n4  0.009 -0.0015 -0.0056  1.0042\n5  0.009  0.0037 -0.0020  0.9951\n6  0.010 -0.0020 -0.0020  1.0020\n7  0.014  0.0090 -0.0025  1.0159\n8  0.015  0.0012 -0.0037  1.0100\n9  0.017 -0.0115 -0.0020  1.0012\n\n\nThe row indices will default to the a set of integers starting at 0. If you want to index the rows with other labels, use the index keyword argument.\n\nfrom pandas import DataFrame\nelevator = {\"time\":[0.007,0.008,0.008,0.009,0.009,0.009,0.01,0.014,0.015,0.017],\"gFx\":[-0.0056,0.007,0,0.0054,-0.0015,0.0037,-0.002,0.009,0.0012,-0.0115],\"gFy\":[-0.0046,0.0024,0.0059,-0.0022,-0.0056,-0.002,-0.002,-0.0025,-0.0037,-0.002],\"gFz\":[1.012,1.0022,1.0039,1.0032,1.0042,0.9951,1.002,1.0159,1.01,1.0012]}\nelevator_data = DataFrame(elevator,index = [\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\",\"H\",\"J\",\"K\"])\nprint(elevator_data)\n\n    time     gFx     gFy     gFz\nA  0.007 -0.0056 -0.0046  1.0120\nB  0.008  0.0070  0.0024  1.0022\nC  0.008  0.0000  0.0059  1.0039\nD  0.009  0.0054 -0.0022  1.0032\nE  0.009 -0.0015 -0.0056  1.0042\nF  0.009  0.0037 -0.0020  0.9951\nG  0.010 -0.0020 -0.0020  1.0020\nH  0.014  0.0090 -0.0025  1.0159\nJ  0.015  0.0012 -0.0037  1.0100\nK  0.017 -0.0115 -0.0020  1.0012\n\n\n\n\n13.1.3 Create from a list\nSometimes you have data in a list or multiple list and would like to combine all of that data and form a dataframe. This can also be done using the DataFrame function (case sensitive remember!). When initializing with lists, you have to also use the columns keyword argument to specify what you want the column labels to be.\nfrom pandas import DataFrame\nfrom numpy import transpose\n\ntime = [0.007,0.008,0.008,0.009,0.009,0.009,0.01,0.014,0.015,0.017]\ngFx = [-0.0056,0.007,0,0.0054,-0.0015,0.0037,-0.002,0.009,0.0012,-0.0115]\ngFy = [-0.0046,0.0024,0.0059,-0.0022,-0.0056,-0.002,-0.002,-0.0025,-0.0037,-0.002]\ngFz = [1.012,1.0022,1.0039,1.0032,1.0042,0.9951,1.002,1.0159,1.01,1.0012]\nelevator_data = DataFrame(transpose([time,gFx,gFy,gFz]),columns = [\"time\", \"gFx\",\"gFy\", \"gFz\"])\nThe row labels will default to integers unless you specify otherwise with the index keyword.\nfrom pandas import DataFrame\nfrom numpy import transpose\n\ntime = [0.007,0.008,0.008,0.009,0.009,0.009,0.01,0.014,0.015,0.017]\ngFx = [-0.0056,0.007,0,0.0054,-0.0015,0.0037,-0.002,0.009,0.0012,-0.0115]\ngFy = [-0.0046,0.0024,0.0059,-0.0022,-0.0056,-0.002,-0.002,-0.0025,-0.0037,-0.002]\ngFz = [1.012,1.0022,1.0039,1.0032,1.0042,0.9951,1.002,1.0159,1.01,1.0012]\nelevator_data = DataFrame(transpose([time,gFx,gFy,gFz]),columns = [\"time\", \"gFx\",\"gFy\", \"gFz\"],index = [\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\",\"H\",\"J\",\"K\"])"
  },
  {
    "objectID": "chapters/pandas.html#extracting-data",
    "href": "chapters/pandas.html#extracting-data",
    "title": "13  Pandas",
    "section": "13.2 Extracting data",
    "text": "13.2 Extracting data\nExtracting data from the dataframe could mean several things. The most common possibilities include:\n\naccessing a single number using row and column labels or row and column indices.\naccessing one or several columns of the dataframe.\naccessing one or several rows of the dataframe.\nslicing from the “middle” of the dataframe. (i.e. Not entire columns or entire rows.)\naccessing only elements in the dataframe that meet a certain criteria.\n\nWe’ll cover each of these tasks one at a time.\n\n13.2.1 Extracting General Information\nSometimes the dataframe is quite large and you’d like to inspect just a small portion of it. You can use dataframe.head(n) to look at the first n rows in the dataframe and dataframe.tail(n) to look at the last n rows.\n\nelevator_data.head(3)\nelevator_data.tail(4)\n\n\n\n\n\n  \n    \n      \n      time\n      gFx\n      gFy\n      gFz\n    \n  \n  \n    \n      G\n      0.010\n      -0.0020\n      -0.0020\n      1.0020\n    \n    \n      H\n      0.014\n      0.0090\n      -0.0025\n      1.0159\n    \n    \n      J\n      0.015\n      0.0012\n      -0.0037\n      1.0100\n    \n    \n      K\n      0.017\n      -0.0115\n      -0.0020\n      1.0012\n    \n  \n\n\n\n\nTo get a list of the column or row labels, use the variables dataframe.columns and dataframe.index.\n\nelevator_data.columns\nelevator_data.index\n\nIndex(['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'J', 'K'], dtype='object')\n\n\n\n\n13.2.2 Extracting a single number\nTo extract a single number from a dataframe, use the dataframe.at[] or dataframe.iat[] objects. The at object should be used if you want to locate the number using row and column labels and iat should be used when you want to access the number using row and column indices. Let’s see an example:\n\nfrom pandas import DataFrame\nfrom numpy import transpose\n\ntime = [0.007,0.008,0.008,0.009,0.009,0.009,0.01,0.014,0.015,0.017]\ngFx = [-0.0056,0.007,0,0.0054,-0.0015,0.0037,-0.002,0.009,0.0012,-0.0115]\ngFy = [-0.0046,0.0024,0.0059,-0.0022,-0.0056,-0.002,-0.002,-0.0025,-0.0037,-0.002]\ngFz = [1.012,1.0022,1.0039,1.0032,1.0042,0.9951,1.002,1.0159,1.01,1.0012]\nelevator_data = DataFrame(transpose([time,gFx,gFy,gFz]),columns = [\"time\", \"gFx\",\"gFy\", \"gFz\"],index = [\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\",\"H\",\"J\",\"K\"])\n\nelevator_data.at[\"A\",\"time\"]\nelevator_data.iat[0,0]\n\n0.007\n\n\nThe loc and iloc dictionaries (see below) can also be used to extract a single entry in the dataframe.\n\n\n13.2.3 Extracting entire columns\nAn entire column of the dataframe can be extract by indexing it like a dictionary, using the column name as the key value\nelevator_data[\"gFz\"]\nelevator_data[\"time\"]\nelevator_data[\"time\"][0:3]\nYou can bundle the column names into a list and extract multiple columns at once.\nelevator_data[[\"gFx\", \"gFy\", \"gFz\"]]\n\n\n13.2.4 Accessing entire rows\nAccessing rows in a dataframe is done with the help of the dataframe.loc[n] or dataframe.iloc[n] dictionary. loc should be used if you want to slice using row and column labels whereas iloc should be used if you want to slice out using indices.\n\nfrom pandas import DataFrame\nfrom numpy import transpose\n\ntime = [0.007,0.008,0.008,0.009,0.009,0.009,0.01,0.014,0.015,0.017]\ngFx = [-0.0056,0.007,0,0.0054,-0.0015,0.0037,-0.002,0.009,0.0012,-0.0115]\ngFy = [-0.0046,0.0024,0.0059,-0.0022,-0.0056,-0.002,-0.002,-0.0025,-0.0037,-0.002]\ngFz = [1.012,1.0022,1.0039,1.0032,1.0042,0.9951,1.002,1.0159,1.01,1.0012]\nelevator_data = DataFrame(transpose([time,gFx,gFy,gFz]),columns = [\"time\", \"gFx\",\"gFy\", \"gFz\"],index = [\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\",\"H\",\"J\",\"K\"])\n\nelevator_data.loc[\"A\"]\nelevator_data.iloc[0]  \n\ntime    0.0070\ngFx    -0.0056\ngFy    -0.0046\ngFz     1.0120\nName: A, dtype: float64\n\n\nMultiple rows can be accessed using the A:B syntax to slice out the desired rows.\n\nfrom pandas import DataFrame\nfrom numpy import transpose\n\ntime = [0.007,0.008,0.008,0.009,0.009,0.009,0.01,0.014,0.015,0.017]\ngFx = [-0.0056,0.007,0,0.0054,-0.0015,0.0037,-0.002,0.009,0.0012,-0.0115]\ngFy = [-0.0046,0.0024,0.0059,-0.0022,-0.0056,-0.002,-0.002,-0.0025,-0.0037,-0.002]\ngFz = [1.012,1.0022,1.0039,1.0032,1.0042,0.9951,1.002,1.0159,1.01,1.0012]\nelevator_data = DataFrame(transpose([time,gFx,gFy,gFz]),columns = [\"time\", \"gFx\",\"gFy\", \"gFz\"],index = [\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\",\"H\",\"J\",\"K\"])\n\nelevator_data.loc[\"A\":\"D\"]\nelevator_data.iloc[0:4]  \n\n\n\n\n\n  \n    \n      \n      time\n      gFx\n      gFy\n      gFz\n    \n  \n  \n    \n      A\n      0.007\n      -0.0056\n      -0.0046\n      1.0120\n    \n    \n      B\n      0.008\n      0.0070\n      0.0024\n      1.0022\n    \n    \n      C\n      0.008\n      0.0000\n      0.0059\n      1.0039\n    \n    \n      D\n      0.009\n      0.0054\n      -0.0022\n      1.0032\n    \n  \n\n\n\n\n\n\n13.2.5 Slicing rows and columns\nThe loc and iloc dictionaries can be used to slice across rows and columns. Simple separate the two slices with a comma:\n\nfrom pandas import DataFrame\nfrom numpy import transpose\n\ntime = [0.007,0.008,0.008,0.009,0.009,0.009,0.01,0.014,0.015,0.017]\ngFx = [-0.0056,0.007,0,0.0054,-0.0015,0.0037,-0.002,0.009,0.0012,-0.0115]\ngFy = [-0.0046,0.0024,0.0059,-0.0022,-0.0056,-0.002,-0.002,-0.0025,-0.0037,-0.002]\ngFz = [1.012,1.0022,1.0039,1.0032,1.0042,0.9951,1.002,1.0159,1.01,1.0012]\nelevator_data = DataFrame(transpose([time,gFx,gFy,gFz]),columns = [\"time\", \"gFx\",\"gFy\", \"gFz\"],index = [\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\",\"H\",\"J\",\"K\"])\n\nelevator_data.loc[\"A\":\"D\",\"time\":\"gFy\"]\nelevator_data.iloc[0:4,0:2]  \n\n\n\n\n\n  \n    \n      \n      time\n      gFx\n    \n  \n  \n    \n      A\n      0.007\n      -0.0056\n    \n    \n      B\n      0.008\n      0.0070\n    \n    \n      C\n      0.008\n      0.0000\n    \n    \n      D\n      0.009\n      0.0054\n    \n  \n\n\n\n\n\n\n13.2.6 Boolean Slicing\nWe have already seen boolean slicing in Numpy Arrays and we can use something similar on Pandas. Let’s see an example:\n\nfrom pandas import DataFrame\nfrom numpy import transpose\n\ntime = [0.007,0.008,0.008,0.009,0.009,0.009,0.01,0.014,0.015,0.017]\ngFx = [-0.0056,0.007,0,0.0054,-0.0015,0.0037,-0.002,0.009,0.0012,-0.0115]\ngFy = [-0.0046,0.0024,0.0059,-0.0022,-0.0056,-0.002,-0.002,-0.0025,-0.0037,-0.002]\ngFz = [1.012,1.0022,1.0039,1.0032,1.0042,0.9951,1.002,1.0159,1.01,1.0012]\nelevator_data = DataFrame(transpose([time,gFx,gFy,gFz]),columns = [\"time\", \"gFx\",\"gFy\", \"gFz\"],index = [\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\",\"H\",\"J\",\"K\"])\n\nelevator_data[elevator_data[\"time\"] < 0.01]  # Slice only the rows where time < 0.01\n\n\n\n\n\n  \n    \n      \n      time\n      gFx\n      gFy\n      gFz\n    \n  \n  \n    \n      A\n      0.007\n      -0.0056\n      -0.0046\n      1.0120\n    \n    \n      B\n      0.008\n      0.0070\n      0.0024\n      1.0022\n    \n    \n      C\n      0.008\n      0.0000\n      0.0059\n      1.0039\n    \n    \n      D\n      0.009\n      0.0054\n      -0.0022\n      1.0032\n    \n    \n      E\n      0.009\n      -0.0015\n      -0.0056\n      1.0042\n    \n    \n      F\n      0.009\n      0.0037\n      -0.0020\n      0.9951\n    \n  \n\n\n\n\nThe statement elevator_data[\"time\"] < 0.01 produces a boolean sequence which can be used as a set of indices to access only those entries where time is less than 0.01.\nMore complex boolean slicing can be done with the use of the query function which allows you to be more specific about your boolean conditions. The example below will extract all rows in the dataframe where time > 0.008 and gFz is greater than 1.\n\nfrom pandas import DataFrame\nfrom numpy import transpose\n\ntime = [0.007,0.008,0.008,0.009,0.009,0.009,0.01,0.014,0.015,0.017]\ngFx = [-0.0056,0.007,0,0.0054,-0.0015,0.0037,-0.002,0.009,0.0012,-0.0115]\ngFy = [-0.0046,0.0024,0.0059,-0.0022,-0.0056,-0.002,-0.002,-0.0025,-0.0037,-0.002]\ngFz = [1.012,1.0022,1.0039,1.0032,1.0042,0.9951,1.002,1.0159,1.01,1.0012]\nelevator_data = DataFrame(transpose([time,gFx,gFy,gFz]),columns = [\"time\", \"gFx\",\"gFy\", \"gFz\"],index = [\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\",\"H\",\"J\",\"K\"])\n\nelevator_data.query(\"time > 0.008 and gFz > 1\")\n\n\n\n\n\n  \n    \n      \n      time\n      gFx\n      gFy\n      gFz\n    \n  \n  \n    \n      D\n      0.009\n      0.0054\n      -0.0022\n      1.0032\n    \n    \n      E\n      0.009\n      -0.0015\n      -0.0056\n      1.0042\n    \n    \n      G\n      0.010\n      -0.0020\n      -0.0020\n      1.0020\n    \n    \n      H\n      0.014\n      0.0090\n      -0.0025\n      1.0159\n    \n    \n      J\n      0.015\n      0.0012\n      -0.0037\n      1.0100\n    \n    \n      K\n      0.017\n      -0.0115\n      -0.0020\n      1.0012\n    \n  \n\n\n\n\n\n\n13.2.7 Special Characters in Column Name\nOften you will find that your column labels will contain spaces and/or other special characters in them. To correctly specify the column label in these cases, you must enclose the name in graves accents (It’s located above the tab key on your keyboard.). For example, if your column label was ” time-s” instead of just “time” like in the example above, you could use the query function like this:\n\nfrom pandas import DataFrame\nfrom numpy import transpose\n\ntime = [0.007,0.008,0.008,0.009,0.009,0.009,0.01,0.014,0.015,0.017]\ngFx = [-0.0056,0.007,0,0.0054,-0.0015,0.0037,-0.002,0.009,0.0012,-0.0115]\ngFy = [-0.0046,0.0024,0.0059,-0.0022,-0.0056,-0.002,-0.002,-0.0025,-0.0037,-0.002]\ngFz = [1.012,1.0022,1.0039,1.0032,1.0042,0.9951,1.002,1.0159,1.01,1.0012]\nelevator_data = DataFrame(transpose([time,gFx,gFy,gFz]),columns = [\" time-s\", \"gFx\",\"gFy\", \"gFz\"],index = [\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\",\"H\",\"J\",\"K\"])\n\nelevator_data.query(\"` time-s` > 0.008 and gFz > 1\")\n\n\n\n\n\n  \n    \n      \n      time-s\n      gFx\n      gFy\n      gFz\n    \n  \n  \n    \n      D\n      0.009\n      0.0054\n      -0.0022\n      1.0032\n    \n    \n      E\n      0.009\n      -0.0015\n      -0.0056\n      1.0042\n    \n    \n      G\n      0.010\n      -0.0020\n      -0.0020\n      1.0020\n    \n    \n      H\n      0.014\n      0.0090\n      -0.0025\n      1.0159\n    \n    \n      J\n      0.015\n      0.0012\n      -0.0037\n      1.0100\n    \n    \n      K\n      0.017\n      -0.0115\n      -0.0020\n      1.0012\n    \n  \n\n\n\n\n\n\n13.2.8 Using Query to match strings\nOften your dataframe will contain strings as the data instead of numbers. If you are trying to use query to find dataframe entries that contain a specified string, you’ll have enclose the boolean expression in single quotes (’’) and enclose the string you are trying to match in double quotes (““). As an example, imagine a dataframe very similar to the one used in the previous example, but with an additional column that specifies whether the object\n\nfrom pandas import DataFrame\nfrom numpy import transpose\n\ndataDict = {\" time-s\":[0.007,0.008,0.008,0.009,0.009,0.009,0.01,0.014,0.015,0.017], \"gFx\":[-0.0056,0.007,0,0.0054,-0.0015,0.0037,-0.002,0.009,0.0012,-0.0115],\"gFy\":[-0.0046,0.0024,0.0059,-0.0022,-0.0056,-0.002,-0.002,-0.0025,-0.0037,-0.002],\"gFz\":[1.012,1.0022,1.0039,1.0032,1.0042,0.9951,1.002,1.0159,1.01,1.0012], \"Here\":[\"Yes\",\"Yes\",\"No\",\"No\",\"Yes\",\"No\",\"Yes\",\"No\",\"Yes\",\"No\"]}\n\nelevator_data = DataFrame(dataDict,index = [\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\",\"H\",\"J\",\"K\"])\n\nelevator_data.query('` time-s` > 0.008 and Here == \"No\"')\n\n\n\n\n\n  \n    \n      \n      time-s\n      gFx\n      gFy\n      gFz\n      Here\n    \n  \n  \n    \n      D\n      0.009\n      0.0054\n      -0.0022\n      1.0032\n      No\n    \n    \n      F\n      0.009\n      0.0037\n      -0.0020\n      0.9951\n      No\n    \n    \n      H\n      0.014\n      0.0090\n      -0.0025\n      1.0159\n      No\n    \n    \n      K\n      0.017\n      -0.0115\n      -0.0020\n      1.0012\n      No\n    \n  \n\n\n\n\n\nTo Do:\n\nAdd print statements to the cell above until you understand what each line of code does.\nAdd comments next to the line of code to help you remember."
  },
  {
    "objectID": "chapters/pandas.html#performing-calculations",
    "href": "chapters/pandas.html#performing-calculations",
    "title": "13  Pandas",
    "section": "13.3 Performing Calculations",
    "text": "13.3 Performing Calculations\nDataframes are similar to numpy arrays in that you can do math across an entire dataset. This makes mathematical calculations very easy. Look at the example below and try to guess what calculation is being performed\n\nfrom numpy import sqrt\n\nelevator_data[[\"gFx\", \"gFy\", \"gFz\"]] *= 9.8\na_magnitude  = sqrt(elevator_data[[\"gFx\", \"gFy\", \"gFz\"]]**2).sum(axis = 1)\n\nmax_accel = a_magnitude.max()\n\nelevator_data\n\n\n\n\n\n  \n    \n      \n      time-s\n      gFx\n      gFy\n      gFz\n      Here\n    \n  \n  \n    \n      A\n      0.007\n      -0.05488\n      -0.04508\n      9.91760\n      Yes\n    \n    \n      B\n      0.008\n      0.06860\n      0.02352\n      9.82156\n      Yes\n    \n    \n      C\n      0.008\n      0.00000\n      0.05782\n      9.83822\n      No\n    \n    \n      D\n      0.009\n      0.05292\n      -0.02156\n      9.83136\n      No\n    \n    \n      E\n      0.009\n      -0.01470\n      -0.05488\n      9.84116\n      Yes\n    \n    \n      F\n      0.009\n      0.03626\n      -0.01960\n      9.75198\n      No\n    \n    \n      G\n      0.010\n      -0.01960\n      -0.01960\n      9.81960\n      Yes\n    \n    \n      H\n      0.014\n      0.08820\n      -0.02450\n      9.95582\n      No\n    \n    \n      J\n      0.015\n      0.01176\n      -0.03626\n      9.89800\n      Yes\n    \n    \n      K\n      0.017\n      -0.11270\n      -0.01960\n      9.81176\n      No\n    \n  \n\n\n\n\nYou may have noticed that sum method that was used to sum up each column. The keyword argument axis = 1 indicates that you want to sum over rows, not over columns. (axis = 0 would result in summing over columns.) There are a few other handy methods for common mathematical operations.\n\nmin() - Find the minimum value.\nmax() - Find the maximum value.\ncumsum() - Cumulative sum, just like in numpy.\nstd() - Standard deviation.\nmean() - Mean or average.\nquantile(q) - Find value of a give quantile q.\n\nThere are a multitude of other useful math functions available. See here for a more comprehensive list. Basically, any function that numpy has, pandas will also have."
  },
  {
    "objectID": "chapters/pandas.html#modifying-the-dataframe",
    "href": "chapters/pandas.html#modifying-the-dataframe",
    "title": "13  Pandas",
    "section": "13.4 Modifying the dataframe",
    "text": "13.4 Modifying the dataframe\n\n13.4.1 Adding new columns\nA new column can be added to a dataframe by typing dataframe[columnname] = followed by a list,tuple, or array containing the new entries. For example:\nelevator_data[\"a_mag\"]  = sqrt( (elevator_data[[\"gFx\", \"gFy\", \"gFz\"]]**2).sum(axis = 1))\n\n\n13.4.2 Adding a new row\nTo add a single (or multiple) rows to a dataframe you should use the concat() function (short for concatenate). This function will join multiple dataframes into one. Below is an example of the usage.\nfrom pandas import DataFrame,concat\n\nto_add = DataFrame({\" time-s\":0.02,\"gFx\":-0.028,\"gFy\":0.018,\"gFz\":1.028},index = [\"L\"]) # Build the dataframe to be added.\nfinal = concat([elevator_data,to_add])  # Append using a dictionary.\n\nelevator_data2 = DataFrame({\"time\":[0.02,0.025],\"gFx\":[-0.028,-0.022],\"gFy\":[0.018,-0.012],\"gFz\":[1.028,1.042]})\n\nfinal2 = concat([elevator_data,to_add,elevator_data2]) #Combine all three data frames into one."
  },
  {
    "objectID": "chapters/pandas.html#other-useful-methods",
    "href": "chapters/pandas.html#other-useful-methods",
    "title": "13  Pandas",
    "section": "13.5 Other useful methods",
    "text": "13.5 Other useful methods\n\n13.5.1 Getting a summary of your dataframe.\nThe describe() function will calculate several useful statistical quantities and display them in a dataframe.\n\nelevator_data.describe()\n\n\n\n\n\n  \n    \n      \n      time-s\n      gFx\n      gFy\n      gFz\n      a_mag\n    \n  \n  \n    \n      count\n      10.000000\n      10.000000\n      10.000000\n      10.000000\n      10.000000\n    \n    \n      mean\n      0.010600\n      0.005586\n      -0.015974\n      9.848706\n      9.848937\n    \n    \n      std\n      0.003438\n      0.060314\n      0.033201\n      0.059088\n      0.059124\n    \n    \n      min\n      0.007000\n      -0.112700\n      -0.054880\n      9.751980\n      9.752067\n    \n    \n      25%\n      0.008250\n      -0.018375\n      -0.033320\n      9.820090\n      9.820186\n    \n    \n      50%\n      0.009000\n      0.005880\n      -0.020580\n      9.834790\n      9.834958\n    \n    \n      75%\n      0.013000\n      0.048755\n      -0.019600\n      9.883790\n      9.883886\n    \n    \n      max\n      0.017000\n      0.088200\n      0.057820\n      9.955820\n      9.956241\n    \n  \n\n\n\n\n\n\n13.5.2 Plotting your dataframe.\nA histogram of each column can be easily generate with the dataframe.hist() function.\n\nelevator_data.hist()\n\narray([[<Axes: title={'center': ' time-s'}>,\n        <Axes: title={'center': 'gFx'}>],\n       [<Axes: title={'center': 'gFy'}>, <Axes: title={'center': 'gFz'}>],\n       [<Axes: title={'center': 'a_mag'}>, <Axes: >]], dtype=object)\n\n\n\n\n\nTo make a scatter plot of two columns in your dataframe, use dataframe.plot.scatter(). The x and y keyword arguments should be used to specify which columns to plot.\n\nelevator_data.plot.scatter(x = \" time-s\", y = \"gFz\")\n\n<Axes: xlabel=' time-s', ylabel='gFz'>\n\n\n\n\n\nYou can also plot a single column vs. the row labels using the plot function\n\nelevator_data[\"gFz\"].plot()\n\n<Axes: >\n\n\n\n\n\nYou can also use this function to plot a single row vs the column labels.\n\nelevator_data.iloc[2][[\" time-s\",\"gFx\",\"gFy\",\"gFz\"]].plot()\n\n<Axes: >\n\n\n\n\n\nA wealth of other functions exist for pandas and I will not exemplify or explain them here because it is beyond the scope of the class. A nice summary sheet for pandas can be found here\n\n\n13.5.3 Writing your dataframe to file\nYou have already used savetxt to save an entire array of numbers to a file in one step. If your data is in a pandas dataframe, saving that dataframe to file couldn’t be easier; just use dataframe.to_csv(\"filename\").\nelevator_data.to_csv(\"myelevatorData.csv\")\nSeveral helpful keyword arguments are available when writing to a file. I’ll list a few of them below.\n\nsep - Delimiter or character used to separate the data as a length-one string. Default is a comma (“,”).\ncolumns - specify which columns in your dataframe to write as a list of column labels.\nindex - True if you want the row labels written and False if you don’t\ncompression - specify the compression scheme as a string. Options are ‘zip’,‘gzip’, ‘bz2’,‘zstd’, and ‘tar’.\n\nDepending on the type of data you are working with, there is a good argument for always using to_csv to write data to file, never needing savetxt."
  },
  {
    "objectID": "chapters/pandas.html#flashcards",
    "href": "chapters/pandas.html#flashcards",
    "title": "13  Pandas",
    "section": "13.6 Flashcards",
    "text": "13.6 Flashcards\n\nHow does read_csv work? Give a short example.\nWhat is the keyword argument usecols used for when reading a dataframe from file?\nHow does the DataFrame function work and what type of arguments can you pass it? Give a few short examples.\nHow do you access/extract multiple columns in their entirety from a dataframe.\nHow do you access/extract multiple rows in their entirety from a dataframe.\nHow do you access/extract the middle part of a dataframe?\nHow do you access/extract only the numbers in a dataframe that meet a given criteria?\nHow do you add a new column to a dataframe?\nHow do you add a new row to a dataframe?\nRecite Mosiah 4:27."
  },
  {
    "objectID": "chapters/pandas.html#exercises",
    "href": "chapters/pandas.html#exercises",
    "title": "13  Pandas",
    "section": "13.7 Exercises",
    "text": "13.7 Exercises\n\nIn homework problem 3 from the chapter on dictionaries and sets, you built a dictionary containing planetary information for your top three favorite planets.\n\nCreate a dataframe from this dictionary.\nMake the name of the planet be the row label.\nWrite this dataframe to a csv file.\n\nIn homework problem 2 from the chapter on numpy, you calculated the moment of inertia for 1000 different objects.\n\nCreate a dataframe out of the mass, radius, length, and inertia data. The dataframe should have four columns and 1000 rows.\nUse describe to get a summary of the data.\nWrite the data to a .csv file and inspect the file to ensure that you did it correctly.\n\nIn homework problem 3 from the chapter on I/O, you read planetary data into a .csv file using genfromtxt.\n\nRead the same file into a dataframe using read_csv. Let the name of the planets be the row label and the physical property be the column label.\nThe sixth column contains the acceleration due to gravity for all of the planets in units of m/s\\(^2\\). Recalculate these values to be in terms of earth’s value (\\(g = 9.78\\) m/s\\(^2\\)) and modify the sixth column.\nThe seventh column contains the orbital period for all of the planets in units of earth years. Recalculate these values to be in earth days and modify that column accordingly.\nAdd a new column labeled “Surface Temperature” that contains the surface temperature for each planet in Kelvins as given here.\nAdd a new row for a hypothetical planet (“planet X”) and set its physical properties equal to the average of the other 9 planets that are already in the dataframe.\nDetermine which planets have an acceleration due to gravity that is less than earth’s value ($9.8 $ m/s\\(^2\\))\nDetermine which planets have an eccentricity that is greater than \\(0.04\\).\nDetermine which planet(s) have an inclination greater than \\(1.5^\\circ\\) and have 10 or more satellites.\nWrite the a .csv file containing the following columns in the dataframe: “Name”, “SurfaceGravity”, “OrbitalPeriod”, and “Satellites”.\nWrite the entire dataframe to a separate file.\n\nHints:\n\nFor part 5 you will want to use describe to generate a dataframe of summary statistics. Then use append to add the row labeled “mean” to your original planetary database. Then use rename to rename that row from mean to Planet X.\n\nThe column label for the acceleration due to gravity start with a space: ” SurfaceGravity” not “SurfaceGravity”.\nFor part 8 use query. To include the space in the column names, enclose the name in backticks “`”. (i.e. ” Inclination > 0.04”)"
  },
  {
    "objectID": "chapters/sympy.html",
    "href": "chapters/sympy.html",
    "title": "14  The sympy module",
    "section": "",
    "text": "Jupyter Notebook\nSympy (pronounced “sim-pie”) is short for symbolic python and can be used to do symbolic math calculations. You may be familiar with other symbolic math packages like Mathematica or Maple. Python’s sympy package will do all of the same things that they will do and it’s nice to not have to switch between two different coding languages."
  },
  {
    "objectID": "chapters/sympy.html#simple-calculations",
    "href": "chapters/sympy.html#simple-calculations",
    "title": "14  The sympy module",
    "section": "14.1 Simple Calculations",
    "text": "14.1 Simple Calculations\nYou should be very comfortable performing simple calculations by now. Up to this point all of the calculations that you have performed have been represented approximately, rather than exactly. For example, \\(\\cos({\\pi \\over 6}) = {\\sqrt{3} \\over 2} \\text{ (exact)} \\approx 0.8660254 \\text{ (approximate)}\\) and when you perform this calculation in Python using the math module, the result is approximate:\n\nfrom math import cos,pi\n\ncos(pi/6)\n\n0.8660254037844387\n\n\n\\(0.8660254\\) is an approximate result; it’s very close to the true value but not exact. Sympy can also perform this calculation and the results are represented exactly.\n\nfrom sympy import cos,pi,init_printing\ninit_printing(use_unicode = True)\n\ncos(pi/6)\n\n\n\n\nThe init_printing(use_unicode=True) function call tells sympy to display mathematical expressions using “pretty” formatting. Fraction appear with the numerator on top of the denominator, powers are displayed as superscripts, and other mathematical symbols are rendered to make the mathematical expression look right. Sympy can even simplify expressions. For example, \\(\\sqrt{8} = 2 \\sqrt{2}\\) and sympy automatically performs this simplification for us:\n\nfrom sympy import sqrt\n\nsqrt(8)\n\n\n\n\nIf you prefer to have your expression approximated numerically, you can use the N function.\n\nfrom sympy import sqrt,N\n\nN(sqrt(8))"
  },
  {
    "objectID": "chapters/sympy.html#forming-mathematical-expressions",
    "href": "chapters/sympy.html#forming-mathematical-expressions",
    "title": "14  The sympy module",
    "section": "14.2 Forming Mathematical Expressions",
    "text": "14.2 Forming Mathematical Expressions\n\n14.2.1 Defining Symbols (Mathematical Variables)\nA common equation that comes up in physics is quadratic function with constant coefficients \\[ax^2 + bx + c\\]. To form this expression, we must first define the variables that appear in the expression: x, a, b, and c. The Symbol function (case sensitive) can be used to define these mathematical variables. The argument to the Symbol function should be a string containing the desired name of the variable.\n\nfrom sympy import Symbol\nx = Symbol(\"x\")\na = Symbol(\"a\")\nb = Symbol(\"b\")\nc = Symbol(\"c\")\nx,a,b,c\n\n\n\n\nInstead of using the Symbol function to initialize variables one at a time, you can initialize multiple variables in one line using the symbols function. The argument to the symbols function should be a string with the names of each variables inside the string and separated by a space.\n\nfrom sympy import symbols\n\nx,a,b,c = symbols(\"x a b c\")\nx,a,b,c\n\n\n\n\n\n\n14.2.2 Mathematical Expressions\nA mathematical expression, which is composed of multiple mathematical variables (symbols), can now be created using the python variables that we just created\n\nfrom sympy import Symbol\nx,a,b,c = symbols(\"x a b c\")\nexpression = a * x**2 + b * x + c\nexpression\n\n\n\n\nExpressions can be used to form new expressions by performing mathematical operations on them\n\nfrom sympy import symbols\n\nx,a,b,c = symbols(\"x a b c\")\nexpression = a * x**2 + b * x + c\n\nnewexpression = x * expression\nnewexpression"
  },
  {
    "objectID": "chapters/sympy.html#simplifying-expressions",
    "href": "chapters/sympy.html#simplifying-expressions",
    "title": "14  The sympy module",
    "section": "14.3 Simplifying Expressions",
    "text": "14.3 Simplifying Expressions\nsympy has several handy functions that can perform algebraic manipulations to your expressions. Below you will find some of the most useful functions for simplifying expressions.\n\n14.3.1 Evaluating expressions\nOnce an expression is defined, you can evaluate the expression using the subs method. The argument to this method is a dictionary containing the values to be inserted for the associated variables. An example is given below\n\nfrom sympy import symbols\n\nx,a,b,c = symbols(\"x a b c\")\nexpression = a * x**2 + b * x + c\n\nevalDict ={a:2,b:4,c:9,x:4}\nexpression.subs(evalDict)\n\n\n\n\n\n\n14.3.2 The simplify function\nIf you don’t know exactly how you want your expression simplified, you should first try the simplify function. simplify attempts to apply all of the more specialized functions in a smart way to produce a simpler looking result. To use simplify simply send the desired expression in as an argument.\nsimplify(expression)\n\nfrom sympy import symbols,cos,sin,simplify\nx,y,z = symbols(\"x y z\")\nsimplify(x**2 * z + 4 * x *y*z + 4*y**2*z)\nsimplify(cos(x)**2 + sin(x)**2)\n\n\n\n\nWhen simplify doesn’t do what you were hoping, you’ll have to think a little bit harder about how you want to simplify your expression. The functions described in the rest of this section will help you in your choice.\n\n\n14.3.3 The expand function\nThe expand function will put a polynomial function into its canonical monomial form. For example, expanding the following polynomial \\[(x + 1)^2\\] will produce the standard form of the polynomial \\[x^2 + 2x + 1\\]. This may not seem like a simplification but nevertheless it can be helpful at times. To expand a polynomial, call the expand function and send in the expression that you want expanded.\nexpand(expression)\n\nfrom sympy import symbols,expand\nx = symbols(\"x\")\nexpand((x + 2) * (x - 3))\nexpand((x+3)**2)\n\n\n\n\nSometimes expanding an expression can result in a single number due to cancellation.\n\nfrom sympy import Symbol,expand\nx = Symbol(\"x\")\nexpand((x + 1)*(x - 2) - (x - 1)*x)\n\n\n\n\n\n\n14.3.4 The factor function\nThe factor function does the opposite of expand, taking a canonical polynomial and attempting to factor it into its irreducible parts. For example, factoring the equation below \\[x^3 - x^2 + x -1\\] will produce \\[(x-1)(x^2 + 1)\\]\n\nfrom sympy import symbols,factor\nx,y,z = symbols(\"x y z\")\nfactor(x**2 * z + 4 * x *y*z + 4*y**2*z)\n\n\n\n\nYou can also factor an expression that isn’t a polynomial. The following trigonometric function can be factored \\[\\cos(x)^2 + 2 \\cos(x)\\sin(x) + \\sin(x)^2\\] into \\[(\\sin(x) + \\cos(x))^2\\]\n\nfrom sympy import symbols,factor,cos,sin\nx,y,z = symbols(\"x y z\")\nfactor(cos(x)**2 + 2 * cos(x) * sin(x) + sin(x)**2)\n\n\n\n\n\n\n14.3.5 The collect function\nThe collect function gathers terms with common powers in an expression. The function takes two arguments: the first is the expression and the second specifies which variable’s powers should be collected.\ncollect(expression, variable)\n\nfrom sympy import symbols,collect\nx,y,z = symbols(\"x y z\")\ncollect(x*y + x - 3 + 2 * x**2 - z *x**2 + x**3,x)\n\n\n\n\n\n\n14.3.6 The cancel function\nThe cancel function is helpful for simplifying an expression by canceling out like terms where possible. This function takes just a single argument, which is the expression to be simplified. The code below will simplify the following expression by canceling the common (x+1) that appears in both the numerator and denominator. \\[{x^2 + 2 x + 1 \\over x^2 + x}\\]\n\nfrom sympy import symbols,cancel\nx,y,z = symbols(\"x y z\")\ncancel((x**2 + 2*x + 1)/(x**2 + x))\n\n\n\n\n\n\n14.3.7 The trigsimp function\nIf you want to use trigonometric identities to simplify your expression use the trigsimp function. For example, most of us know that \\(\\cos(x)^2 + \\sin(x)^2 = 1\\). trigsimp will perform this simplification for us.\n\nfrom sympy import symbols,trigsimp,cos,sin\nx = symbols(\"x\")\ntrigsimp(cos(x)**2 + sin(x)**2)\n\n\n\n\n\n\n14.3.8 The expand_trig function\nexpand_trig is the opposite of trigsimp and usually makes trig functions longer, but that can still be a useful way to view the function. Below we expand the expression \\[\\sin(x + y)\\] using a trig identity.\n\nfrom sympy import symbols,expand_trig\nx,y = symbols(\"x y\")\nexpand_trig(sin(x + y))"
  },
  {
    "objectID": "chapters/sympy.html#calculus",
    "href": "chapters/sympy.html#calculus",
    "title": "14  The sympy module",
    "section": "14.4 Calculus",
    "text": "14.4 Calculus\nsympy can do common calculus operations on symbolic expressions. We’ll cover: derivatives, integrals, and limits.\n\n14.4.1 Derivatives\nTo calculate the derivative of an expression, use the diff function, which takes two arguments. The first is the expression that you want to take the derivative of and the second is the differentiating variable. In the cell below we calculate the derivative \\[{d\\over dx} \\cos(x)\\]\n\nfrom sympy import symbols,diff,cos\nx = symbols(\"x\")\ndiff(cos(x),x)\n\n\n\n\nTo take multiple derivatives, simply add more xs to the diff function call. Below we calculate the derivative \\[{d^2\\over dx^2} \\cos(x)\\]\n\nfrom sympy import symbols,diff,cos\nx = symbols(\"x\")\ndiff(cos(x),x,x)\n\n\n\n\ndiff can perform partial derivatives too. Below we perform the following partial derivatives \\[{\\partial^2 \\over \\partial z^2} {\\partial \\over \\partial y} {\\partial \\over \\partial x} \\exp(x y z)\\]\n\nfrom sympy import symbols,diff,exp\nx,y,z = symbols(\"x y z\")\ndiff(exp(x * y * z),x,y,z,z)\n\n\n\n\nA differentiated function is a sympy expression just as good as any other and we can make a plot of it by evaluating the expression over a grid of values.\n\nfrom sympy import symbols,diff\nimport numpy as np\nimport matplotlib.pyplot as plt\nx,a,b,c = symbols(\"x a b c\")\nexpression = a * x**2 + b * x + c\n\nnewexpression = diff(expression,x)\nxarray = np.arange(0,5,0.1)\ny = [expression.subs({a:-2,b:4,c:9,x:X}) for X in xarray]\nyprime = [newexpression.subs({a:-2,b:4,c:9,x:X}) for X in xarray]\nplt.plot(xarray,yprime,'r.-',label= \"y'(x)\")\nplt.plot(xarray,y,'b.-',label= \"y(x)\")\nplt.legend()\nplt.grid()\nplt.show()\n\n\n\n\n\n\n14.4.2 Integrals\nUse the integrate function to perform definite and indefinite integrals. For definite integral, the function should be called with two arguments; the first is the expression to be integrated and the second is the tuple containing the integration limits. Below we integrate \\[ \\int_0^5 \\exp(-x) dx\\]\n\nfrom sympy import integrate, Symbol\n\nx = Symbol(\"x\")\n\nintegrate(exp(-x),(x,0,5))\n\n\n\n\nThe limits of your integral can be at infinity by importing oo and using it in the limit specification.\n\nfrom sympy import integrate, Symbol,oo\n\nx = Symbol(\"x\")\n\nintegrate(exp(-x),(x,0,oo))\n\n\n\n\nMultiple integrations can be carried out by adding more arguments to the integrate function, each one specifying the limits for that variable. Here we integrate \\[\\int_0^\\infty \\int_0^\\infty \\exp(-x^2 -y^2) dx dy \\]\n\nfrom sympy import integrate, symbols,oo\n\nx,y = symbols(\"x y\")\n\nintegrate(exp(-x**2 - y**2),(x,0,oo),(y,0,oo))\n\n\n\n\nIndefinite integrals can be performed by omitting the limit specification and just indicating the variable to be integrated over. Below we perform the following indefinite integral \\[\\int \\int x^2 + y^2 dx dy \\]\n\nfrom sympy import integrate, symbols\n\nx,y = symbols(\"x y\")\n\nintegrate(x**2 + y**2,x,y)\n\n\n\n\n\n\n14.4.3 Limits\nsympy can compute limits symbolically with the limit function. The function takes three arguments: the expression, the variable of interest, and the limiting value for that variable. Below we take the following limit \\[\\lim_{x \\to 0} {\\sin(x)\\over x}\\]\n\nfrom sympy import limit, Symbol,sin\n\nx = Symbol(\"x\")\n\nlimit(sin(x)/x,x,0)"
  },
  {
    "objectID": "chapters/sympy.html#solving-equations",
    "href": "chapters/sympy.html#solving-equations",
    "title": "14  The sympy module",
    "section": "14.5 Solving equations",
    "text": "14.5 Solving equations\nSo far we have seen how to construct expressions but not solve equations. The difference is that an equation is expressing some sort of equality between an multiple expressions. For example, the following is an equation \\[5 x^2 + 3 x - 2 = 10\\] To form an equation, you can use the Eq function. To use it, send in the expression on the left hand side of the equation for the first argument and the expression on the right hand side of the equation for the second argument.\nEq(lhs,rhs)\nBelow we form the equation \\[5 x + 2y = 8\\]\n\nfrom sympy import symbols,Eq\n\nx,y = symbols(\"x y\")\n\nequation = Eq(5 * x + 2 * y , 8)\nequation\n\n\n\n\n\n14.5.1 Solving single equations\nOnce an equation is created, the solveset function attempts to solve the function for the desired variables. To use solveset, pass the equation as the first argument and the variable being solved for as the second. Here we solve the equation \\[3 x^2 - 5 x =8\\] for \\(x\\)\n\nfrom sympy import symbols,Eq,solveset\n\nx = symbols(\"x\")\n\nequation = Eq(3* x**2 - 5 * x, 8)\nsolveset(equation,x)\n\n\n\n\n\n14.5.1.1 No analytic solution\nIn some instances, sympy will not be able to find any solutions to the equation. For example, the solution to \\[{\\sin(x)\\over x} = 1\\] cannot be determined through analytical technique even though there are values of x that solve the equation. For situations like this, sympy will output an expression that is meant to indicate that it can’t find a solution.\n\nfrom sympy import symbols,Eq,solveset,sin\n\nx = symbols(\"x\")\n\nequation = Eq(sin(x)/x, 1)\nsolveset(equation,x)\n\n\n\n\n\n\n14.5.1.2 No solution… period\nSome equations really don’t have solutions and sympy can correctly identify these cases. For example, the equation \\[\\exp(x) = 0\\] has no solutions. Let’s see what sympy tells us when we try to solve this one.\n\nfrom sympy import symbols,Eq,solveset,exp\n\nx = symbols(\"x\")\n\nequation = Eq(exp(x), 0)\nsolveset(equation,x)\n\n\n\n\nThe \\(\\emptyset\\) symbol means an empty set or there are no solutions to this equation.\n\n\n14.5.1.3 Many or Infinite Solutions\nSome equations have infinitely many solutions. For example the following equation \\[x - x = 0\\] is satisfied for any complex or real value of \\(x\\). Let’s see what sympy does when we ask it to solve this one.\n\nfrom sympy import symbols,Eq,solveset\n\nx = symbols(\"x\")\n\nequation = Eq(x-x, 0)\nsolveset(equation,x)\n\n\n\n\nThe output (\\(\\mathbb{C}\\)) is communicating that the set of all complex numbers are the solution to this equation. (Meaning you can choose any number and it will be a solution to this equation.)\n\n\n\n14.5.2 Solving Systems of equations\nOften you will have multiple equations with multiple unknown variables that you want to solve for. They call this a system of equations. An example would be the following system \\[3 x - 5 y = 8\\] \\[8x + 2y = 3\\]. The normal process for solving this system is to solve one equation for \\(x\\) and then plug the expression that results into the other equation. That equations will only have \\(y\\) as a variable and you can do algebra to solve for it.\n\n14.5.2.1 Linear Systems\nThe example given above is called a linear system because none of the variables are raised to a power. To solve a system like this, use sympy’s linsolve function.\n\nfrom sympy import symbols,Eq,linsolve\n\nx,y = symbols(\"x y\")\n\nequationOne = Eq(3* x - 5 * y, 8)\nequationTwo = Eq(8* x + 2 * y, 3)\nlinsolve([equationOne,equationTwo],(x,y))\n\n\n\n\nIt isn’t hard to find a system of equations that doesn’t have a solution. \\[12 x - 3 y = 8\\] \\[8x - 2y = 3\\] As with single equations, sympy will indicate this with the empty set symbol (\\(\\emptyset\\)).\n\nfrom sympy import symbols,Eq,linsolve\n\nx,y = symbols(\"x y\")\n\nequationOne = Eq(12* x - 3 * y, 8)\nequationTwo = Eq(8* x - 2 * y, 3)\nlinsolve([equationOne,equationTwo],(x,y))\n\n\n\n\n\n\n14.5.2.2 Nonlinear Systems\nIf the equations involve variables being raised to powers, we call it a non linear system and you must use sympy’s nonlinsolve to solve the system. For example, here is a nonlinear system \\[3 x^2 + 5 y^2 = 8\\] \\[8x^2 - 12y^2 = 13\\]\n\nfrom sympy import symbols,Eq,nonlinsolve\n\nx,y = symbols(\"x y\")\n\n\neqOne = Eq(3*x**2 + 5*y**2,8)\neqTwo = Eq(8*x**2 - 12*y**2,13)\nnonlinsolve([eqOne,eqTwo],(x,y))"
  },
  {
    "objectID": "chapters/sympy.html#flashcards",
    "href": "chapters/sympy.html#flashcards",
    "title": "14  The sympy module",
    "section": "14.6 Flashcards",
    "text": "14.6 Flashcards\n\nHow do you define a mathematical variable in Python?\nHow do you form a mathematical expression in Python? (Give an example)\nHow do you form a mathematical equation in Python? (Give an example)\nWhat does the simplify function do?\nWhat does the factor function do?\nHow do you perform a derivative in Python?\nHow do you perform an integral in Python? (definite and indefinite)\nHow do you solve an equation in Python?\nHow do you solve a system of equations in Python?\nHow do you evaluate a definite integral at infinity (\\(\\infty\\))?\nRecite 1 Ne 4:6"
  },
  {
    "objectID": "chapters/sympy.html#exercises",
    "href": "chapters/sympy.html#exercises",
    "title": "14  The sympy module",
    "section": "14.7 Exercises",
    "text": "14.7 Exercises\n\nDefine a sympy variable for \\(x\\) and then evaluate the following expressions.\n\n\\(\\sin(x + {\\pi \\over 2})\\)\n\\(\\sin(x + \\pi)\\)\n\n\\(\\cos(x + {\\pi \\over 2})\\)\n\\(\\cos(x + \\pi)\\)\n\\(\\sin(-x)\\)\n\n\\(\\cos(-x)\\)\n\\(\\sqrt{1 - \\sin(x)^2}\\)\n\n\n# Python code here\n\nA projectile is thrown directly downward from the top of a tall building (\\(y_i = 150\\) meters) and lands with a thud on the ground (\\(y_f = 0\\)) \\(4\\) seconds later. The position equation for the projectile is \\[y_f = y_i + v_i \\Delta t + {1\\over 2} g \\Delta t^2\\] Use sympy to solve this equation for the initial velocity. Note \\(g = 9.8\\) m/s\\(^2\\) Answer: You should find the initial speed to be \\(\\approx 18\\) m/s\n\n# Python code here\n\nA projectile is launched from the top of a building (\\(y_i = 23\\) m) with an initial speed of \\(v_i = 60\\) m/s and a launch angle of \\(\\theta_i = 32^\\circ\\). The vertical position of the projectile is given by \\[y_f = y_i + v_i \\sin \\theta_i \\Delta t - {1\\over 2}g \\Delta t^2\\]. Determine the time it takes before the projectile impacts the ground by solving this equation for \\(\\Delta t\\).\n\n# Python code here\n\nAn elastic collision is one where the total energy of the particles is the same before and after the collision. The equations that define an elastic collision where one of the objects is initially at rest are \\[{1\\over 2} m_1 (v_1)_i^2 = {1\\over 2} m_1 (v_1)_f^2 +{1\\over 2} m_2 (v_2)_f^2\\] \\[m_1 (v_1)_i = m_1 (v_1)_f  + m_2 (v_2)_f\\]. Consider a situation where particle 1 (\\(m_1 = 5 \\text{ kg}\\)) is initially moving to the right with speed \\((v_1)_i = 10 \\text{ m/s}\\) and particle 2 is stationary (\\(m_2 = 2 \\text{ kg}\\)). Solve this system of equations for\\((v_1)_f\\) and \\((v_2)_f\\). Do the results make sense? Then do the following\n\nMake \\(m_2\\) greater than \\(m_1\\). What do you expect will happen. Verify that the results match your guess.\n\nMake the mass of particle 2 much greater than particle 1. What do you expect will happen? Verify that the results match your guess.\nMake the mass of particle 1 much greater than particle 2. What do you expect will happen? Verify that the results match your guess.\n\n\n# Python code here\n\nDefine a sympy variable for \\(x\\) and then calculate the following derivatives:\n\n\\({d\\over dx} \\ln(x)\\)\n\\({d\\over dx} e^{5x^2}\\)\n\\({d\\over dx} \\cos(3 x^3)\\)\n\\({d\\over dx} (x^3 - 5x^2 + 10 x)\\)\n\n\n# Python code here\n\nImpulse is defined as the integral of the Force vs. time graph. \\[I = \\int F dt\\]. Calculate the impulse imparted to an object from \\(0< t < 10\\) if the force that it experiences is given by \\[F(t) = e^{-(t - 4)}\\].\n\n# Python code here"
  },
  {
    "objectID": "chapters/rootFinding.html",
    "href": "chapters/rootFinding.html",
    "title": "15  Root Finding and Optimization Algorithms",
    "section": "",
    "text": "Jupyter Notebook\nOften in science, we find ourselves wanting to do one of the following: (See figure below)\nThese skills are routinely covered in an algebra class but often the equation we encounter cannot be solved using standard algebraic techniques. Instead we have to resort to a class of numerical algorithms generally referred to as root finding or optimization algorithms. In the remainder of this chapter we will discuss various numerical methods for finding the roots of an equation. The algorithms described below can be used to perform any of the tasks mentioned above."
  },
  {
    "objectID": "chapters/rootFinding.html#bisection",
    "href": "chapters/rootFinding.html#bisection",
    "title": "15  Root Finding and Optimization Algorithms",
    "section": "15.1 Bisection",
    "text": "15.1 Bisection\n\n\n\nUsed with permission from: https://commons.wikimedia.org/wiki/File:Bisection_method.svg\n\n\nThe bisection method finds the roots of a function by iteratively narrowing the interval where the zero is found until the interval becomes sufficiently small. If you want to find the location where the function equals something other than zero, you can simply rearrange the function until a zero appears on the right hand side of the equation and proceed with bisection on the new function. To begin the bisection method, the user must choose an interval wherein the function zero is guaranteed to be found. The midpoint of the interval is then found and a new, narrower interval is chosen. By repeating this process until the interval becomes sufficiently small, the algorithm eventually finds the location where the function is equal to zero. The steps to the algorithm are as follows:\n\nChoose an interval wherein the function zero is certain to be located. Call the interval \\((a,b)\\)\nCalculate the midpoint of the interval \\(c = {a+ b \\over 2}\\)\nCalculate the function value at the midpoint (\\(f(c)\\)).\nBy examining the sign of \\(f(c)\\) determine whether the interval \\((a,c)\\) or \\((c,b)\\) contains the zero of the function.\nRepeat steps 2-4 until \\(f(c)\\) is sufficiently small.\n\nIn the code cell below, try to use the bisection method to solve the following equation.\n\\[\ny(x) = 5 x^2 - 3x - 2 = 0\n\\]\n# Code here"
  },
  {
    "objectID": "chapters/rootFinding.html#newtons-method",
    "href": "chapters/rootFinding.html#newtons-method",
    "title": "15  Root Finding and Optimization Algorithms",
    "section": "15.2 Newton’s Method",
    "text": "15.2 Newton’s Method\n\n\n\nUsed with permission from: https://commons.wikimedia.org/wiki/File:Newton_iteration.svg\n\n\nNewton’s method uses the slope of the function to estimate a better approximation to the function’s zero. To understand how we can use the slope to approximate the zero, first let’s write down an approximation to the slope of a function \\(f(x)\\).\n\\[\nf'(x_0) \\approx {f(x_1) - f(x_0) \\over x_1 - x_0}\n\\]\nIf the slope of the function were a constant, we could simply set \\(f(x_1) = 0\\) and solve for \\(x_1\\) and we would be done.\n\\[\nx_1 = x_0 - {f(x_0)\\over f'(x_0)}\n\\]\nIn reality, the function will not have a constant slope but this equation will still get us closer to the zero than we were originally. (see figure) By repeatedly evaluating the equation above, always using the most recent estimate as \\(x_0\\), until \\(f(x_0)\\) becomes sufficiently small, the location where the function is zero can be found.\n\\[\nx_{n+1} = x_n - {f(x_n)\\over f'(x_n)}\n\\]\nTo begin the algorithm, the user must choose an initial guess for the zero that isn’t very far away from the true value. An improvement on this initial guess is calculated using the equation above where \\(f'(x_n)\\) is the derivative of the function evaluated at the current guess. The algorithm continues with repeated evaluation of the equation above until \\(f(x_n)\\) evaluates to a sufficiently small number.\nBelow you will find a code example for solving the following equation:\n\\[\ny(x) = \\cos(x) = 0\n\\]\n\nimport numpy as np\n\nx = 2.3\n\nwhile abs(np.cos(x)) > 1e-5:\n  x = x + np.cos(x)/np.sin(x) \n\nprint(x,np.cos(x))\n\n1.5707963256833193 1.1115773359029342e-09\n\n\nIf the function of interest has multiple zeros (like the cosine function we did above), one must give careful consideration to the initial guess. Making a poor choice can lead to the algorithm finding a different zero than what was intended."
  },
  {
    "objectID": "chapters/rootFinding.html#fixed-point-iteration",
    "href": "chapters/rootFinding.html#fixed-point-iteration",
    "title": "15  Root Finding and Optimization Algorithms",
    "section": "15.3 Fixed-Point Iteration",
    "text": "15.3 Fixed-Point Iteration\n\n\n\nUsed with permission from: https://commons.wikimedia.org/wiki/File:Cosine_fixed_point.svg\n\n\nFixed-point iteration is another algorithm for finding function zeros. To begin, the function of interest must be rearranged to look similar to the function below.\n\\[\nx = \\cos(x)\n\\]\nAs opposed to the alternate form:\n\\[\ny(x) = x - \\cos(x) = 0\n\\]\nIf the function cannot be manipulated to look like the form above, it is not a good candidate for the fixed-point iteration method. Once the equation is in this form, the user must choose an initial guess for the zero just as with the other algorithms. The algorithm then proceeds by using the initial guess to evaluate the right hand side of the equation. This process repeats with the new guess always being used to evaluate the function until \\(|x - \\cos(x)|\\) is sufficiently small. The equation given above is an example of a transcendental equation, or an equation that cannot be solved using algebraic techniques. No matter how hard you try, you’ll never come up with an expression that solves this equation.\nThe code cell below shows the fixed-point iteration algorithm used to find the zeros of the function mentioned above: \\(x = \\cos(x)\\)\nimport numpy as np\nx = 3\ncount = 0\nwhile abs(x - np.cos(x)) > 1e-5:\n  x = np.cos(x)\n  count += 1\nTo find the zeros of a function that is not in the form: \\(x = f(x)\\), you must first algebraically manipulate the equation to take this form. For example, the following equation\n\\[\n2x^3 - 2 x - 5 =0\n\\]\nIs equivalent to:\n\\[\nx = (x+{5\\over 2})^{1\\over 3}\n\\]\nAnd the fixed-point iteration algorithm can now be used to solve for \\(x\\):\nimport numpy as np\nx = 3\ncount = 0\nwhile abs(x - (x+5/2)**(1/3)) > 1e-8:\n    x = (x+5/2)**(1/3)\n    count += 1\n    if count > 10000:\n        break"
  },
  {
    "objectID": "chapters/rootFinding.html#finding-extrema",
    "href": "chapters/rootFinding.html#finding-extrema",
    "title": "15  Root Finding and Optimization Algorithms",
    "section": "15.4 Finding Extrema",
    "text": "15.4 Finding Extrema\nAny of the methods discussed above can be used to find extrema by finding the zeros of the derivative. For example, to find the minimum of this function:\n\\[\ny(x) = 5 x^3 - 2x^2 - 8 x + 2\n\\]\nWe can find the zeros of the derivative function:\n\\[\ny'(x) = 15 x^2 - 4 x - 8\n\\]\nAnd then used fixed-point iteration, or any of the other methods discussed, to solve this equation for \\(x\\):\n\nimport numpy as np\nx = 3\ncount = 0\nwhile abs(x - np.sqrt(4/15 * x + 8/15)) > 1e-8:\n    x = np.sqrt(4/15 * x + 8/15)\n    count += 1\n    if count > 10000:\n      print(\"Too many iterations. Results may not be correct!\")\n      break\nprint(x)\n\n0.8757019168612669"
  },
  {
    "objectID": "chapters/rootFinding.html#exercises",
    "href": "chapters/rootFinding.html#exercises",
    "title": "15  Root Finding and Optimization Algorithms",
    "section": "15.5 Exercises",
    "text": "15.5 Exercises\n\nUse the bisection method to find the zeros of the function \\[ y(x) = 8x^3 - 15 x^2 - 4 x + 5\\] Hint: This function has three zeros; one in the region [-1,0], one in the region [0,1] and another in the region [1.5,2.5]\n\n# Code Here\n\nUse Newton’s method to find the zero for the following function (slightly different from the one in problem 1) \\[y(x) = 8x^3 - 15 x^2 - 4 x - 5\\] then use sympy to solve the equation and verify that the answer are the same.\nAnswer: You should find that the zero is located at \\(\\approx 2.2257\\)\nHint: The derivative of this function is:\n\n\\[\ny'(x) = 24 x^2 - 20 x - 4\n\\]\n# Code Here\n\nUse fixed-point iteration to solve the following equation\\[\\left({1\\over 2}\\right)^x = x^2\\]\n\n# Code Here\n\nUse Newton’s method to solve the following equation \\[e^x = \\cos(x)\\] Note: This function has three solutions; one in the region [-5,-4], one in the region [-2,-1] and another in the region [-1,1]. See if you can find all of them by varying your initial guess.\n\n# Code Here\n\nUse a method of your choosing to find the minimum of the function \\[y(x) = 10 x^2 \\cos(\\sqrt{x})\\] Hint: If you choose to use the bisection method, you’ll need the first derivative of this function. If you choose to use Newton’s method, you’ll need the first and second derivatives of this function. Both of these functions are given below.\n\n\\[\ny'(x) = 20 x \\cos(\\sqrt{x}) - 5 x^{3/2} \\sin(\\sqrt{x})\n\\]\n\\[\ny''(x) = 20 \\cos(\\sqrt{x}) - {5\\over 2} x \\cos(\\sqrt{x}) - {35\\over 2} \\sqrt{x} \\sin(\\sqrt{x})\n\\]\n# Code Here"
  },
  {
    "objectID": "chapters/extrapolation_interpolation.html",
    "href": "chapters/extrapolation_interpolation.html",
    "title": "16  Extrapolation and Interpolation",
    "section": "",
    "text": "Jupyter Notebook\nBy now we should be comfortable with representing mathematical functions on discrete grids. For example, the plot below is the location of a projectile as it flies through the air at 11 discrete points in time (red dots). There will be times when we want to find good values of a function between grid points (blue dot) or beyond the last grid point (green dot). The former is called interpolation and the latter is called extrapolation. In this chapter we will learn how to do both."
  },
  {
    "objectID": "chapters/extrapolation_interpolation.html#linear-interpolation-and-extrapolation",
    "href": "chapters/extrapolation_interpolation.html#linear-interpolation-and-extrapolation",
    "title": "16  Extrapolation and Interpolation",
    "section": "16.1 Linear Interpolation and Extrapolation",
    "text": "16.1 Linear Interpolation and Extrapolation\nThe simplest way to estimate function values is to assume that the function is linear in the neighborhood of the data points. Using the fact that two points define a straight line will allow us to write a linear approximation to the function. For example, suppose that we have function values \\((x_1,y_1)\\) and \\((x_2,y_2)\\), as shown in the figure below.\n\n\n\n\n\n\nIllustration of linear interpolation/extrapolation. The red dots are the known function values. The lack dot is an interpolation and the green dot is an extrapolation.\n\n\n\n\n\nThe formula for a straight line that passes through these two points is\n\\[\ny-y_1 = { (y_2-y_1) \\over (x_2-x_1) } (x-x_1)\n\\]\nSolving this for \\(y\\) gives\n\\[\ny(x) = y_1 + { (y_2-y_1) \\over (x_2-x_1) } (x-x_1)\n\\tag{16.1}\\]\nThis function provides a good approximation to the true function \\(y(x)\\) in the neighborhood of the two data points. All we have to do is evaluate it for any \\(x\\) we please. If we evaluate it in between two data points we call it interpolation and if we evaluate it somewhere beyond the last data point we call it extrapolation.\n\n16.1.1 Linear Interpolation\nTo linearly interpolate or extrapolate we simply evaluate the equation above at \\(x\\) values between or beyond \\(x_1\\) and \\(x_2\\).\nLet’s evaluate the function above halfway in between two grid points: \\(x = x_1 + {1\\over 2} (x_2 - x_1)\\) \\[\\begin{align}\ny(x_1 + {1\\over 2} (x_2 - x_1)) &= y_1 + { (y_2-y_1) \\over (x_2-x_1) } (x_1 + {1\\over 2} (x_2 - x_1)-x_1) \\\\\n&= y_1 + { (y_2-y_1) (x_2 - x_1) \\over 2(x_2-x_1) } \\\\\n&= y_1 + {1\\over 2} (y_2-y_1) \\\\\n\\end{align}\\]\nThat’s a pretty cool result that we can generalize to\n\\[\ny(x_1 + ph) = y_1 + p (y_2-y_1)\n\\tag{16.2}\\]\nwhere p is a fraction of the grid spacing.\n\n\n16.1.2 Linear Extrapolation\nNow let’s evaluate the equation above beyond the last grid point at \\(x_2 + h\\) where \\(h = (x_2 - x_1)\\) is the grid spacing.\n\\[\n\\begin{align}\ny(x_2 + (x_2 - x_1)) &= y_1 + { (y_2-y_1) \\over (x_2-x_1) } (x_2 + (x_2 - x_1)-x_1) \\\\\n&= y_1 + { (y_2-y_1) (2x_2 - 2x_1) \\over (x_2-x_1) } \\\\\n&= y_1 + 2 (y_2-y_1) \\\\\n&= 2 y_2 - y_1\n\\end{align}\n\\tag{16.3}\\]\n\n\n16.1.3 Zero Finding\nSometimes you will want to find the x value that produces \\(y(x) = 0\\). We call that finding the zero of the function. We can do this by setting \\(y =0\\) in (Equation 16.1) and solving for x:\n\\[\n\\begin{align}\n0 &= y_1 + {y_2 - y_1 \\over x_2 - x_1} (x - x_1)\\\\\n-y_1 & = {y_2 - y_1 \\over x_2 - x_1} (x - x_1)\\\\\n-{y_1 (x_2 - x_1)\\over y_2 - y_1} &= x - x_1\\\\\nx_1 - {y_1 (x_2 - x_1)\\over y_2 - y_1} &= x \\\\\n\\end{align}\n\\tag{16.4}\\]"
  },
  {
    "objectID": "chapters/extrapolation_interpolation.html#quadratic-interpolation-and-extrapolation",
    "href": "chapters/extrapolation_interpolation.html#quadratic-interpolation-and-extrapolation",
    "title": "16  Extrapolation and Interpolation",
    "section": "16.2 Quadratic Interpolation and Extrapolation",
    "text": "16.2 Quadratic Interpolation and Extrapolation\nA fancier technique for finding values between and beyond grid points is to use a parabola instead of a line. It takes three data points to define a parabola, so we need to start with the function values \\((x_1,y_1)\\), \\((x_2,y_2)\\), and \\((x_3,y_3)\\), as shown in the figure below.\n\n\n\n\n\n\nIllustration of quadratic interpolation/extrapolation. The red dots are the known function values. Black dots indicate interpolations and the green dot represents extrapolation.\n\n\n\n\n\nThe general formula for a parabola is\n\\[\ny=a + bx + cx^2\n\\tag{16.5}\\]\nwhere the coefficients \\(a\\), \\(b,\\) and \\(c\\) need to be chosen so that the parabola passes through our three data points. To determine these constants, you set up three equations that force the parabola to match the data points, like this: \\[\\begin{align}\n    y_1 &= a + bx_1 + cx_1^2\\\\\n    y_2 &= a + bx_2 + cx_2^2\\\\\n    y_3 &= a + bx_3 + cx_3^2\\\\\n\\end{align}\\]\nWe can solve this system of equations for \\(a\\), \\(b\\), and \\(c\\) and then plug these expressions back into (Equation 16.5) to get an approximation to the function in the neighborhood of these points. When we do this (it’s long and not super pretty so I’ll save you from the gory details) we find the following useful results for interpolating:\n\\[\ny(x_1 + {1\\over 2} h) = {1\\over 8} (3 y_1 + 6 y_2 - y_3)\n\\tag{16.6}\\]\n\\[\ny(x_2 + {1\\over 2} h) = {1\\over 8} (- y_1 + 6 y_2 + 3 y_3)\n\\tag{16.7}\\]\nand the following useful results for extrapolating\n\\[\ny(x_3 +  h) =  y_1 - 3 y_2 + 3y_3\n\\tag{16.8}\\]\n\\[\ny(x_3 +  {1\\over 2}h) =  {1\\over 8}(3 y_1 - 10 y_2 + 15y_3)\n\\tag{16.9}\\]"
  },
  {
    "objectID": "chapters/extrapolation_interpolation.html#an-example",
    "href": "chapters/extrapolation_interpolation.html#an-example",
    "title": "16  Extrapolation and Interpolation",
    "section": "16.3 An Example",
    "text": "16.3 An Example\nLet’s take the example of the projectile that was mentioned at the beginning of this chapter (shown below again). The red dots are the known data points and let’s try to estimate the height of the projectile between the 3rd and 4th data points in the set (the blue dot) using both linear and quadratic methods.\n\n\n\n\n\nLet’s evaluate (Equation 16.2) and (Equation 16.6) to perform this interpolation in the cell below.\n\nfrom numpy import linspace,sin,cos,pi\n\nvi = 30\nθ = 40 * pi/180\nt = linspace(0,3.5,10)\nx = vi * cos(θ) * t \ny = vi * sin(θ) * t - 4.9 * t**2\n\nyInterpLinear = y[2] + 1/2 * (y[3]-y[2])\nyInterpQuadratic = 1/8 *(3*y[2] + 6 * y[3] - y[4])\nprint(yInterpLinear)\nprint(yInterpQuadratic)\n\n13.931150961536407\n14.11641330721542\n\n\nNotice that the linear and quadratic interpolations are close to the same number but they aren’t equal; we wouldn’t really expect them to be. Deciding which interpolation method is the best choice is a case-by-case decision. For this case, I would favor the quadratic interpolation since the trajectory is more parabolic than linear. Now let’s use the extrapolation formulas to estimate the projectile’s height past the last data point. For the linear case, the second-to-last data point is playing the role of \\((x_1,y_1)\\) and the last data point is playing the role of \\((x_2,y_2)\\). For the quadratic case, the third-to-last data point is playing the role of \\((x_1,y_1)\\), the second-to-last data point is playing the role of \\((x_2,y_2)\\), and the last data point is playing the role of \\((x_3,y_3)\\). Best to use negative indices to index the data arrays for this case.\n\nfrom numpy import linspace,sin,cos,pi\n\nvi = 30\nθ = 40 * pi/180\nt = linspace(0,3.5,10)\nx = vi * cos(θ) * t \ny = vi * sin(θ) * t - 4.9 * t**2\n\nyExtrapLinear = 2* y[-1] - y[-2]\nyExtrapQuadratic = y[-3] - 3 * y[-2] + 3 * y[-1]\nprint(yExtrapLinear)\nprint(yExtrapQuadratic)\n\n2.3690482905900723\n0.8869495251579806\n\n\nNow the quadratic and the linear extrapolations differ pretty significantly. The linear version is a better value in this case due to the very course grid being used here. Finally, let’s use (Equation 16.4) to estimate the landing location for the projectile.\n\nfrom numpy import linspace,sin,cos,pi\n\nvi = 30\nθ = 40 * pi/180\nt = linspace(0,3.5,10)\nx = vi * cos(θ) * t \ny = vi * sin(θ) * t - 4.9 * t**2\n\nxRange = x[-2] - y[-2] * (x[-1] - x[-2])/(y[-1] - y[-2])\nprint(xRange)\n\n93.52444507627926"
  },
  {
    "objectID": "chapters/extrapolation_interpolation.html#flashcards",
    "href": "chapters/extrapolation_interpolation.html#flashcards",
    "title": "16  Extrapolation and Interpolation",
    "section": "16.4 Flashcards",
    "text": "16.4 Flashcards\n\nWhat is the difference between interpolation and extrapolation?\nWhat is the equation for linear interpolation?\nWhat is the equation for linear extrapolation?\nWhat is the equation(s) for quadratic interpolation?\nWhat is the equation(s) for quadratic extrapolation?\nWhat is the equation for finding the zeros of a function?\nRecite Moses 1:39."
  },
  {
    "objectID": "chapters/extrapolation_interpolation.html#exercises",
    "href": "chapters/extrapolation_interpolation.html#exercises",
    "title": "16  Extrapolation and Interpolation",
    "section": "16.5 Exercises",
    "text": "16.5 Exercises\n\n\nIn the cell below, you will find the coordinates for a batted baseball flying through the air while experiencing non-negligible air drag.\n\nPlot the data.\nUse the linear zero-finding formula (Equation 16.4) to estimate the landing location of the ball.\nUse linear interpolation to calculate the height of the projectile between the 2nd and 3rd data point. Make a visual inspection of the plot to ensure that your interpolation is reasonable.\nUse quadratic interpolation to calculate the height of the projectile between the 2nd and 3rd data point. Make a visual inspection of the plot to ensure that your interpolation is reasonable.\n\n\nx = [0, 15.805250773081712, 29.98211261814125, 42.526480802646844, 53.54837374010167, 63.375313562732956, 72.28376367575353, 80.43524080501983, 87.9042108343639, 94.71629032437068, 100.88093230888737, 106.41217684263896] \ny = [0, 15.80525077308171, 27.532112618141245, 35.45860314481743, 39.97307745470617, 41.548109055524456, 40.52592795902555, 37.14060411207481, 31.588726752728686, 24.07513301195207, 14.825650490213738, 4.076523019892836]\n\nThis file contains worldwide carbon emission data from 1958 to 2017.\n\nRead the data file using any method of your choosing.\nPlot the data so you can see what it looks like.\nUse linear extrapolation to predict what carbon emissions will be in the year 2030.\n\nUse quadratic extrapolation to predict what carbon emissions will be in the year 2030.\n\nHints:\n\nRemember that our extrapolation formulas assume that the spacing between grid points is equal. Hence, to extrapolate to 2030, \\(x_1\\) must correspond to 2004 \\(x_2\\) should correspond to \\(2017\\) for the linear extrapolation.\nFor the quadratic extrapolation, \\(x_1\\) should correspond to 1991, \\(x_2\\) to 2004 and \\(x_3\\) to 2017. You could pick other years if you like as long as they are spaced out evenly.\n\n\n# Solution here\n\nThis file contains the change in average global temperature from 1958 to 2017.\n\nRead the data file using any method of your choosing.\nPlot the data so you can see what it looks like.\nUse linear extrapolation to predict what average global temperature change will be in the year 2030 if this trend continues.\n\nUse quadratic extrapolation to predict what average global temperature change will be in the year 2030 if this trend continues.\n\n\n# Solution here"
  },
  {
    "objectID": "chapters/fitting.html",
    "href": "chapters/fitting.html",
    "title": "17  Curve Fitting",
    "section": "",
    "text": "Jupyter Notebook .\nOften in science you will gather data as a way to explore the relationship between two physical quantities and/or to validate your theories. For example, perhaps you are interested how the amount of fertilizer applied to your tomato plants affect the final size of the fruit. Or maybe you want to know how a planet’s distance from the sun affects it’s orbital period. Investigating these kinds of questions are the very essence of science and great scientific discoveries begin with simple questions posed by curious minds. As a brief reminder, the steps to the scientific process are:\n1. Formulate a question.\n2. Form a hypothesis.\n3. Use your hypothesis to make a prediction.\n4. Test your prediction.\n5. Analyze the results and fine tune your theory.\nThe process of gathering data and analyzing it, hoping to draw conclusions and establish physical laws are what steps 4 and 5 are all about. One computational tool that will help you establish firm relationships is called curve fitting. Curve fitting is the process of finding a function that matches your data as closely as possible. Finding a best-fit function that agrees with your hypothesis can be a valuable step in verifying or proving a theory. Other useful mathematical conclusions can be drawn from it as well.\nAs a simple example consider the stopping time for a car with its brakes locked up (most modern cars are designed to prevent this). The question is: How does the stopping time depend on the car’s initial speed. If you are familiar with Newtonian mechanics at all, you might hypothesize that the acceleration of the car should not depend on the initial velocity and hence the stopping time will increase linearly with the initial speed. Furthermore, the following kinematic equation\n\\[\n\\begin{align*}\nv_f &= v_i - a \\Delta t\\\\\n0 &= v_i - \\mu_k g \\Delta t\\\\\n\\Delta t &= {v_i\\over \\mu_k g}\n\\end{align*}\n\\]\nwould suggest that the slope of \\(\\Delta t\\) vs. \\(v_i\\) function is \\({1\\over a} = {1\\over \\mu g}\\). In other words, the theory of kinematics suggest that the acceleration should be independent of initial speed. To prove your idea, you should first measure the stopping time for cars with a variety of initial speeds (shown below).\nWe notice that the data looks linear which matches our hypothesis that the acceleration is constant."
  },
  {
    "objectID": "chapters/fitting.html#fitting-to-a-polynomial",
    "href": "chapters/fitting.html#fitting-to-a-polynomial",
    "title": "17  Curve Fitting",
    "section": "17.1 Fitting to a polynomial",
    "text": "17.1 Fitting to a polynomial\nThe next thing to do is to find the line that passes through the data points as close as possible. When the fit function is a polynomial , we can use the polyfit function from numpy. This function takes three argument: the independent data set, the dependent data set, and the order of the polynomial\npolyfit(x,y,order)\nThe polyfit function returns a list of numbers containing the function parameters for the best fit function.\n\nfrom matplotlib import pyplot as plt\nfrom numpy import polyfit\n\nt = [3.23,3.43,4.67,5.45,6,8.52]\nvi = [12,17,22,25,29,38]\n\nparams = polyfit(vi,t,1)\nslope = params[0]\nyint = params[1]\n\ng=9.8 #Acceleration due to gravity\nmu = 1/(slope * g)\nprint(params)\nprint(mu)\n\n[0.20971747 0.21840032]\n0.48656326406696415\n\n\nIn this case, \\(0.2097\\) is the slope of the best-fit function and \\(0.2184\\) is the y-intercept of the best fit function. Remembering our theory from above, we notice that the slope of this fit function can be used to calculate the coefficient of friction between the rubber tires and the roadway.\n\\[\n\\begin{align*}\nm &= {1\\over \\mu g}\\\\\n\\mu &= {1\\over m g}\n\\end{align*}\n\\]\nIt is often useful to plot the fit function on top of the data to verify that it really matches the data.\n\nfrom matplotlib import pyplot as plt\nfrom numpy import polyfit,linspace\n\nt = [3.23,3.43,4.67,5.45,6,8.52]\nvi = [12,17,22,25,29,38]\n\nparams = polyfit(vi,t,1)\nvDense = linspace(8,40,100)\ntDense = params[0] * vDense + params[1]\n\nplt.plot(vi,t,'r.',ms = 16)\nplt.plot(vDense,tDense,'k',lw = 3)\n\n\n\n\n\n17.1.1 Assessing the quality of the fit\nSometimes it might not be clear what type of function you should fit to. A good way to measure the quality of a fit it so sum the square of the difference between the fit function and the data.\n\\[\n\\sum_i (y_i - f(x_i))^2\n\\]\nYou can make polyfit do this for you using the full = True keyword argument. Now the function will return a list of 5 things: the first is the list of fitting parameters and the second thing is the sum of the square of the errors. Fits with big values for this sum are not as good as those with lower values.\n\nfrom matplotlib import pyplot as plt\nfrom numpy import polyfit,linspace\n\nt = [3.23,3.43,4.67,5.45,6,8.52]\nvi = [12,17,22,25,29,38]\n\nparamsLinear = polyfit(vi,t,1,full=True)\nparamsQuadratic = polyfit(vi,t,2,full=True)\nvDense = linspace(8,40,100)\ntDenseLinear = paramsLinear[0][0] * vDense + paramsLinear[0][1]\ntDenseQuadratic = paramsQuadratic[0][0] * vDense**2 + paramsQuadratic[0][1] * vDense + paramsQuadratic[0][2]\n\nerrorLinear = paramsLinear[1][0]\nerrorQuadratic = paramsQuadratic[1][0]\n\nplt.plot(vi,t,'r.',ms = 16)\nplt.plot(vDense,tDenseLinear,'k',lw = 3)\nplt.title(f\"Error: {errorLinear:1.3f}\")\nplt.show()\n\n\nplt.plot(vi,t,'r.',ms = 16)\nplt.plot(vDense,tDenseQuadratic,'b',lw = 3)\nplt.title(f\"Error: {errorQuadratic:1.3f}\")\nplt.show()"
  },
  {
    "objectID": "chapters/fitting.html#other-functions-for-curve-fitting.",
    "href": "chapters/fitting.html#other-functions-for-curve-fitting.",
    "title": "17  Curve Fitting",
    "section": "17.2 Other functions for curve fitting.",
    "text": "17.2 Other functions for curve fitting.\nIf the fit function is a polynomial, polyfit is a great choice but there are times when the hypothesized functions is not a polynomial. In cases like this, the function scipy.optimize.curve_fit should work. As an example, let’s say that you have the following intensity vs. wavelength data.\n\n\n\n\n\nIf you suspected that the fit function looked like this \\[I(\\lambda) = a \\lambda^{-5} {1\\over \\exp{b\\over \\lambda} - 1}\\], you could find the values of a and b that made the function fit the data like this:\n\nfrom scipy.optimize import curve_fit\nfrom matplotlib import pyplot as plt\nfrom numpy import exp,log\n\ndef fit_function(wvlength,a,b):\n  return a * wvlength**-5 * 1/(exp(b/wvlength) + 1)\n\nwavelength = [0.1, 0.6, 1.1, 1.6, 2.1, 2.6, 3.1, 3.6, 4.1, 4.6, 5.1, 5.6, 6.1]\nintensity = [0, 7.43023e-7, 0.0000699768, 0.000184459, \\\n0.000211137, 0.000183716, 0.000144493, 0.000109646, 0.0000825034, \\\n0.0000623056, 0.0000474756, 0.0000365799, 0.0000285178]\n\nparams = curve_fit(fit_function,wavelength,intensity)\nprint(params)\nwDense = linspace(0.1,7,100)\niDense = params[0][0] * wDense**-5 * 1/(exp(params[0][1]/wDense) + 1)\n\nplt.plot(wavelength,intensity,'r.',ms = 13)\nplt.plot(wDense,iDense,'k',lw = 2)\n\n(array([ 1.21509047, 10.32796789]), array([[0.00225532, 0.0038109 ],\n       [0.0038109 , 0.00717859]]))\n\n\n\n\n\nNotice that the curve_fit function returns more than just the fit paramters. It also returns a \\(2\\) x \\(2\\) matrix containing the uncertainties on the fit parameters. If you want to calculate the fit error, you’ll have to do it manually, using the equation\n\\[\n\\sum_i (y_i - f(x_i))^2\n\\]\n\nfrom scipy.optimize import curve_fit\nfrom matplotlib import pyplot as plt\nfrom numpy import exp,log,diagonal,sqrt,array\n\ndef fit_function(wvlength,a,b):\n  return a * wvlength**-5 * 1/(exp(b/wvlength) + 1)\n\ndef fit_function_two(wvlength,a,b):\n  return a * wvlength**-5 * 1/(exp(b/wvlength) - 1)\n\nwavelength = array([0.1, 0.6, 1.1, 1.6, 2.1, 2.6, 3.1, 3.6, 4.1, 4.6, 5.1, 5.6, 6.1])\nintensity = array([0, 7.43023e-7, 0.0000699768, 0.000184459, 0.000211137, 0.000183716, 0.000144493, 0.000109646, 0.0000825034, 0.0000623056, 0.0000474756, 0.0000365799, 0.0000285178])\n\nparamsOne = curve_fit(fit_function,wavelength,intensity)\nparamsTwo = curve_fit(fit_function_two,wavelength,intensity)\nwDense = linspace(0.1,7,100)\niDenseOne = fit_function(wDense,paramsOne[0][0],paramsOne[0][1])\niDenseTwo = fit_function_two(wDense,paramsTwo[0][0],paramsTwo[0][1])\n\nerrorOne = sum((intensity - fit_function(wavelength,paramsOne[0][0],paramsOne[0][1]))**2 )\nerrorTwo = sum( (intensity - fit_function_two(wavelength,paramsTwo[0][0],paramsTwo[0][1]))**2 )\n\nplt.plot(wavelength,intensity,'r.',ms = 13)\nplt.plot(wDense,iDenseOne,'k',lw = 2)\nplt.title(f\"Error: {errorOne:1.3e}\")\nplt.show()\n\n\nplt.plot(wavelength,intensity,'r.',ms = 13)\nplt.plot(wDense,iDenseTwo,'k',lw = 2)\nplt.title(f\"Error: {errorTwo:1.3e}\")\nplt.show()"
  },
  {
    "objectID": "chapters/fitting.html#flashcards",
    "href": "chapters/fitting.html#flashcards",
    "title": "17  Curve Fitting",
    "section": "17.3 Flashcards",
    "text": "17.3 Flashcards\n\nWhat python function should you use to fit a polynomial to your data? Give an example of its usage.\nWhat python function should you use to fit a function that is not a polynomial to your data. Give an example of how to use this function.\nWhat is the output from the polyfit function?\nWhat is the output from the curve_fit function?\nHow can you assess the quality of a fit function?\nWhy did the Savior teach in parables?"
  },
  {
    "objectID": "chapters/fitting.html#exercises",
    "href": "chapters/fitting.html#exercises",
    "title": "17  Curve Fitting",
    "section": "17.4 Exercises",
    "text": "17.4 Exercises\n\nYou push a box with five known forces while using a motion detector to measure the cart’s acceleration. The data are shown below.\n\nPlot the data with force on the vertical axis and acceleration on the horizontal axis.\n\nFit a polynomial function of order one (linear function) to this data.\nFit a polynomial function of order two (quadratic function) to this data.\nDetermine which is the better fit.\nPlot the best-fit functions on top of the data.\nDetermine the mass of the box.\n\n\n\n\n\nForce (N)\nacceleration (m/s)\n\n\n\n\n0.25\n0.5\n\n\n0.50\n0.8\n\n\n0.75\n1.3\n\n\n1.0\n1.8\n\n\n1.25\n2.1\n\n\n\n# Solution Here\n\nYour friend wants to know the acceleration of his car and asks you to help him. You set up a motion detector that allows you to measure the position of the car at regular intervals. Your data are as follows:\n\nPlot the data with time on the horizontal axis and position on the vertical.\nFit a polynomial function of order one (linear function) to this data.\nFit a polynomial function of order two (quadratic function) to this data.\nDetermine which is the better fit.\nPlot the best-fit functions on top of the data.\nCalculate the acceleration of the car using the best fit.\n\n\n\n\n\nTime (s)\nPosition (m)\n\n\n\n\n0.0\n0.256\n\n\n0.1\n0.249\n\n\n0.2\n0.195\n\n\n0.3\n0.514\n\n\n0.4\n0.538\n\n\n0.5\n0.785\n\n\n0.6\n1.11\n\n\n0.7\n1.31\n\n\n0.8\n1.81\n\n\n0.9\n2.32\n\n\n1.0\n2.74\n\n\n\n# Solution Here\n\nThe takeoff speed for a passenger airline jet is \\(80\\) m/s. Velocity data measured during takeoff are given in the table below.\n\nPlot the data and fit a linear function to the data set. Do you find good evidence that the acceleration of the airplane is constant.\nPlot the best-fit function on top of the data.\nAt what time will the airplane achieve liftoff?\n\n\n\n\n\nTime (s)\nVelocity (m/s)\n\n\n\n\n0\n0\n\n\n10\n23\n\n\n20\n46\n\n\n30\n69\n\n\n\n# Solution Here\n\nIn PH123 you’ll learn about ideal gases and the processes associated with them. One such process is called an adiabatic process. The relationship between the temperature and the volume in an adiabatic process is\n\n\\[\nT(V) = {C\\over V^{\\gamma -1}}\n\\]\nFor your experiment you compress a cylinder of gas four different times and measure the temperature of the gas.\n\n\n\nVolume (m\\(^3\\))\nTemperature (\\(^\\circ\\) C)\n\n\n\n\n0.481\n35\n\n\n0.412\n68\n\n\n0.347\n110\n\n\n0.299\n150\n\n\n\n\nPlot temperature vs. volume. Make sure the volumes are in cubic meters and the temperatures are in Kelvins: \\[T_K = T_C + 273\\].\nFit the function mentioned above to this data.\nPlot the best-fit function on top of the data.\nCalculate gamma. The value of gamma is an indication of what type of gas is present in the cylinder. \\(\\gamma = 1.4\\) for a diatomic gas and \\(\\gamma = 1.67\\) for a monatomic gas.\n\n# Solution Here"
  },
  {
    "objectID": "chapters/numericalCalculus.html",
    "href": "chapters/numericalCalculus.html",
    "title": "18  Numerical Calculus",
    "section": "",
    "text": "Jupyter Notebook\nIf you have taken a calculus class, you probably know what a derivative and anti-derivative are and how to calculate them. (If you haven’t taken calculus, you will understand these concepts soon.) The techniques that you learned in calculus class are called analytical methods, which means that the derivative (or anti-derivative) are calculated using pencil, paper, and some mathematical rules to guide you. In this chapter, we will explore how to find the derivative (or anti-derivative) of a discrete set of data rather than a continuous function."
  },
  {
    "objectID": "chapters/numericalCalculus.html#numerical-derivatives",
    "href": "chapters/numericalCalculus.html#numerical-derivatives",
    "title": "18  Numerical Calculus",
    "section": "18.1 Numerical Derivatives",
    "text": "18.1 Numerical Derivatives\nLet’s start with a simple data set that gives the position of an object dropped from a tall building at various times.\n\n\n\n\n\nThere are three possible ways that we could find the slope at a single point: the forward difference, the backward difference, and the center difference.\n\\[\nf'(x) = {f(x + h) - f(x - h)\\over 2h} \\text{ (center-difference)}\n\\]\n\\[\nf'(x) = {f(x + h) - f(x )\\over h} \\text{ (forward-difference)}\n\\]\n\\[\nf'(x) = {f(x) - f(x - h)\\over h} \\text{ (backward-difference)}\n\\]\nWe illustrate them in the figure below.\n\n\n\n(0.75, 3.5, 6.5, 8.25)\n\n\n\n\nFigure 1: Illustration of the forward difference derivative (blue solid line), the backward difference (blue dashed line) and the center difference (red dashed line)\n\n\n\n\n\n\n\n\nClearly, the centered-difference is the best way to calculate slopes and it is the method you should always strive for. Let’s see how to use the center-difference equation in python to calculate the slope at every point in a data set.\n\nfrom numpy import linspace,array\nfrom matplotlib import pyplot as plt\n\nt = array([0.0, 0.21052631578947367, 0.42105263157894735, 0.631578947368421, 0.8421052631578947, 1.0526315789473684, 1.263157894736842, 1.4736842105263157, 1.6842105263157894, 1.894736842105263, 2.1052631578947367, 2.3157894736842106, 2.526315789473684, 2.7368421052631575, 2.9473684210526314, 3.1578947368421053, 3.3684210526315788, 3.578947368421052, 3.789473684210526, 4.0])\ny = array([100.0, 99.78282548476454, 99.13130193905818, 98.04542936288088, 96.52520775623269, 94.57063711911357, 92.18171745152354, 89.35844875346261, 86.10083102493076, 82.40886426592797, 78.2825484764543, 73.72188365650969, 68.72686980609419, 63.29750692520776, 57.43379501385042, 51.13573407202215, 44.403324099722994, 37.23656509695292, 29.63545706371191, 21.599999999999994])\n\ndt = t[1] - t[0]\nyprime = (y[2:] - y[:-2])/(2 * dt)\n\nplt.plot(t,y,'r--.',ms = 13)\nplt.plot(t[1:-1],yprime,'b--.',ms = 13)\nplt.xlabel(\"time (s)\")\nplt.ylabel(\"height (m)\")\nplt.show()\n\n\n\n\nPay special attention to this line: yprime = (y[2:] - y[:-2])/(2 * dt). By slicing the array of function values carefully, I can calculate the center-difference derivative for all points in the data set simultaneously. (see figure below) Also note that when using the center difference formula, you are unable to calculate the slope at the endpoints of the dataset. Hence, your array of slope values is two shorter than your original list. When I plot the derivative, the time array has to be trimmed to get the slopes to match up correctly with times.\n\n\n\nIllustration of center-difference derivative on a discrete grid. Using array slicing the slope can be calculated at all points simultaneously.\n\n\nHere is another example for a dataset that exhibits a few more features. Take a second to verify that the blue function is giving the slope of the red function.\n\nfrom numpy import array\n\nt = array([0.0, 0.10204081632653061, 0.20408163265306123, 0.30612244897959184, 0.40816326530612246, 0.5102040816326531, 0.6122448979591837, 0.7142857142857143, 0.8163265306122449, 0.9183673469387755, 1.0204081632653061, 1.1224489795918369, 1.2244897959183674, 1.3265306122448979, 1.4285714285714286, 1.5306122448979593, 1.6326530612244898, 1.7346938775510203, 1.836734693877551, 1.9387755102040818, 2.0408163265306123, 2.142857142857143, 2.2448979591836737, 2.3469387755102042, 2.4489795918367347, 2.5510204081632653, 2.6530612244897958, 2.7551020408163267, 2.857142857142857, 2.9591836734693877, 3.0612244897959187, 3.163265306122449, 3.2653061224489797, 3.36734693877551, 3.4693877551020407, 3.5714285714285716, 3.673469387755102, 3.7755102040816326, 3.8775510204081636, 3.979591836734694, 4.081632653061225, 4.183673469387755, 4.285714285714286, 4.387755102040816, 4.4897959183673475, 4.591836734693878, 4.6938775510204085, 4.795918367346939, 4.8979591836734695, 5.0, 5.1020408163265305, 5.204081632653061, 5.3061224489795915, 5.408163265306123, 5.510204081632653, 5.612244897959184, 5.714285714285714, 5.816326530612245, 5.918367346938775, 6.020408163265306, 6.122448979591837, 6.224489795918368, 6.326530612244898, 6.428571428571429, 6.530612244897959, 6.63265306122449, 6.73469387755102, 6.836734693877551, 6.938775510204081, 7.040816326530613, 7.142857142857143, 7.244897959183674, 7.346938775510204, 7.448979591836735, 7.551020408163265, 7.653061224489796, 7.755102040816327, 7.857142857142858, 7.959183673469388, 8.061224489795919, 8.16326530612245, 8.26530612244898, 8.36734693877551, 8.46938775510204, 8.571428571428571, 8.673469387755102, 8.775510204081632, 8.877551020408163, 8.979591836734695, 9.081632653061225, 9.183673469387756, 9.285714285714286, 9.387755102040817, 9.489795918367347, 9.591836734693878, 9.693877551020408, 9.795918367346939, 9.89795918367347, 10.0])\n\ny = array([1.0, 0.9867106049449835, 0.9633896110036303, 0.930441653845362, 0.8883647907109408, 0.8377438153135915, 0.7792427802562372, 0.7135968174516216, 0.641603352856869, 0.5641128165642914, 0.4820189528946211, 0.3962488375981065, 0.30775271057607917, 0.217493732695753, 0.12643777430107145, 0.03554334095074269, -0.05424826121944644, -0.1420224222596137, -0.22690029414347004, -0.30804733831471925, -0.38468127466905855, -0.4560793591162092, -0.5215849250188013, -0.5806131324972382, -0.6326558787228784, -0.6772858317939752, -0.7141595604960038, -0.743019742085619, -0.7636964401012755, -0.7761074539906521, -0.7802577519550382, -0.7762380077468505, -0.7642222711259269, -0.7444648101959878, -0.7172961718235661, -0.6831185137135822, -0.6424002684118669, -0.5956702054667365, -0.5435109631591742, -0.4865521255631921, -0.42546292419273285, -0.3609446461065957, -0.29372283206542116, -0.2245393491613234, -0.15414442227722988, -0.083288707794463, -0.012715491177467673, 0.05684691254372852, 0.12469247975946875, 0.19014444921827992, 0.2525618761933174, 0.31134570856282195, 0.36594432944772914, 0.4158585174857275, 0.4606457826610142, 0.49992404277520236, 0.5333746130575407, 0.5607444889909092, 0.5818479100925077, 0.5965672000538682, 0.6048528862341104, 0.60672310893566, 0.6022623380982411, 0.5916194219536842, 0.5750049987241208, 0.5526883085574614, 0.5249934485201562, 0.49229511855756375, 0.45501391084259973, 0.4136111988262666, 0.3685836855487481, 0.32045767334377057, 0.26978311895604673, 0.21712753928331918, 0.16306983344972584, 0.10819408672204209, 0.0530834209080176, -0.0016860456534446109, -0.05555106756061642, -0.10796691308417367, -0.15841272129543982, -0.20639652454758026, -0.2514598895714763, -0.29318213516550146, -0.33118408953590006, -0.36513135572337047, -0.3947370591710421, -0.41976405728705063, -0.4400265967682593, -0.45539141041706666, -0.4657782511379014, -0.4711598666822405, -0.47156142446092897, -0.46705940130261336, -0.45777995835259105, -0.44389682632607497, -0.4256287310064338, -0.4032363931693947, -0.3770191409801755])\n\nfrom matplotlib import pyplot as plt\n\ndt = t[1] - t[0]\nyprime = (y[2:] - y[:-2])/(2 * dt)\n\nplt.plot(t,y,'r',label = 'y(t)')\nplt.plot(t[1:-1],yprime,'b',label = \"y'(t)\")\nplt.xlabel(\"time (s)\")\nplt.ylabel(\"height (m)\")\nplt.legend()\n\n<matplotlib.legend.Legend at 0x11b963190>\n\n\n\n\n\n\n18.1.1 Numerical second derivatives\nWe can derive a formula for a second derivative as follows:\n\\[\n\\begin{align*}\nf''(x) &= {f'(x + {h\\over 2}) - f'(x - {h\\over 2}) \\over  h}\\\\\n&= {1\\over h} \\left({f(x + h) - f(x)\\over  h} - {f(x)  - f(x -  h) \\over  h} \\right)\\\\\n&= {1\\over h} \\left({f(x +  h) - 2 f(x) + f(x -  h) \\over  h} - {f(x)  - f'(x -  h) \\over  h} \\right)\\\\\n&= {f(x +  h) - 2 f(x) + f(x -  h) \\over  h^2} \\\\\n\\end{align*}\n\\]\nAnd here is an example of doing this in python.\n\nfrom numpy import array\n\nt = array([0.0, 0.10204081632653061, 0.20408163265306123, 0.30612244897959184, 0.40816326530612246, 0.5102040816326531, 0.6122448979591837, 0.7142857142857143, 0.8163265306122449, 0.9183673469387755, 1.0204081632653061, 1.1224489795918369, 1.2244897959183674, 1.3265306122448979, 1.4285714285714286, 1.5306122448979593, 1.6326530612244898, 1.7346938775510203, 1.836734693877551, 1.9387755102040818, 2.0408163265306123, 2.142857142857143, 2.2448979591836737, 2.3469387755102042, 2.4489795918367347, 2.5510204081632653, 2.6530612244897958, 2.7551020408163267, 2.857142857142857, 2.9591836734693877, 3.0612244897959187, 3.163265306122449, 3.2653061224489797, 3.36734693877551, 3.4693877551020407, 3.5714285714285716, 3.673469387755102, 3.7755102040816326, 3.8775510204081636, 3.979591836734694, 4.081632653061225, 4.183673469387755, 4.285714285714286, 4.387755102040816, 4.4897959183673475, 4.591836734693878, 4.6938775510204085, 4.795918367346939, 4.8979591836734695, 5.0, 5.1020408163265305, 5.204081632653061, 5.3061224489795915, 5.408163265306123, 5.510204081632653, 5.612244897959184, 5.714285714285714, 5.816326530612245, 5.918367346938775, 6.020408163265306, 6.122448979591837, 6.224489795918368, 6.326530612244898, 6.428571428571429, 6.530612244897959, 6.63265306122449, 6.73469387755102, 6.836734693877551, 6.938775510204081, 7.040816326530613, 7.142857142857143, 7.244897959183674, 7.346938775510204, 7.448979591836735, 7.551020408163265, 7.653061224489796, 7.755102040816327, 7.857142857142858, 7.959183673469388, 8.061224489795919, 8.16326530612245, 8.26530612244898, 8.36734693877551, 8.46938775510204, 8.571428571428571, 8.673469387755102, 8.775510204081632, 8.877551020408163, 8.979591836734695, 9.081632653061225, 9.183673469387756, 9.285714285714286, 9.387755102040817, 9.489795918367347, 9.591836734693878, 9.693877551020408, 9.795918367346939, 9.89795918367347, 10.0])\n\ny = array([1.0, 0.9867106049449835, 0.9633896110036303, 0.930441653845362, 0.8883647907109408, 0.8377438153135915, 0.7792427802562372, 0.7135968174516216, 0.641603352856869, 0.5641128165642914, 0.4820189528946211, 0.3962488375981065, 0.30775271057607917, 0.217493732695753, 0.12643777430107145, 0.03554334095074269, -0.05424826121944644, -0.1420224222596137, -0.22690029414347004, -0.30804733831471925, -0.38468127466905855, -0.4560793591162092, -0.5215849250188013, -0.5806131324972382, -0.6326558787228784, -0.6772858317939752, -0.7141595604960038, -0.743019742085619, -0.7636964401012755, -0.7761074539906521, -0.7802577519550382, -0.7762380077468505, -0.7642222711259269, -0.7444648101959878, -0.7172961718235661, -0.6831185137135822, -0.6424002684118669, -0.5956702054667365, -0.5435109631591742, -0.4865521255631921, -0.42546292419273285, -0.3609446461065957, -0.29372283206542116, -0.2245393491613234, -0.15414442227722988, -0.083288707794463, -0.012715491177467673, 0.05684691254372852, 0.12469247975946875, 0.19014444921827992, 0.2525618761933174, 0.31134570856282195, 0.36594432944772914, 0.4158585174857275, 0.4606457826610142, 0.49992404277520236, 0.5333746130575407, 0.5607444889909092, 0.5818479100925077, 0.5965672000538682, 0.6048528862341104, 0.60672310893566, 0.6022623380982411, 0.5916194219536842, 0.5750049987241208, 0.5526883085574614, 0.5249934485201562, 0.49229511855756375, 0.45501391084259973, 0.4136111988262666, 0.3685836855487481, 0.32045767334377057, 0.26978311895604673, 0.21712753928331918, 0.16306983344972584, 0.10819408672204209, 0.0530834209080176, -0.0016860456534446109, -0.05555106756061642, -0.10796691308417367, -0.15841272129543982, -0.20639652454758026, -0.2514598895714763, -0.29318213516550146, -0.33118408953590006, -0.36513135572337047, -0.3947370591710421, -0.41976405728705063, -0.4400265967682593, -0.45539141041706666, -0.4657782511379014, -0.4711598666822405, -0.47156142446092897, -0.46705940130261336, -0.45777995835259105, -0.44389682632607497, -0.4256287310064338, -0.4032363931693947, -0.3770191409801755])\n\nfrom matplotlib import pyplot as plt\n\ndt = t[1] - t[0]\nyprime = (y[2:] - y[:-2])/(2 * dt)\nyprimeprime = (y[2:] - 2 * y[1:-1] + y[:-2])/dt**2\nplt.plot(t,y,'r--.',label = 'y(t)')\nplt.plot(t[1:-1],yprime,'b--.',label = \"y'(t)\")\nplt.plot(t[1:-1],yprimeprime,'m--.',label = \"y''(t)\")\nplt.xlabel(\"time (s)\")\nplt.ylabel(\"height (m)\")\nplt.legend()\n\n<matplotlib.legend.Legend at 0x11b9846d0>"
  },
  {
    "objectID": "chapters/numericalCalculus.html#integration",
    "href": "chapters/numericalCalculus.html#integration",
    "title": "18  Numerical Calculus",
    "section": "18.2 Integration",
    "text": "18.2 Integration\nIn calculus you learn rules for finding anti-derivatives, or undoing the derivative. In this section we will learn how to find anti-derivatives of functions that are represented by discrete sets of data. The mathematical notation for an anti-derivative (also called an integral) is\n\\[\n\\int y(x) dx\n\\]\nFor example, the anti-derivative of \\(x^2\\) is \\({x^3 \\over 3}\\) or\n\\[\n\\int x^2 dx = {x^3\\over 3} + C\n\\]\nAny constant \\(C\\) can be added to the anti-derivative and the equality still holds. You can see this by taking the derivative of the right hand side and noticing that the derivative of the constant is zero.\n\n18.2.1 Definite Integrals\nAn alternate interpretation of the integral is that of the area created by the function and the horizontal axis. When thinking of an anti-derivative like this, we should put bounds on the integral to specify where to start counting the area and when to stop. These bounds show up as a subscript and superscript to the integral symbol (\\(\\int\\)). Here is a definite integral of the function \\(\\sin(x)\\) from \\(0 < x < \\pi\\).\n\\[\n\\int_0^\\pi \\sin(x) dx\n\\]\nTo perform a definite integral, the anti-derivative should first be evaluated at the upper and lower bounds. Then subtract these two numbers to obtain the final result.\n\\[\n\\int_a^b f'(x) dx = f(b) - f(a)\n\\]\nThe definite integral of \\(\\sin(x)\\) from \\(0 < x < \\pi\\) would be.\n\\[\n\\int_0^\\pi \\sin(x) dx = -\\cos(x)|_0^\\pi = -\\cos(\\pi) -(-\\cos(0)) = 2\n\\]\nAnd corresponds to the area shown in the figure below.\n\n\n(-0.3141592653589793,\n 6.5973445725385655,\n -1.0998615404412626,\n 1.0998615404412626)\n\n\n\n\n\nWhen working with discrete data, the integral of the underlying function can be approximated as a sum of the area of many rectangles. This can be written mathematically as\n\\[\n\\begin{align*}\n\\int f(x) dx &\\approx  dx  f(x_1) + dx f(x_2) + \\dots\\\\\n&= dx \\sum_i f(x_i)\n\\end{align*}\n\\]\nThe smaller the width of the rectangles, the better the approximation.\n\n\n(-0.6440264939859076,\n 6.613052535806514,\n -1.0998615404412626,\n 1.0998615404412626)\n\n\n\n\n\nLet’s use the rectangle rule to approximate the integral of a simple function and compare to the true answer to check for accuracy.\n\\[\n\\int_0^\\pi \\sin(x) dx\n\\]\n\nfrom numpy import linspace,sin,cos,pi\nx,dx = linspace(0,pi,100,retstep=True)\ny = sin(x)\n\nintegral = dx * sum(y)\nprint(integral)\nprint(-(cos(pi) - cos(0)))\n\n1.9998321638939924\n2.0\n\n\nNotice that I used the retstep = True keyword argument when calling linspace to retrieve the width of the rectangles.\n\n\n18.2.2 Trapezoid Integration\nWe can improve upon the rectangle approximation to the integral by replacing the rectangles with trapezoids. You may recall that the area of a trapezoid is\n\\[\nA = {\\Delta x \\over 2} \\left( f(a) + f(b)\\right)\n\\]\n\n\n(-0.15707963267948966,\n 3.2986722862692828,\n -0.049993706383693756,\n 1.049867834057569)\n\n\n\n\n\nIf we add up the area of all of these trapezoids we get\n\\[\n\\begin{align*}\n\\int_a^b f(x) dx &= {\\Delta x \\over 2} \\left( f(x_0) + f(x_1)\\right) + {\\Delta x \\over 2} \\left( f(x_1) + f(x_2)\\right) + {\\Delta x \\over 2} \\left( f(x_2) + f(x_3)\\right) \\dots \\\\\n&= {\\Delta x \\over 2} \\left( f(x_0) + 2 f(x_1) + 2 f(x_2) + \\dots 2 f(x_{n-1}) + f(x_n)\\right)\n\\end{align*}\n\\]\nLet’s use the trapezoid rule to integrate the function\n\\[\ny(x) = \\exp{-0.05 x} \\cos(x)\n\\]\nand see how it compares to the rectangle rule. We’ll also use sympy to see that the exact value is for comparison.\n\nfrom numpy import linspace,exp,cos,pi\nimport sympy as sp\nx,dx = linspace(0,pi,6,retstep=True)\ny = exp(-0.05 * x) * cos(x)\n\nintegralrectangle = dx * sum(y)\nintegraltrapezoid = dx /2 * (2 * sum(y[1:-1]) + y[0] + y[-1])\n\nxvar = sp.Symbol(\"x\")\nexpression = sp.exp(-0.05 * xvar) * sp.cos(xvar)\nexact = sp.integrate(expression,(xvar,0,sp.pi))\n\nprint(integralrectangle)\nprint(integraltrapezoid)\ndisplay(sp.N(exact))\n\n0.14127987124712144\n0.0956124235314592\n\n\n0.0925005485861962\n\n\nNotice that even with only 6 data points, using trapezoids did quite a bit better than using rectangles. There are other more sophisticated methods for integrating a function that you will learn about in other classes.\n\n\n18.2.3 Indefinite Integrals\nThe result of a definite integral is a single number; the area under the curve from the lower bound to the upper bound. The result of an indefinite integral is a function which gives the area under the curve starting at \\(x = 0\\) and ending at any value of \\(x\\) of your choosing. To perform an indefinite integral using a discrete data set, simply perform a definite integral from \\(x = 0\\) to every other x value in your range separately, saving each value in a list for later use. Let’s demonstrate this in the cell below.\n\nfrom numpy import linspace, sin,cos,pi\nfrom matplotlib import pyplot as plt\n\nx,dx = linspace(0,2 * pi,100,retstep = True)\ny = cos(x)\n\nintegral = [dx * sum(y[:n]) for n in range(len(x))]\nplt.plot(x,y,'r')\nplt.plot(x,integral,'b--.')\nplt.show()\n\n\n\n\nThe value of the blue curve gives the area under the red curve from \\(x = 0\\) to any value of x you want to consider. You should verify that this is true for a few points.\n\nfrom numpy import linspace, sin,cos,pi\nfrom matplotlib import pyplot as plt\n\nx,dx = linspace(0,2 * pi,100,retstep = True)\ny = sin(x)\n\nintegral = [dx * sum(y[:n]) for n in range(len(x))]\nplt.plot(x,y,'r')\nplt.plot(x,integral,'b--.')\nplt.show()"
  },
  {
    "objectID": "chapters/numericalCalculus.html#flashcards",
    "href": "chapters/numericalCalculus.html#flashcards",
    "title": "18  Numerical Calculus",
    "section": "18.3 Flashcards",
    "text": "18.3 Flashcards\n\nWrite down the equation for the center difference first derivative.\nWrite down the equation for the center difference second derivative.\nWrite down the equation for the integral approximation using rectangles.\nWrite down the equation for the integral approximation using trapezoids."
  },
  {
    "objectID": "chapters/numericalCalculus.html#exercises",
    "href": "chapters/numericalCalculus.html#exercises",
    "title": "18  Numerical Calculus",
    "section": "18.4 Exercises",
    "text": "18.4 Exercises\n\nFollow the steps below to calculate the first and second derivative of the following function \\[y(x) = {\\sin(x) \\over x}\\]\n\nGenerate a discrete grid of 20 equally-spaced points from \\(0< x < 10\\).\nGenerate an array of function values by evaluating the function above on the grid of points from step 1.\nUse the center-difference equation to generate an array of slope values.\nUse the center-difference second derivative equation to generate an array of second derivatives.\nPlot all three functions on the same axes and verify that they look right.\n\nFollow the steps below to calculate the definite and indefinite integral of the following function \\[F(t) = e^{-(t - 5)^2 \\over .05} \\] from \\(0<t<10\\) seconds.\n\nGenerate a discrete grid of 20 equally-spaced points from \\(0< t < 10\\).\nGenerate an array of function values by evaluating the function above on the grid of points from step 1.\nUsing the rectangle equation, approximate the integral.\nUsing the trapezoid equation, approximate the integral.\nUsing sympy evaluate the integral and compare to your approximations.\nModify the number of grid points until your approximations are within \\(0.001\\) of the true result.\n\nThis file contains data from Felix Baumgartner’s 2012 jump from an altitude of \\(39\\) km above the surface of the earth. Complete the following:\n\nRead the data file into a pandas dataframe.\nPlot altitude vs. time.\nUsing the center-difference formula, calculate the derivative of this data. What quantity do you get when you take a derivative of position vs. time data?\nCalculate the second derivative of this data. What quantity do you get when you take a second derivative of position vs. time data?\nPlot the derivatives and inspect them to verify that they make sense.\nThe original data set has a column that contains the Felix’s airspeed (in km/hour). Plot this column vs. time and compare to the derivative you performed to see if they match (or are close)."
  },
  {
    "objectID": "chapters/eulers.html",
    "href": "chapters/eulers.html",
    "title": "19  Euler’s Method",
    "section": "",
    "text": "Jupyter Notebook\nIn PH121 you will learn(or have already learned) how the position, velocity, and acceleration of an object are related to one another. One of the more challenging cases occurs when the acceleration of the object is not constant. The acceleration could vary with position, velocity, or time. In these cases, you may not be able to use calculus to find the position and/or velocity of an object. Instead, you’ll have to repeatedly use these equations\n\\[\nv_{i+1} = v_i  + a_i \\Delta t\n\\]\n\\[\nx_{i+1} = x_i + v_i \\Delta t\n\\]\nwith a very small \\(\\Delta t\\). If \\(\\Delta t\\) is sufficiently small, assuming that the acceleration is constant is a reasonable approximation. Below we will explain the physics of a few important situations where Euler’s method is a good choice to solve the problem."
  },
  {
    "objectID": "chapters/eulers.html#air-drag---one-dimensional",
    "href": "chapters/eulers.html#air-drag---one-dimensional",
    "title": "19  Euler’s Method",
    "section": "19.1 Air Drag - One dimensional",
    "text": "19.1 Air Drag - One dimensional\nThe drag force (due to air resistance) is given by:\n\\[\nF_\\text{drag} = {1\\over 2} C \\cdot \\rho_\\mathrm{air} \\cdot A \\cdot v^2\n\\]\nwhere \\(C\\) is the drag coefficient, \\(\\rho_\\mathrm{air}\\) is the density of air, and \\(A\\) is the cross-sectional area of the projectile. For an object that is dropped (or thrown) vertically, the acceleration is given by the following\n\\[\n\\begin{align*}\n-m g - {1\\over 2} \\rho A C v^2 &= m a\\\\\n-g - {1\\over 2 m} \\rho A C v^2 &= a\\\\\n\\end{align*}\n\\]\nand we can use the standard kinematic equations with a very small \\(\\Delta t\\) to determine the position and velocity at future times.\n\\[\ny_\\mathrm{n+1} = y_n + v_n  \\Delta t\n\\]\n\\[\nv_{n+1} = v_n - a \\Delta t\n\\]\nIn the code cell below you will find an example of Euler’s method for a small styrofoam ball that is dropped from the top of a \\(100\\)-m-tall building. The styrofoam ball has a mass \\(m = 100\\) g, drag constant \\(C = 0.02\\), radius \\(r = 0.25\\) m and the density of air is \\(1.29\\) kg/m\\(^3\\).\n\nfrom matplotlib import pyplot as plt\nfrom numpy import pi\n\ndt = 0.01\nv = [0]\ny =[100]\nt = [0]\ng = 9.8\nC = 0.02\nrho = 1.29\nr = .25\nA = pi * r**2\nm = .1\n\nwhile y[-1] > 0:\n  a = 1/2/m * rho * A * C * v[-1]**2 - g\n  v.append(v[-1]+ a * dt)\n  y.append(y[-1] + v[-1] * dt)\n  t.append(t[-1] + dt)\n    \nfig = plt.figure()\nax1 = fig.add_subplot(2,1,1)\nax2 = fig.add_subplot(2,1,2)\nax1.plot(t,y,'r.')\nax2.plot(t,v,'r.')\nplt.show()"
  },
  {
    "objectID": "chapters/eulers.html#air-drag-two-dimensional",
    "href": "chapters/eulers.html#air-drag-two-dimensional",
    "title": "19  Euler’s Method",
    "section": "19.2 Air Drag (two dimensional)",
    "text": "19.2 Air Drag (two dimensional)\nFor two dimensional motion, we need to decompose the drag force into x and y components.\n\\[\n\\begin{align*}\nF_x &= F_D \\cos(\\theta)\\\\\n&= F_D {v_x\\over v}\\\\\n&= -{1\\over 2} \\rho A C v^2 {v_x\\over v}\\\\\n&= -{1\\over 2} \\rho A C v v_x\\\\\n\\end{align*}\n\\]\nA similar expression for the y component of the drag force is\n\\[\nF_y = -{1\\over 2} \\rho A C v v_y\\\\\n\\]"
  },
  {
    "objectID": "chapters/eulers.html#rocket-propulsion",
    "href": "chapters/eulers.html#rocket-propulsion",
    "title": "19  Euler’s Method",
    "section": "19.3 Rocket Propulsion",
    "text": "19.3 Rocket Propulsion\nThe liftoff of a rocket provides some interesting physics to consider. The mass of the rocket + fuel is decreasing as the fuel burns off. Hence, the acceleration of the rocket is very much not a constant. However, in your code you don’t want to decrease the mass of the rocket-fuel system forever or the mass will become lower than the mass of the rocket alone, and eventually will go negative (yikes!). Watch out for that.\nThe force of the thrust on the rocket is given by:\n\\[ F = v_e {dM\\over dt}\\]\nwhere \\({dM\\over dt}\\) is the rate of mass loss due to the fuel burning and \\(v_e\\) is the speed with which the exhaust exits the rocket. Can you do a unit analysis on this function and convince yourself that it has the right units?\nThe force of air drag on the rocket is quadratic. In other words, it is given by:\n\\[F_\\text{drag} = {1\\over 2} \\rho A C v^2\\]\nwhere \\(\\rho\\) is the density of air, \\(A\\) is the cross-sectional area of the rocket, and \\(C\\) is the drag coefficient. Also notice that the direction of the drag force changes at the peak of the trajectory. For the upward journey, the drag force points downward, and for the downward part of the journey, the drag force points upward. To handle this efficiently when writing your code, I recommend calculating this force like this:\n\\[ F_D = {1\\over 2} \\rho A C v |v|\\]\nso that the sign of this calculation changes naturally at the peak of the trajectory.\nSince the rocket may travel a considerable distance into the atmosphere, we must take into account that the density of the atmosphere varies with altitude according to:\n\\[\\rho(h) = (1.09 - {0.0065 h\\over 300})^{2.5}\\]"
  },
  {
    "objectID": "chapters/eulers.html#exercises",
    "href": "chapters/eulers.html#exercises",
    "title": "19  Euler’s Method",
    "section": "19.4 Exercises",
    "text": "19.4 Exercises\n\nIn 2012, Felix Baumgartner successfully jumped from a height of \\(39.0\\) km above the surface of the Earth. Consider the complexities that this real-world examples provides:\n\nFor this problem, we must include the force of air drag to get the calculation right. The force of air drag is given by: \\(F_d = {1\\over 2} \\rho A C v^2\\), with \\(C = 0.58\\), \\(A = 1.04\\) m\\(^2\\)\nBecause Felix jumped from such a high altitude, the density of the atmosphere changed as he fell. The density of the atmosphere changes with altitude according to the following equation: \\(\\rho = 1.2 \\text{ (kg/m}^3\\text{)} e^{-h\\over 1 \\times 10^4}\\)\nThe acceleration due to gravity, g, is not constant over the flight, but changes with altitude according to the following equation: \\(g = {9.8 \\text{ m/s}^2 \\over (1 + {h\\over R_E})^2}\\), where \\(R_E = 6.37 \\times 10^6\\) m\nAssume that Felix’s mass is \\(m = 73\\) kg and that he starts from rest.\n\nUse Euler’s method to answer the following questions:\n\nHow long does it take Felix to reach Earth’s surface. Give your answer to the nearest second. (Note: We are not considering a parachute in this case.. ouch.) Answer: You should find that his flight took \\(\\approx 400\\) s.\nCompare the real fall time you just calculated to the dragless, constant-g (\\(9.8\\)m/s\\(^2\\)) fall time. Answer: You should find that the fall time is \\(\\approx 90\\) s. (big difference eh.)\n\nA rocket has a total mass \\(M_i = 180\\) kg, including \\(130\\) kg of fuel and oxidizer. The rocket is launched from the ground, starting from rest at time \\(t = 0\\) s, and puts out exhaust with a relative speed of \\(v_e = 1500\\) m/s at a constant burn rate of \\({dM \\over dt} = 2.50\\) kg/s. The burn lasts until the fuel runs out. Assume a cylindrical rocket with a fuselage radius \\(r = 20\\) cm, and a drag coefficient of \\(C = 0.5\\).\n\nUsing Euler’s method, plot the position vs. time and velocity vs. time graphs for the rocket from the moment it lifts off until it hits the ground again. Note: We’re not modeling a parachute here.\nMake sure your code is well commented.\nHow long was the flight?\nWhat is the rocket’s impact speed with the ground?\nOnce you think your simulation is correct, play with some of the key parameters to ensure that the results of your simulation agree with your own intuition. Here are some things you could try:\n\nChange the mass of the rocket.\nChange the mass of the fuel.\nChange the exhaust speed of the fuel.\nChange the drag coefficient.\nChange the size of the rocket (cross-sectional area).\n\n\nThe distance from home plate to the home run fence is \\(550\\) feet. It is well known that it is easier to hit home run in Denver (where the altitude is higher and the air density is lower) than it is in a ballpark that is closer to sea level. Use Euler’s method to determine the initial speed needed to hit a home run at sea level where the air density is \\(\\rho = 1.225\\) kg/m\\(^3\\). Then repeat the calculation for a ballpark in Denver where the air density is \\(82\\%\\) of the sea level value. If you were a pitcher, would you feel inclined to pitch in Denver? The drag constant for a baseball is not constant with its speed. Experimental work has revealed the following expression for the group of variables that multiplies velocity in the drag equation (at sea level)\n\n\\[\n{1\\over 2 m} \\rho A C  = {B \\over m} = .0039 + {.0058\\over 1 + e^{v - 35\\over 5}}\n\\]"
  }
]