[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Scientific Computing",
    "section": "",
    "text": "1 Python and Jupyter Notebooks\nJupyter Notebook",
    "crumbs": [
      "Basic Python",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Python and Jupyter Notebooks</span>"
    ]
  },
  {
    "objectID": "index.html#python",
    "href": "index.html#python",
    "title": "Scientific Computing",
    "section": "1.1 Python",
    "text": "1.1 Python\nPython is a computer programming language available on all major platforms (Mac, Windows, Linux). Python is a scripting language which means that the computer interprets and runs your code at the moment you run it. In contrast, with a compiled language like C the code must first be converted into binary before it can run (called “compiling” the code). There are pros and cons to both types of languages. The on-the-fly interpretation of Python makes it quick and easy to write code and provides fast results for simple calculations. When codes become longer and more complex, on-the-fly interpretation becomes less efficient and execution time will be much slower than it would be with a compiled language. The pros and cons flip for a compiled language; writing code in a compiled language can be cumbersome and slow, but the execution time is typically much faster. Out of necessity, most programmers become proficient in both types of languages. Python(or another interpreted language) is used to “toy around” with your problem and build familiarity. As the complexity of the code increases the user is then forced to transition to a compiled language to get the needed speed. This is the famous “two language” problem and there is a new programming language designed to eliminate this problem by combining the pros from both into one language. (The name of the language is Julia)\nPython is free, open source software and is maintained by the non-profit Python software foundation. This is great because it means that you will always have free access to the Python language regardless of what organization or university you are affiliated with. You’ll never have to worry about not being able to use your Python code without paying for it. Another benefit of open source languages is that all of the codes developed by other people are available for anyone to inspect, modify, and use. This allows anyone to review another’s code to ensure that it does what they say it does, or to modify it to do something else. One last benefit that comes with an open source language is the community of Python users available to answer questions and provide instruction to the beginner. Answers to most questions about python are readily available on tutorial or forum websites.",
    "crumbs": [
      "Basic Python",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Python and Jupyter Notebooks</span>"
    ]
  },
  {
    "objectID": "index.html#installing-software",
    "href": "index.html#installing-software",
    "title": "Scientific Computing",
    "section": "1.2 Installing Software",
    "text": "1.2 Installing Software\nThe first step is to install the software (if you haven’t already). The most convenient way to install Python and also get many of the commonly-used libraries is to use an installer. I recommend Anaconda. When installing the software be sure to choose Python 3 since this is the current version. By default, Anaconda will install a suit of softwares and libraries that are commonly used. If you want to install other Python libraries, open the Anaconda-Navigator (green circle icon) and select the Environment tab on the left. Select Not Installed from the pull-down to see all of the libraries that are available to be installed. To install a library, check the box next to it and click Apply. Anaconda will take care of the rest.\n\nTo Do:\n\nInstall Anaconda\nCheck to see if the library “numpy” is installed. If not, install it.",
    "crumbs": [
      "Basic Python",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Python and Jupyter Notebooks</span>"
    ]
  },
  {
    "objectID": "index.html#jupyter-notebooks",
    "href": "index.html#jupyter-notebooks",
    "title": "Scientific Computing",
    "section": "1.3 Jupyter Notebooks",
    "text": "1.3 Jupyter Notebooks\nA Jupyter notebook is an electronic document designed to support interactive data processing, analysis, and visualization in an easily shared format. A Jupyter notebook can contain live code, math equations, explanatory text, and the output of codes (numbers, plots, graphics, etc..). To launch a Jupyter notebook, first open Anaconda-Navigator (green circle icon) and click the Launch button under JupyterLab. Jupyter can also be launched from the command line by typing jupyter-lab. The jupyter notebook will launch in your default web browser, but it is not a website. From here you can select an already existing Jupyter notebook, denoted by the orange icons and the .ipynb extension, or create a new notebook by clicking New from the File menu.\n\nTo Do:\n\nAt the top of this page there is a link titled “Jupyter Notebook”. Click on that link to download the Jupyter notebook version of this chapter.\nLaunch JupyterLab as explained above.\nOpen the file that you downloaded in step 1 and continue reading this book in the jupyter notebook.\n\n\n\n1.3.1 Notebook Structure\nThere are two types of “cells” in a Jupyter notebook: code cells and text cells (also called Markdown cell). Code cells contain “live” Python code that can be run inside of the notebook with any output appearing directly below it. An example of a code cell is given below:\n\naccel = 9.8\ndt = 0.5\nvi = 10\nvf = vi + a * dt\nprint(vf)\n\nMarkdown cells are designed to contain explanatory information about what is happening inside of the code cells. They can contain text, math equations, and images. Markdown cells support markdown, html, and \\(\\mathrm{\\LaTeX}\\) (for generating pretty math equations).\nBoth markdown and code cells can be executed by either selecting Run Selected Cells in the Run menu, by clicking the Play icon at the top of the notebook, or by using the Shift-Return shortcut when your cursor is in the desired cell.\n\n\n1.3.2 \\(\\mathrm{\\LaTeX}\\)\nOften you will want to include math equations as part of your explanation/text. Below is an example of what your math should and should not look like.\n\n\\(|\\vec{v}|  = \\sqrt{v_x^2 + v_y^2}\\) (like this)\n\nv = sqrt(vx^2 + vy^2) (not like this)\n\nTo make your math equations look like the first example, you must enclose your math equation in “$$”, one pair at the beginnning of the equation and one pair at the end. Enclosing your expression in double dollar signs will put the expression on its own line. To place the expression in the middle of a sentence (inline) you’ll need to enclose the expression in single dollar signs. To generate the math symbols that often show up in equations, you’ll need to know the correct syntax. A table of commonly used math symbols is given below.\n\n\n\n\n\n\n\n\nMath symbol\nExample\n\\(\\mathrm{\\LaTeX}\\) syntax\n\n\n\n\nSubscript\n\\(v_x\\)\nv_x\n\n\nPowers\n\\(v^2\\)\nv^2\n\n\nPowers with more than one digit\n\\(v^{10}\\)\nv^{10}\n\n\nSquare root\n\\(\\sqrt{a + b}\\)\n\\sqrt{a + b}\n\n\nFractions\n\\(\\frac{a}{b}\\)\n\\frac{a}{b}\n\n\nVectors\n\\(\\vec{x}\\)\n\\vec{x}\n\n\nIntegrals\n\\(\\int x^2 dx\\)\n\\int x^2 dx\n\n\nPartial Derivatives\n\\({\\partial f \\over \\partial x}\\)\n{\\partial f \\over \\partial x}\n\n\nSummations\n\\(\\sum_{i = 1}^{10} x_i^2\\)\n\\sum_{i = 1}^{10} x_i^2\n\n\nInfinity\n\\(\\infty\\)\n\\infty\n\n\n\nYou can include Greek letters in your expressions if you know the corresponding syntax. The table below shows some of the more common Greek letters used in physics.\n\n\n\nGreek Letter\n\\(\\mathrm{\\LaTeX}\\) syntax\n\n\n\n\n\\(\\alpha\\)\n\\alpha\n\n\n\\(\\beta\\)\n\\beta\n\n\n\\(\\gamma\\)\n\\gamma\n\n\n\\(\\Delta\\)\n\\Delta\n\n\n\\(\\epsilon\\)\n\\epsilon\n\n\n\nA more comprehensive list of math symbols available can be found here\n\n\n1.3.3 Tables\nTables are often useful for presenting data. You can make a table in a jupyter notebook using the following syntax\n|t (s)       | v (m/s)     |\n|------------|-------------|\n| 0          | 10          |\n| 1.2        | 22          |\n| 2.3        | 25          |\n| 3.0        | 38          |\n| 5.5        | 56          |\nwhich will generate the following table:\n\n\n\nt (s)\nv (m/s)\n\n\n\n\n0\n10\n\n\n1.2\n22\n\n\n2.3\n25\n\n\n3.0\n38\n\n\n5.5\n56\n\n\n\n\n\n1.3.4 Navigating Jupyter Notebooks\nNavigating a Jupyter notebook is fairly straightforward but there are a few handy shortcuts/hotkeys that will make navigation quicker and your workflow more efficient. When working in a Jupyter notebook, you are always operating in one of two modes: edit mode or navigate mode. In edit mode you can make modifications to the text or code in a cell and in navigate mode you can add/delete cells and modify the cell type. If you can see a blinking cursor in one of the cells you are in edit mode. Otherwise you are in navigate mode. To exit edit mode, simply press the esc key and you will enter navigate mode. To exit navigate mode, simply press the enter key and you will enter edit mode for the cell you were focused on. (You can also double click on a cell with your mouse to enter edit mode.) The shift + enter key sequence will “execute” a cell and produce the associated output. For text cells, executing just means to render the text in a nicely formatted fashion. “Executing” a code cell will actually execute the code block contained in the cell. You also enter navigate mode every time you execute a cell using the shift + enter key sequence. A summary of these shortcuts is given below:\n\nUp/down arrows - Navigate to different cells in the notebook.\nY - turns a text cell into a code cell.\nM - turns a code cell into a text cell.\nA - inserts a new cell above the current cell.\nB - inserts a new cell below the current cell.\nX - deletes the current cell.\nenter - enters edit mode.\nshift + enter - execute a cell.\nesc - enter navigate mode.",
    "crumbs": [
      "Basic Python",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Python and Jupyter Notebooks</span>"
    ]
  },
  {
    "objectID": "index.html#tips-for-studying-jupyter-notebooks",
    "href": "index.html#tips-for-studying-jupyter-notebooks",
    "title": "Scientific Computing",
    "section": "1.4 Tips for studying Jupyter notebooks",
    "text": "1.4 Tips for studying Jupyter notebooks\n\n1.4.1 Print Statements\nJupyter notebooks in this class will be a nice mix of text cells (explanation) and code cells (examples). You will soon learn that code cells produce no output unless you explicitly tell them to using a print statement (similar to the one you used above). When you encounter a code cell, you should feel free to make modifications and additions to the cell until you fully understand how the code works.\n\n\n1.4.2 Comments\nComments are a way to describe what each section of code does and makes it easier for you and others to understand the code. It may seem clear what each section of code does as you write it, but after a week, month or longer, it is unlikely to be obvious. Paul Wilson of the University of Wisconsin at Madison is quoted as saying, “Your closest collaborator is you six months ago, but you don’t reply to emails.” Comment your code now so that you are not confused later.\nThere are several ways to add comments to your code:\n\nUse # to start a comment. Everything on the line that follows will be ignored.\nFor longer comments that will span several lines, use triple double quotes to begin and end the comment (\"\"\")\n\nThe cell below illustrates these two ways to make comments:\n\n# Speed of light in a vacuum\nc = 3e8\n\nv = 300 # Speed of sound in air\n\n\"\"\"\nThe variables below are the initial conditions for a cannon\nlaunching a ball at a 30 degree angle with an initial speed of\n50 m/s.  The initial height of the cannon ball is 1000 m\n\"\"\"\nv = 50\ntheta = 30\nh_i = 1000\n\n\nTo Do:\n\nExecute the code block below and verify that no output is produced.\nAdd print statements that help you see the result of the calculation.\nAdd simple comments next to each line explaining the code.\n\n\n\na = 2 \nb = 3 \nc = a**b",
    "crumbs": [
      "Basic Python",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Python and Jupyter Notebooks</span>"
    ]
  },
  {
    "objectID": "index.html#exercises",
    "href": "index.html#exercises",
    "title": "Scientific Computing",
    "section": "1.5 Exercises",
    "text": "1.5 Exercises\n\nPerform the following actions using the shortcuts above:\n\nAdd a cell below this one.\nTurn the cell into a code cell (observe the distinct appearance of code cells).\nIn the code cell, calculate the Stefan-Boltzmann constant using the equation given in the first column of the table found here. Add a print statement so you can verify that you did it correctly.\nExecute the cell using shift + enter. Observe the output.\nCreate another cell just below the code cell you just created.\nTurn it into a text/markdown cell if it isn’t already.\nUsing \\(\\mathrm{\\LaTeX}\\) syntax, write the equation from the table that you used to peform the calculation.\n“Execute” the cell and observe the new output.\n\nRecreate the first three columns of your top 10 favorite physical constants found here (same table as given in exercise 1). Pick constants that have Greek letters and fun mathematical equations associated with them.",
    "crumbs": [
      "Basic Python",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Python and Jupyter Notebooks</span>"
    ]
  },
  {
    "objectID": "chapters/variables.html",
    "href": "chapters/variables.html",
    "title": "2  Variables and Numbers",
    "section": "",
    "text": "2.1 Variables\nJupyter Notebook\nWhen performing mathematical operations, it is often desirable to store the values in variables for later use instead of manually typing them back in each time you need to use them. This will reduce effort because small changes to variables can automatically propagate through your calculations.\nAttaching a value to a variable is called assignment and is performed using the equal sign (=), as demonstrated in the cell below:\na = 5.0\nb = 3\nc = a + b",
    "crumbs": [
      "Basic Python",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Variables and Numbers</span>"
    ]
  },
  {
    "objectID": "chapters/variables.html#variables",
    "href": "chapters/variables.html#variables",
    "title": "2  Variables and Numbers",
    "section": "",
    "text": "2.1.1 Variable naming convention\nThere are some rules for allowed variable names in Python. They are as follows:\n\nVariable names must begin with a letter or an underscore (_)\nVariables names must only contain letters, numbers, and underscores.\nVariable names cannot contain spaces.\nVariables names cannot be a word reserved by Python for something else. These words are:\n\n\n\n\n\nPython\nreserved\nwords\n\n\n\n\n\nand\nas\nassert\nbreak\nclass\n\n\ncontinue\ndef\ndel\nelif\nelse\n\n\nexcept\nFalse\nfinally\nfor\nfrom\n\n\nglobal\nif\nimport\nin\nis\n\n\nlambda\nNone\nnonlocal\nnot\nor\n\n\npass\nraise\nreturn\nTrue\ntry\n\n\nwhy\nwith\nyield\n\n\n\n\n\nThe cell below contains some allowed variable names and some that are not allowed.\n\nTo Do:\n\nDetermine which variable names are allowed and which are not in the cell below.\nWhat does Python do if you try to define a variable using a name that is not allowed?\n\n\n\nmy1variable = 3\n1stvariables = 2\na big constant = 3\na_big_constant = 1e8\n\nIt is also a good practice to make variable names meaningful. For example, in the cell below we calculate \\(E = mc^2\\) using two choices for variable assignments. In one case, it is easy to determine what the calculation is and in the other it isn’t.\n\n# Good Variable Names\nmass_kg = 1.6\nlight_speed = 3.0e8\nenergy = mass_kg * light_speed**2\n\n\n# Poor Variable Names\na = 1.6\nb = 3.0e8\nc = a * b**2",
    "crumbs": [
      "Basic Python",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Variables and Numbers</span>"
    ]
  },
  {
    "objectID": "chapters/variables.html#numbers-integers-and-floats",
    "href": "chapters/variables.html#numbers-integers-and-floats",
    "title": "2  Variables and Numbers",
    "section": "2.2 Numbers: Integers and Floats",
    "text": "2.2 Numbers: Integers and Floats\nThere are two types of numbers in Python - floats and integers. Floats, short for “floating point numbers,” are values with decimals in them. They may be either whole or non-whole numbers such as 3.0 or 1.2, but there is always a decimal point. Integers are whole numbers with no decimal point such as 2 or 53.\nMathematical operations that only use integers and evaluate to a whole number will generate an integers (except for division). All other situations will generate a float. See the example cell below.\n\na = 24\nb = 6\nd = 0.3\ne = a + b # Produces an integer.\nf = a + d # Produces a float\ng = a * b # Produces a ???\nh = a / b # Produces a ???\n\n\nTo Do:\n\nFor each of the mathematical operations above guess what type of number the result will be.\nUse print statements to verify your guesses and formulate a general rule that you can rely on. (Tip, the type() function will tell you what kind of number a variable is.)\n\n\n\n# Python Code Here!\n\nIntegers and floats can be inter-converted to each other using the int() and float() functions.\n\nint(3.0)\nfloat(4)\n\n4.0\n\n\nThe distinction between floats and ints is often a minor detail. Occasionally, a function will require that an argument be a float or an int but usually you won’t have to worry about which one you use.\nBelow you will find some other common mathematical operations that can be performed on numerical variables.\n\na = 20\nb = 10\nc = a + b \nd = a/b  \nr = a//b\nr = a % b\ne = a * b\nf = c**4\n\n\nTo Do:\n\nUse print statements to investigate what each operation does.\n\nGuess what type of number you expect the result to produce (int or float) and then check yourself?\nAdd comments next to each line (Use # to start a comment) explaining that operation.\n\n\n\n# Python Code Here!\n\n\n2.2.1 Augmented Assignment\nAugmented assignment is a shortened way to make a simple modification to a variable. For example, if we want to increase the value of a variable by 10, one way to do it would be like this.\n\na = 5\na = a + 10\n\nThis is certainly not difficult, but it does involve typing the variable twice which becomes cumbersome as your variable name gets longer. Alternatively, we can accomplish the same thing with the += operator.\n\na = 5\na += 10\n\nAugmented assignment can be used with addition, subtraction, multiplication, and division as shown in the code cell below.\n\na = 7\na += 3\na -= 1\na *= 4\na /= 3\n\n\nTo Do:\n\nPredict what the final result of a will be in the code cell above.\nAdd an appropriately-place print statement to see if you were correct.\nIf you were wrong, pow-wow with your neighbor until you understand.\n\n\n\n# Python Code Here!\n\n\n\n2.2.2 Compound Assignment\nAt the beginning of a program or calculation, it is often necessary to define a set of variables. Each variable may get it’s own line of code, but if there are a lot of variables, this can begin to clutter your code a little. An alternative is to assign multiple variables on a single line. In the code below, we assign the atomic mass of the first three elements.\n\nH, He, Li = 1.01, 4.00, 5.39\n\n\nTo Do:\n\nUse print statements to verify that each variable was assigned it’s own value.\nAdd assignments for the atomic masses of the next three elements on the periodic table.\n\n\n\n# Python Code Here!\n\n\n\n2.2.3 Large numbers\nSometimes you find yourself working with large numbers in your calculation. Maybe your calculation involves the use of ten billion, which has 10 zeros in it. It can be difficult to look at all of those zeros with no commas to help break it up. In those cases, you can use an underscore (_) in place of the comma, as shown below.\n\nmyLargeNumber = 10000000000 # This is tough to look at.\nmyLargeNumber = 10_000_000_000  # This is easy to read\n\nmyLargeFloat = 5000000.6 # This is tough to read\nmyLargeFloat = 5_000_000.6 # This is easy to read\n\n\n\n2.2.4 Very Large Numbers\nIf your number is very large or very small ( \\(20-30\\) zeros), you would probably rather not have to type all of the zeros at all, even if you can break it up with the underscores. For example, the Boltzmann constant, which comes up in thermodynamics, has a value equal to\n\\[ 1.38 \\times 10^{-23}\\]\nWe can avoid typing all those zeros by using scientific notation when defining the variable. (see example below) This is super handy for very large and very small numbers. (Numbers of both variety show up frequently in physics!)\n\nkB = 1.38e-23\n\n\n\n2.2.5 Python functions\nIn addition to basic mathematical functions, python contains several mathematical functions. As in mathematics, a function has a name (e.g. f) and the arguments are places inside of the parenthesis after the name. The argument is any value or piece of information fed into the function. In the case below, f requires a single argument x. \\[f(x)\\]\nIn the cell below, you will find several useful Python functions.\n\nabs(-5.5)\nfloat(2)\nint(5.6)\nprint(1.26e-6)\nround(-5.51)\nstr(3.2)\n\n1.26e-06\n\n\n'3.2'\n\n\nIn addition to Python’s native collection of mathematical functions, there is also a math module with more mathematical functions. Think of a module as an add-on or tool pack for Python just like a library. The math module comes with every installation of python and can be imported (i.e. activated) using the import math command. After the module has been imported, any function in the module is called using math.function() where function is the name of the function. Below is a list of commonly-used functions inside the math module. Carefully look at each of them and guess what they mean.\n\nimport math\nmath.sqrt(4)\nmath.ceil(4.3)\nmath.cos(1.5)\nmath.sin(1.5)\nmath.tan(3.14)\nmath.asin(1)\nmath.acos(1/2)\nmath.atan(2)\nmath.degrees(6.28)\nmath.e\nmath.exp(5)\nmath.factorial(4)\nmath.log(200)\nmath.log10(1000)\nmath.radians(360)\nmath.pi\nmath.pow(2,8)\n\n256.0\n\n\n\nTo Do:\n\nUse print statements to figure out what each function in the code cell above does. Pay special attention to trigonometric function. Do these functions expect the argument to be in radians or degrees?\nAdd comments to remind yourself for later.\n\n\n\n# Python Code Here!\n\nThere are other ways to import functions from modules. If you only want to use a single function inside the module, you can selectively import it using from, as shown below.\n\nfrom math import radians\nradians(4)\n\n0.06981317007977318",
    "crumbs": [
      "Basic Python",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Variables and Numbers</span>"
    ]
  },
  {
    "objectID": "chapters/variables.html#errors-in-python",
    "href": "chapters/variables.html#errors-in-python",
    "title": "2  Variables and Numbers",
    "section": "2.3 Errors In Python",
    "text": "2.3 Errors In Python\nWhen you are learning to write code, you will inevitably run into errors. Seeing a block of red text can be intimidating at first, but it’s important to remember that errors are not failures; they are helpful signs. The error message is simply Python’s way of telling you that it couldn’t understand your instructions and often gives you a very specific clue about what went wrong.\nLearning to read these messages is a fundamental skill that will turn you into a more effective programmer. Let’s look at some of the most common errors you will encounter on your journey.\n\n2.3.1 Syntax Error\nA SyntaxError is the most common type of error for beginners. It means you have broken a grammar rule of the Python language. Just like a sentence in English needs correct punctuation to make sense, a line of Python code needs correct syntax.\n: Missing punctuation, like a colon :, a parenthesis ), or a quotation mark “.\nIn the example below, we forget to close the parentheses for the print function.\n\n# We are trying to print a message, but we forgot the closing parenthesis.\nprint(\"This line has a syntax error\"\n\n\n  Cell In[19], line 2\n    print(\"This line has a syntax error\"\n                                        ^\n_IncompleteInputError: incomplete input\n\n\n\n\n\n\n2.3.2 Indentation Error\nPython is unique because it uses whitespace (specifically, the spaces at the beginning of a line) to group code together. An IndentationError means that the spacing in your code is not correct or consistent.\n: Forgetting to indent code that belongs inside a loop, function, or if statement.\n\n# The line below should be indented, because it belongs inside the for loop.\nfor i in range(5):\nprint(i)\n\n\n  Cell In[20], line 3\n    print(i)\n    ^\nIndentationError: expected an indented block after 'for' statement on line 2\n\n\n\n\nYou can also get an IndentationError if there are multiple lines indented but their indentation levels are not consistent, as shown below.\n\n# Indentation error because the lines in the loop are not all indented\n# to the same position\nfor i in range(10):\n    print(i)\n     print(i**2)\n\n\n  Cell In[21], line 5\n    print(i**2)\n    ^\nIndentationError: unexpected indent\n\n\n\n\n\n\n2.3.3 NameError\nA NameError occurs when you try to use a variable or function that Python doesn’t recognize.\n: A typo in a variable name or trying to use a variable before you have assigned it a value.\n\n# We create a variable called 'initial_velocity'.\ninitial_velocity = 20\n\n# But then we make a typo when trying to print it. Python doesn't know what 'initial_velocite' is.\nprint(initial_velocite)\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[22], line 5\n      2 initial_velocity = 20\n      4 # But then we make a typo when trying to print it. Python doesn't know what 'initial_velocite' is.\n----&gt; 5 print(initial_velocite)\n\nNameError: name 'initial_velocite' is not defined\n\n\n\nSince Python executes code sequentially: the first line gets executed first, then the second line, etc., you can get a NameError if you try to use a variable before it is defined, as shown below.\n\ndx = 5.22\n\nv = dx/dt  # A NameError occurs at this line because dt is not yet defined.\n\ndt = 0.4\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[23], line 3\n      1 dx = 5.22\n----&gt; 3 v = dx/dt  # A NameError occurs at this line because dt is not yet defined.\n      5 dt = 0.4\n\nNameError: name 'dt' is not defined\n\n\n\n\n\n2.3.4 TypeError\nA TypeError means you are trying to do an operation with a data type that doesn’t support it. It’s like trying to add a word to a number—it just doesn’t make sense.\n: Trying to combine incompatible types, like adding a string and an integer.\n\n# You can't directly add a number (an integer) to a word (a string).\n# Python doesn't know if you mean to do math or combine text.\nmessage = \"The answer is: \" + 5\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[24], line 3\n      1 # You can't directly add a number (an integer) to a word (a string).\n      2 # Python doesn't know if you mean to do math or combine text.\n----&gt; 3 message = \"The answer is: \" + 5\n\nTypeError: can only concatenate str (not \"int\") to str\n\n\n\n\n\n2.3.5 IndexError\nAn IndexError happens when you try to access an item in a list using an index that is out of bounds.\n: Forgetting that list indices start at 0. For a list of 3 items, the only valid indices are 0, 1, and 2.\n\n# This list has three items.\nplanets = [\"Mercury\", \"Venus\", \"Earth\"]\n\n# The valid indices are 0, 1, and 2.\n# By asking for index 3, we are asking for a fourth item that doesn't exist.\nprint(planets[3])\n\n\n---------------------------------------------------------------------------\nIndexError                                Traceback (most recent call last)\nCell In[25], line 6\n      2 planets = [\"Mercury\", \"Venus\", \"Earth\"]\n      4 # The valid indices are 0, 1, and 2.\n      5 # By asking for index 3, we are asking for a fourth item that doesn't exist.\n----&gt; 6 print(planets[3])\n\nIndexError: list index out of range\n\n\n\n\n\n2.3.6 FileNotFoundError\nThis is a very common error when you start working with data. It simply means that you are trying to open a file that Python cannot find at the location you specified.\n: A typo in the filename or the file not being in the same folder as your script.\n\n# Python will look in the current folder for a file with this name.\n# If it can't find it, it will raise this error.\nwith open(\"data_that_does_not_exist.csv\") as f:\n    print(f.read())\n\n\n---------------------------------------------------------------------------\nFileNotFoundError                         Traceback (most recent call last)\nCell In[26], line 3\n      1 # Python will look in the current folder for a file with this name.\n      2 # If it can't find it, it will raise this error.\n----&gt; 3 with open(\"data_that_does_not_exist.csv\") as f:\n      4     print(f.read())\n\nFile ~/environments/lammps_env/lib/python3.13/site-packages/IPython/core/interactiveshell.py:343, in _modified_open(file, *args, **kwargs)\n    336 if file in {0, 1, 2}:\n    337     raise ValueError(\n    338         f\"IPython won't let you open fd={file} by default \"\n    339         \"as it is likely to crash IPython. If you know what you are doing, \"\n    340         \"you can use builtins' open.\"\n    341     )\n--&gt; 343 return io_open(file, *args, **kwargs)\n\nFileNotFoundError: [Errno 2] No such file or directory: 'data_that_does_not_exist.csv'",
    "crumbs": [
      "Basic Python",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Variables and Numbers</span>"
    ]
  },
  {
    "objectID": "chapters/strings.html",
    "href": "chapters/strings.html",
    "title": "3  Strings",
    "section": "",
    "text": "3.1 Creating Strings\nJupyter Notebook\nAnother commonly-used type of data is a string of characters known simply as strings. Strings can contain a variety of characters including letters, numbers, and symbols.\nStrings are created by placing the sequence of characters in single (or double) quotes.\ntext = \"some text\"\nStrings can also be created by converting a float or an integer into a string using the str() function.\ntext = str(4.5)\nOne common error made when working with strings is to attempt to perform math with them. Python will not perform math with strings because it sees them as a series of characters and nothing more. In the cell below, we attempt to perform math with some strings.\na = \"4\"\nb = \"2\"\nc = 5\n\nd = a + b\ne = a * b\nf = b * c\n# Python Code Here!\nIf you want to know the length of a string, you can use the len() function\ntext = \"some text\"\nlen(text)\n\n9\nThe length of the string above is 9 because a space is a valid character.",
    "crumbs": [
      "Basic Python",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Strings</span>"
    ]
  },
  {
    "objectID": "chapters/strings.html#creating-strings",
    "href": "chapters/strings.html#creating-strings",
    "title": "3  Strings",
    "section": "",
    "text": "To Do:\n\nUse print statements in the cell above to determine what happens when you add two strings together. (Ancillary question: Can you subtract strings?)\nUse print statements in the cell above to determine what happens when you multiply two strings.\nUse print statements in the cell above to determine what happens when you multiply a string and an integer.\nWhat do you think will happen if you multiplied a string and a float? Guess and then see if you’re right.\nAdd comments for you to refer back to later.",
    "crumbs": [
      "Basic Python",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Strings</span>"
    ]
  },
  {
    "objectID": "chapters/strings.html#displaying-text-and-numbers-together",
    "href": "chapters/strings.html#displaying-text-and-numbers-together",
    "title": "3  Strings",
    "section": "3.2 Displaying text and numbers together",
    "text": "3.2 Displaying text and numbers together\nYou have been using print() statements quite a lot lately (hopefully) but you probably haven’t printed text and numbers together. To display both text and numbers in the same message, there are several options. The first is to just put multiple variables into the print() function, separating them with commas.\n\ng = 9.8\nunit = \"m/s^2\"\nprint(g,unit)\n\n9.8 m/s^2\n\n\nAnother option is to convert the number to a string and then “add” it to the other string. This creates a single string as an argument to the print() function.\n\ng = 9.8\nunit = \"m/s^2\"\nprint(str(g) + unit)\n\n9.8m/s^2\n\n\nNotice the lack of space between the number and the unit. “Adding” the two strings smashed them together exactly as they were, no spaces added. You can insert multiple numbers into a string using something called “f”-strings. (short for formatted strings). To construct an f-string, simply place an “f” in front of the string. Anytime you want to insert a number in your string, enclose it in curly braces.\n\nv = 5.0\nc = 3e8\nprint(f\"The speed of light is {c} and the speed of my car is {v}\")\n\nThe speed of light is 300000000.0 and the speed of my car is 5.0\n\n\nThat’s a clever way to insert a numerical value into a string, but the value of the speed of light is still displaying too many digits. To specify how the number should be formatted place a : after the variable name followed by a formatting tag.\n\nv1 = 5.0\nv2 = 8.3\nc = 2.998e8\nn = 2\n\nprint(f\"There are {n:d} cars traveling side by side.  One car is traveling at {v1:4.2f} m/s and the other is traveling at {v2:4.2f} m/s.  Those speeds are much smaller than the speed of light, which is {c:.2e} m/s\") \n\nThere are 2 cars traveling side by side.  One car is traveling at 5.00 m/s and the other is traveling at 8.30 m/s.  Those speeds are much smaller than the speed of light, which is 3.00e+08 m/s\n\n\nThe structure of the stuff inside of the curly braces is {variable:formatcode}; variable holds the value to be displayed and formatcode indicates how the variable should be formatted when it is printed. The f in :4.2f indicates that the variable should be displayed as a float and the 4.2 indicates that four spaces should be allocated to display the number and no more than 2 numbers after the decimal should be displayed. A selection of some commonly-used format codes is given below.\n\nA summary of common format codes.\n\n\n\n\n\n\nformat code\nexplanation\n\n\n\n\n{variable}\nUse the default format for the data type.\n\n\n{variable:4d}\nDisplay as an integer, allocating 4 spaces for it.\n\n\n{variable:.4f}\nDisplay as a float, with four numbers after the decimal being displayed.\n\n\n{variable:8.4f}\nDisplay as a float, allocating 8 total spaces and 4 numbers after the decimal place.\n\n\n{variable:8.4e}\nDisplay using scientific notation, allocating 8 total spaces and 4 numbers after the decimal place.\n\n\n{variable:6s}\nDisplay as a string, allocating 6 total spaces for it. If the string is longer than 6 spaces, it will display the entire string with no extra white space. If the string is shorter than 6 spaces, it will pad the string with whitespace until it is 6 spaces long.\n\n\n\n\nTo Do:\n\nModify the print statement above so that the float variables are given 8 total spaces with only 1 number after the decimal being displayed.\nModify the print statement above so that the speed of light is displayed with 3 numbers after the decimal place.\n\n\n\n# Python Code Here!",
    "crumbs": [
      "Basic Python",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Strings</span>"
    ]
  },
  {
    "objectID": "chapters/strings.html#indexing-and-slicing",
    "href": "chapters/strings.html#indexing-and-slicing",
    "title": "3  Strings",
    "section": "3.3 Indexing and Slicing",
    "text": "3.3 Indexing and Slicing\nAccessing a piece (or slice) of a string is a common task in scientific computing. Often you will import data into Python from a text file and need to extract a portion of the file for later use in calculations. Indexing allows the user to extract a single element, or character, from a string. The key detail about indexing in Python is that indices start from zero. That means that the first character is index zero, the second character is index 1, and so on. For example, maybe a string contains the following amino acid sequence ‘MSLFKIRMPE’. For this example, the indices are as follows:\n\n\n\nCharacters\nM\nS\nL\nF\nK\nI\nR\nM\nP\nE\n\n\n\n\nIndex\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\nTo access a single character from a string, place the desired index in square brackets after the name of the string.\n\nseq = \"MSLFKIRMPE\"\nseq[0]\n\n'M'\n\n\nTo access the last character in a string you could do\n\nseq = \"MSLFKIRMPI\"\nseq[len(seq) - 1]\n\n'I'\n\n\nBut this seems overly cumbersome. An easier approach is to index backwards. The string can be reverse indexed from the last character to the first using negative indices, starting with -1 as the last charcter.\n\nseq = \"MSLFKIRMPE\"\nseq[-1]\n\n'E'\n\n\n\nTo Do:\n\nAccess the 5th character in the peptide sequence above.\nAccess the character that is 3rd from the end in the peptide sequence above.\n\n\n\n# Python Code Here!\n\nIndexing only provides a single character, but it is common to want a series of characters from a string. Slicing allows us to grab a section of a string. Slicing is performed by specifying start and stop indices separated by a colon in the square brackets. One important detail worth mentioning: the character at the starting index is included in the slice while the character located at the final index is not included in the slice.\n\nseq = \"MSLFKIRMPE\"\nseq[0:5]\n\n'MSLFK'\n\n\nLooking at the string, you notice that the character at location 5 (I) has been excluded from the slice. You can leave off the first number when slicing and the slice will start at the beginning of the string.\n\nseq = \"MSLFKIRMPE\"\nseq[:5]\n\n'MSLFK'\n\n\nYou can also use negative indices when slicing. This is especially helpful when you want to grab the last few characters in a string.\n\nfile = \"data.txt\"\next = file[-3:]\nprint(ext)\n\ntxt\n\n\nFinally, we can adjust the step size in the slice. That is, we can ask for every other character in the string by setting a step size of 2. The structure of the slice is [start,stop,step].\n\nseq = \"MSLFKIRMPE\"\nseq[0:8:2]\n\n'MLKR'\n\n\nYou can omit the start and stop indices and Python will assume that you are slicing the entire string.\n\nseq = \"MSLFKIRMPE\"\nseq[::2]\n\n'MLKRP'",
    "crumbs": [
      "Basic Python",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Strings</span>"
    ]
  },
  {
    "objectID": "chapters/strings.html#string-methods",
    "href": "chapters/strings.html#string-methods",
    "title": "3  Strings",
    "section": "3.4 String Methods",
    "text": "3.4 String Methods\nA method is a function that works only with a specific type of object. String methods only work on strings, and they don’t work on other types of objects, like floats or ints. If it helps you, you can just think of a method as a function.\nOne example of a string method is the capitalize() function which returns a string with the first letter capitalized. To use a method (referred to as calling the method), the method name is appended to the variable you want it to operate on. For example, below is an Albert Einstein quote that needs capitalized.\n\nquote = \"i want to know God's thoughts. The rest are details.\"\nquote.capitalize()\nprint(quote)\n\ni want to know God's thoughts. The rest are details.\n\n\nNotice that the original variable (quote) remains unchanged. This particular method does not change the value of the original string but rather returns a capitalized version of it. If we want to save the capitalized version, we can assign it to a new variable, or overwrite the original.\n\nquote = \"i want to know God's thoughts. The rest are details\"\nquote = quote.capitalize()\nprint(quote)\n\nI want to know god's thoughts. the rest are details\n\n\nIn the cell below you will find a list of commonly-used string methods.\n\na = \"spdfgssfpggg\"\na.capitalize()\na.center(10)\na.count(\"s\")\na.find(\"d\")\na.isalnum()\na.isalpha()\na.isdigit()\na.lstrip(\"s\")\na.rstrip(\"g\")\na.split(\"s\")\na.replace(\"sss\",\"ggg\")\na.startswith(\"s\")\na.endswith(\"p\")\n\nseparator = \",\"\nseparator.join([\"hydrogen\", \"nitrogen\", \"oxygen\"])\n\n'hydrogen,nitrogen,oxygen'\n\n\n\nTo Do:\n\nUse well-placed print statements to determine what each string method does.\nAdd comments next to each method for future reference.\n\n\n\n# Python Code Here!",
    "crumbs": [
      "Basic Python",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Strings</span>"
    ]
  },
  {
    "objectID": "chapters/booleans.html",
    "href": "chapters/booleans.html",
    "title": "4  Boolean Variables and Conditional Execution",
    "section": "",
    "text": "4.1 Boolean Variables\nJupyter Notebook\nWe have learned about three types of variables in Python: ints, floats, and strings. Another variable type is a boolean, which can be one of two values: True or False. You can assign a boolean variable in the same way that you assign numbers or string, using =\nmyBool = True\nTrue must be capitalized so don’t try true or it won’t be a boolean\nmyBool = true",
    "crumbs": [
      "Basic Python",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Boolean Variables and Conditional Execution</span>"
    ]
  },
  {
    "objectID": "chapters/booleans.html#boolean-variables",
    "href": "chapters/booleans.html#boolean-variables",
    "title": "4  Boolean Variables and Conditional Execution",
    "section": "",
    "text": "4.1.1 Boolean Logic\nOften you will want to check to see if some condition is true. For example, maybe you want to know if the radius of a certain satellite’s orbit is bigger or smaller than Mercury’s orbit. To perform this check, there are several boolean operators that will return True or False. Take note of the boolean operators shown in the cell below along with the comments added to explain what they do.\n\nr1 = 3.5e8\nr2 = 2.7e6\n\nr1 &gt; r2 # Is r1 greater than r2\nr1 &lt; r2 # Is r1 less than r2\nr1 &gt;= r2 # Is r1 greater than or equal to r2\nr1 &lt;= r2 # Is r1 less than or equal to r2\nr1 != r2 # Is r1 not equal to r2\nr1 == r2 # Is r1 equal to r2\n\nFalse\n\n\nA word of caution about comparing Python floats using == is in order here. Python floats are stored as a 53-digit, base-2 binary number(that’s a mouthful). If you’re interested in what that means, we can talk more. If you’re not that interested, just know that when you define a float in Python, the number that is stored in the computer is not exactly the number that you think it is. This can cause problems when you are comparing two numbers that you think should be equal but actually aren’t equal in the computer.1 The code below illustrates this problem.\n\na = 0.1\nb = 3 * a\nc = 0.3\nprint(b==c)  # Are they the same number?  You would think they would\n             # be right?\nprint(\" {:.5f} \".format(b))     # They sure look the same.\nprint(\" {:.5f} \".format(c))     # They sure look the same.\nprint(\" {:.45f} \".format(b))  #b--- out to 45 decimal places\nprint(\" {:.45f} \".format(c))  #c--- out to 45 decimal places\n\nFalse\n 0.30000 \n 0.30000 \n 0.300000000000000044408920985006261616945266724 \n 0.299999999999999988897769753748434595763683319 \n\n\nThe first two print statements display the value of b and c to five decimal places. The second two print statements force Python to display the value of b and c out to 45 decimal places. Notice that the true value of b is not exactly equal to 0.3. This is why the statement print(b==c) returns False. The take home message here is that comparing two floats to see if they are equal is always a bad idea. A better way to check to see if two floats are equal (or close enough that we can say they are equal) is to check if the absolute value of their difference is very small, like this:\n\na = 0.1\nb = 3 * a\nc = 0.3\nprint(abs(b - c) &lt; 1e-10)\n\nTrue\n\n\n\n\n4.1.2 Compound Comparisons (Logical Operators)\nComparisons like those shown above can be chained together to make compound comparisons using the and, or, and not operators.\n\n\n\nOperator\nDescription\n\n\n\n\nand\nTests for both being True\n\n\nor\nTests for either being True\n\n\nnot\nTests for False\n\n\n\nThe and operator requires both inputs to be True in order to return True while the or operator requires only one input to be True in order to evaluate at True. The not operator is different in that it only takes a single input value and returns True if and only if the input is False. It is a test for False.\nTruth tables are a good way to visualize the output from compound comparisons.\n\n\n\np\nq\np and q\np or q\n\n\n\n\nTrue\nTrue\nTrue\nTrue\n\n\nTrue\nFalse\nFalse\nTrue\n\n\nFalse\nTrue\nFalse\nTrue\n\n\nFalse\nFalse\nFalse\nFalse\n\n\n\nAs a simple example, suppose you know the density (\\(\\rho\\)) and speed of light (c) for two materials and you’d like to know if both values are bigger for material 1 or material 2.\n\nTo Do:\n\nPredict the output for each compound comparison given below. Add your guess as a comment.\nNow add appropriately-placed print statements to check your guesses.\nModify your guess as needed and discuss any questions with a neighbor.\n\n\n\nc1 = 2.5e8\nc2 = 2.48e8\nρ1 = 450\nρ2 = 580\n\nc1 &gt; c2 and ρ1 &gt; ρ2\nc1 &lt; c2 and ρ1 &lt; ρ2\nc1 &gt; c2 and ρ1 &lt; ρ2\nc1 &lt; c2 and ρ1 &gt; ρ2\n\nc1 &gt; c2 and not ρ1 &gt; ρ2\nc1 &lt; c2 and not ρ1 &lt; ρ2\n\nc1 &gt; c2 or ρ1 &gt; ρ2\nc1 &lt; c2 or ρ1 &lt; ρ2\n\nTrue\n\n\n\n\n4.1.3 Tests for Inclusion\nYou can check for inclusion using the Python in operator. This provides an easy way to see if a character (or word) is present in a long string. Let’s say you have a long string that contains the names of Jupyter’s moons (there are 79 of them!!) and you want to see if a certain moon is included in the list. The in statement let’s us quickly test to see if it is in the list. (see example below)\n\njupytermoons = \"Metis,Adrastea,Amalthea,Thebe,Io,Europa,Ganymede,Callisto,Themisto,Leda,Himalia,Lysithea,Elara,Dia,Carpo,Euporie,Thelxinoe,Euanthe,Helike,Orthosie,Iocaste,Praxidike,Harpalyke,Mneme,Hermippe,Thyone,Ananke,Herse,Aitne,Kale,Taygete,Chaldene,Erinome,Aoede,Kallichore,Kalyke,Carme,Callirrhoe,Eurydome,Pasithee,Kore,Cyllene,Eukelade,Pasiphae,Hegemone,Arche,Isonoe,Sinope,Sponde,Autonoe,Megaclite\"\n\n\"Cyllene\" in jupytermoons\n\nTrue",
    "crumbs": [
      "Basic Python",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Boolean Variables and Conditional Execution</span>"
    ]
  },
  {
    "objectID": "chapters/booleans.html#conditions",
    "href": "chapters/booleans.html#conditions",
    "title": "4  Boolean Variables and Conditional Execution",
    "section": "4.2 Conditions",
    "text": "4.2 Conditions\nConditions allow the user to specify if and when certain lines or blocks of code are executed. Specifically, when a condition is true, the block of indented code directly below it will run.\n\n4.2.1 if statement\nThe if statement is used to control when a block of code runs. Its usage is shown below ending in a colon and the block of code below indented with four spaces. Using the Tab key will also produce four spaces.\n\njupytermoons = \"Metis,Adrastea,Amalthea,Thebe,Io,Europa,Ganymede,Callisto,Themisto,Leda,Himalia,Lysithea,Elara,Dia,Carpo,Euporie,Thelxinoe,Euanthe,Helike,Orthosie,Iocaste,Praxidike,Harpalyke,Mneme,Hermippe,Thyone,Ananke,Herse,Aitne,Kale,Taygete,Chaldene,Erinome,Aoede,Kallichore,Kalyke,Carme,Callirrhoe,Eurydome,Pasithee,Kore,Cyllene,Eukelade,Pasiphae,Hegemone,Arche,Isonoe,Sinope,Sponde,Autonoe,Megaclite\"\n\nif \"Cyllene\" in jupytermoons:\n    found = True\n    print(\"Found Cyllene in the list\")\n    \nif \"Matis\" in jupytermoons:\n    found = True\n    print(\"Found Matis in the list\")\n\nFound Cyllene in the list\n\n\nIf the boolean statement after if is true, the indented code below it will run. If the statement is false, Python just skips the indented lines below. The end of an if code block is determined by the indentation; to signal the end of the block, simply step back the indentation.\n\n\n4.2.2 else Statement\nSometimes there will be an alternate block of code that you want to run if the if statement evaluates to False. The else statement is used to specify this block of code, as shown below.\n\njupytermoons = \"Metis,Adrastea,Amalthea,Thebe,Io,Europa,Ganymede,Callisto,Themisto,Leda,Himalia,Lysithea,Elara,Dia,Carpo,Euporie,Thelxinoe,Euanthe,Helike,Orthosie,Iocaste,Praxidike,Harpalyke,Mneme,Hermippe,Thyone,Ananke,Herse,Aitne,Kale,Taygete,Chaldene,Erinome,Aoede,Kallichore,Kalyke,Carme,Callirrhoe,Eurydome,Pasithee,Kore,Cyllene,Eukelade,Pasiphae,Hegemone,Arche,Isonoe,Sinope,Sponde,Autonoe,Megaclite\"\n\nif \"Cyllene\" in jupytermoons:\n    found = True\n    print(\"Found Cyllene in the string\")\nelse:\n    found = False\n    print(\"Did not find Cyllene in the string\")\n\n    \nif \"Matis\" in jupytermoons:\n    found = True\n    print(\"Found Matis in the string\")\nelse:\n    found = False\n    print(\"Did not find Matis in the string\")\n\nFound Cyllene in the string\nDid not find Matis in the string\n\n\nNotice that the else statement must be followed by a colon and the block of code to be executed is indented, just as in the if block.\nThere is an additional statement called the elif statement, short for “else if”, which is used to add extra conditions below the initial if statement. The block of code below the elif statement only runs if the if statement is false and the elif statement is true. An example is given below.\n\njupytermoons = \"Metis,Adrastea,Amalthea,Thebe,Io,Europa,Ganymede,Callisto,Themisto,Leda,Himalia,Lysithea,Elara,Dia,Carpo,Euporie,Thelxinoe,Euanthe,Helike,Orthosie,Iocaste,Praxidike,Harpalyke,Mneme,Hermippe,Thyone,Ananke,Herse,Aitne,Kale,Taygete,Chaldene,Erinome,Aoede,Kallichore,Kalyke,Carme,Callirrhoe,Eurydome,Pasithee,Kore,Cyllene,Eukelade,Pasiphae,Hegemone,Arche,Isonoe,Sinope,Sponde,Autonoe,Megaclite\"\n\nif \"Matis\" in jupytermoons:\n    foundMatis = True\n    print(\"Found Matis in the string\")\nelif \"Cyllene\" in jupytermoons:\n    foundCyllene = True\n    print(\"Found Cyllene in the string.\")\nelse:\n    foundCyl = False\n    foundMatis = False\n    print(\"Did not find Cyllene or Matis in the string\")\n\nFound Cyllene in the string.\n\n\nIt is worth noting that else statements are not required. If you leave the else statement off and the if statement is false, no code block will execute.",
    "crumbs": [
      "Basic Python",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Boolean Variables and Conditional Execution</span>"
    ]
  },
  {
    "objectID": "chapters/booleans.html#footnotes",
    "href": "chapters/booleans.html#footnotes",
    "title": "4  Boolean Variables and Conditional Execution",
    "section": "",
    "text": "There is a library called Decimal that will fix a lot of these problems.↩︎",
    "crumbs": [
      "Basic Python",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Boolean Variables and Conditional Execution</span>"
    ]
  },
  {
    "objectID": "chapters/listsAndTuples.html",
    "href": "chapters/listsAndTuples.html",
    "title": "5  Lists and Tuples",
    "section": "",
    "text": "5.1 Creating Lists\nJupyter Notebook\nUp to this point, we have only worked with single numerical values or strings (multiple characters). Often we will want to work with collections of values (perhaps the orbital period of all of the planets in our solar system.) and it will be quite inconvenient to store each value into its own variable. Instead, the values can be stored in a list or tuple. Lists and tuples are both collections of elements , like numbers or strings. The key difference between them is that tuples are immutable, which means they cannot be modified after their initial creation. On the other hand, lists are mutable, or able to be modified.\nThe easiest way to create a list is by putting the list elements inside of square brackets. Below, we create a list containing the masses of all of the planets in our solar system.\nmass = [1.8986e27,5.6846e26,10.243e25,8.6810e25,5.9736e24,4.8685e24,6.4185e23,3.3022e23]\nNote that square brackets ([]) must be used when creating the list. If you accidentally use parenthesis (())1 or curly brackets ({})2 you’ll end up creating something other than a list.\nLists can contain any type of data and the type of data doesn’t have to be the same for all of the elements. Below, we create a list of the electron configurations for the first 10 elements on the periodic table.\nelectrons = [\"1s1\",\"1s2\", \"1s2-2s1\",\"1s2-2s2\",\"1s2-2s2-2p1\",\"1s2-2s2-2p2\",\"1s2-2s2-2p3\",\"1s2-2s2-2p4\",\"1s2-2s2-2p5\",\"1s2-2s2-2p6\"]\nLists can contain mixed data types. Below we construct a list of the electrical conductivities of three metals.\nconductivity = [\"Gold\",4.10e7,\"Copper\",5.96e7,\"Aluminum\",3.5e7]\nIf the elements of a list are also lists, we call it a nested list.\nconductivity = [[1,2,3],[4,5,6],[7,8,9]]",
    "crumbs": [
      "Basic Python",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Lists and Tuples</span>"
    ]
  },
  {
    "objectID": "chapters/listsAndTuples.html#creating-lists",
    "href": "chapters/listsAndTuples.html#creating-lists",
    "title": "5  Lists and Tuples",
    "section": "",
    "text": "1 Use parenthesis to create a tuple, which is just like a list but cannot be modified.2 Use curly brackets to create a dictionary, which is like a list but can be indexed on any data type, not just integers.\n\n\n\n\n\n\n5.1.1 The range function\nOften it will be necessary to generate a (possibly very long) list of integers. Instead of constructing the list by typing these numbers one by one, Python has a built-in function called range() that will do it for you. The range() function requires at least one argument to tell it how high the range should be.\n\na = range(10)  # Generate a list of integers up to 10\na\n\nrange(0, 10)\n\n\nThis output probably wasn’t what you expected. Instead of generating the full list of numbers, Python generates a range object that stands in place of it because it requires less memory. (Consider what might happen to your computer’s memory if you did range(1000000000000).) To force Python to generate the list, you can convert the range object into a list using the list() function.\n\na = range(10)  # Generate a list of integers up to 10\nlist(a)\n\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\nThe range function can be called with up to three arguments: range(start,end,stepsize). Consistent with indexing, the range includes the start value and excludes the end value. Below we generate a list of integers starting at 5, ending at 100 with a step size of 5.\n\nmyList = range(5,100,5)\nlist(myList)\n\n[5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95]\n\n\n\nTo Do:\nUse the range function to generate a list of even numbers from 8 to 88. (the list should include 88!)\n\n\n# Python Code Here!",
    "crumbs": [
      "Basic Python",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Lists and Tuples</span>"
    ]
  },
  {
    "objectID": "chapters/listsAndTuples.html#indexing-and-slicing-lists",
    "href": "chapters/listsAndTuples.html#indexing-and-slicing-lists",
    "title": "5  Lists and Tuples",
    "section": "5.2 Indexing and Slicing Lists",
    "text": "5.2 Indexing and Slicing Lists\nIndexing is used to access individual elements of a list, and it is similar to indexing strings. The index is the position of the desired element in the list and the index numbering starts at zero. Accessing an element of a list is done by placing the numerical index of the element we want in square brackets behind the list name. For example, if we want the electron configuration of the first element in our list from above, we use electrons[0] and the electron configuration for the second element would be electrons[1] and so on. Just as with string, negative indices can be used to access list elements counting from the back of the list forward.\n\nelectrons = [\"1s1\",\"1s2\", \"1s2-2s1\",\"1s2-2s2\",\"1s2-2s2-2p1\",\"1s2-2s2-2p2\",\"1s2-2s2-2p3\",\"1s2-2s2-2p4\",\"1s2-2s2-2p5\",\"1s2-2s2-2p6\"]\n\nelectrons[1]\nelectrons[-2]\nelectrons[5]\nelectrons[-1]\n\n\nTo Do:\n\nPredict the output for each of the indexes performed in the cell above.\nUse print statements to check your answers.\nDiscuss any misunderstandings with a peer.\n\n\n\n# Python Code Here!\n\nAccessing elements of nested lists requires multiple sets of parenthesis.\n\nconductivity = [[1,2,3],[4,5,6],[7,8,9]]\n\nx = conductivity[1][0]\ny = conductivity[0][2]\n\n\nTo Do:\n\nPredict the output for each of the indexes performed in the cell above.\nUse print statements to check your answers.\nDiscuss any misunderstandings with a peer.\n\n\n\n# Python Code Here!\n\nSince lists are mutable, we can modify the value of an element in a list using the = operator.\n\nconductivity = [\"Gold\",4.10e7,\"Copper\",5.96e7,\"Aluminum\",3.5e7]\n\nconductivity[1] = 4.15e7\nconductivity\n\n['Gold', 41500000.0, 'Copper', 59600000.0, 'Aluminum', 35000000.0]\n\n\n\nTo Do:\n\nUse a print statement to verify that the conductivity list was indeed modified as expected.\nModify the third element to be “Platinum” and the fourth to be the conductivity of Platinum (9.43e6).\n\n\n\n# Python Code Here!\n\nMultiple list elements can be retrieved at once (called slicing) by including the start and stop indices separated by a colon: [start:stop:step]. A convention that occurs throughout python is that the first index is included in the slice but the second is not. (i.e. [included: excluded: step]) Default values for the start location, stop location, and step sizes will be used if these values are omitted. Below we give some examples of slicing.\n\nelectrons = [\"1s1\",\"1s2\", \"1s2-2s1\",\"1s2-2s2\",\"1s2-2s2-2p1\",\"1s2-2s2-2p2\",\"1s2-2s2-2p3\",\"1s2-2s2-2p4\",\"1s2-2s2-2p5\",\"1s2-2s2-2p6\"]\n\nelectrons[1:]\nelectrons[1:3]\nelectrons[:3]\nelectrons[1:8:2]\nelectrons[5:2:-1]\n\n\nTo Do:\n\nPredict the output for the five slices in the cell above.\nUse print statements to check your answers.\nDiscuss any misunderstandings with a peer.\nNow use list slicing to extract every third element of the list in the cell above starting at the beginning.\n\n\n\n# Python Code Here!",
    "crumbs": [
      "Basic Python",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Lists and Tuples</span>"
    ]
  },
  {
    "objectID": "chapters/listsAndTuples.html#tests-for-inclusion",
    "href": "chapters/listsAndTuples.html#tests-for-inclusion",
    "title": "5  Lists and Tuples",
    "section": "5.3 Tests for Inclusion",
    "text": "5.3 Tests for Inclusion\nJust as with strings, the in operator can be used with lists to determine if a list element is present. Suppose you have a list of all the known radioactive elements on the periodic table and you’d like to know if Iridium is in the list. The in statement let’s us quickly test to see if it is in the list. (see example below)\n\nradioactiveElements = [\"Technetium\",\"Promethium\",\"Polonium\",\"Astatine\",\"Radon\",\"Francium\",\"Radium\", \"Actinium\", \"Thorium\", \"Protactinium\",\"Uranium\",\"Neptunium\",\"Plutonium\",\"Americium\",\"Curium\",\"Berkelium\",\"Californium\",\"Einsteinium\",\"Fermium\",\"Mendelevium\",\"Nobelium\",\"Lawrencium\",\"Rutherfordium\",\"Dubnium\",\"Seaborgium\",\"Bohrium\",\"Hassium\",\"Meitnerium\",\"Darmstadtium\",\"Roentenium\",\"Copernicium\",\"Nihonium\",\"Flerovium\",\"Moscovium\",\"Livermorium\",\"Tennessine\", \"Oganesson\"]\n\n\"Iridium\" in radioactiveElements\n\nFalse\n\n\nThe in operator will work with numerical data as well.\n\nnumbers = [5,6,3,1,2]\n\n4 in numbers\n\nFalse",
    "crumbs": [
      "Basic Python",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Lists and Tuples</span>"
    ]
  },
  {
    "objectID": "chapters/listsAndTuples.html#list-methods",
    "href": "chapters/listsAndTuples.html#list-methods",
    "title": "5  Lists and Tuples",
    "section": "5.4 List Methods",
    "text": "5.4 List Methods\nLists have a collection of methods (or functions) for accomplishing routine tasks. Some of the more common list methods are given below. All of the methods given will modify the original list (except copy()). As a reminder, methods only work on the object type that they were designed for (lists in this case) and they are called by appending the method name to the variable you want it to operate on. (e.g. myList.clear())\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\nappend(element)\nAdds a single element to the end of the list.\n\n\nclear()\nRemoves all elements from a list.\n\n\ncopy()\nCreates an independent copy of the list.\n\n\ncount(element)\nCounts the number of occurrences of element in the list.\n\n\nextend([a,b,c,...])\nAdds multiple elements to the end of the list.\n\n\nindex(element)\nReturns the index of the first occurrence of element.\n\n\ninsert(index,element)\nInserts the given element at the specified index.\n\n\npop(index)\nRemoves and returns the element given at index. If no index is provided, it defaults to the last element.\n\n\nremove(element)\nRemoves the first occurrence of element in the list.\n\n\nreverse()\nReverses the order of the entire list.\n\n\nsort()\nSorts the list in place.3\n\n\n\n3 It modifies the original list. In contrast, the function sorted() will leave the original list unchanged.\nTo Do:\nIn the cell below you will find a list containing the speed of sound for several materials and at different temperatures. (in meters/second) Use the list methods in the table above to perform the following:\n\nThe speed of sound in Aluminum is \\(6420\\) m/s. Add two elements to the end of this list: the string “Aluminum” and its speed of sound. Do it two ways, first with append and then with extend.\nRemove the first two elements from this list.\nInsert the removed elements so they appear just after the entry for Helium.\nFind the index location for “Ethyl Alcohol”.\nUse the remove method twice to remove the entry for “Granite” and its associated speed.\nUse the extend method twice to append an entry for the speed of sound for “Steel”, which is 5790 m/s.\n\n\n\na = [\"Air 0C\",331,\"Air 30C\",343, \"Helium 0C\",970,\"Ethyl Alcohol\",1170,\"Water 20C\",1480, \"Granite\",6000]",
    "crumbs": [
      "Basic Python",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Lists and Tuples</span>"
    ]
  },
  {
    "objectID": "chapters/listsAndTuples.html#built-in-functions-for-lists",
    "href": "chapters/listsAndTuples.html#built-in-functions-for-lists",
    "title": "5  Lists and Tuples",
    "section": "5.5 Built-in functions for Lists",
    "text": "5.5 Built-in functions for Lists\nPython has several built-in functions that will work with lists. Functions are called by placing the arguments to the function in parenthesis and prepending the name of the function to the parenthesis. Here are a few common functions that are used with lists: (the zip and enumerate functions will be explained in greater detail next chapter.)\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\nlen(list)\nReturns the number of elements in the list.\n\n\nmax(list)\nFinds the largest element in the list.\n\n\nmin(list)\nFinds the smallest element in the list.\n\n\nsum(list)\nReturns the sum of the elements in the list.4\n\n\nlistOne + listTwo\nJoins listOne with listTwo to form one list.\n\n\n2 * list\nRepeat list and concatenate to itself, making the list twice as long.\n\n\ndel list[index]\nDeletes list elements located at index. Can also specify a range of values.\n\n\nzip(listOne,listTwo)\nZips two lists together. (Creates [(a1,b1),(a2,b2),...] from [a1,a2,a3...] and [b1,b2,b3...]\n\n\nenumerate(list)\nZips a list to the index value for that list (Creates [(0,a1),(1,a2),(2,a3)...] from [a1,a2,a3...]\n\n\n\n4 Only works if the list contains only ints and floats.\nTo Do:\nThe cell below contains two lists with strings in them and a third list that contains numbers. Use these lists to evaluate all of the functions from the table above, printing the result so that you can see what action was performed. Specifically, seek to answer the following questions:\n\nWhat happens when you find the max or min of a list of strings? (list of numbers?)\nWhat happens when you add two lists together? Does it matter if one list contains strings and the other numbers?\nWhat happens when you multiply a list by an integer? Does it matter if the list contains numbers vs strings?\nWhat happens when you zip two lists together? Does it matter if the list contains numbers or strings?\n\n\n\na = [\"l\",\"j\",\"n\"]\nb = [\"r\",\"s\",\"t\"]\nc = [4,7,8]",
    "crumbs": [
      "Basic Python",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Lists and Tuples</span>"
    ]
  },
  {
    "objectID": "chapters/listsAndTuples.html#tuples",
    "href": "chapters/listsAndTuples.html#tuples",
    "title": "5  Lists and Tuples",
    "section": "5.6 Tuples",
    "text": "5.6 Tuples\nTuples are another object type similar to lists except that they are immutable… that is to say, they cannot be modified once created. They look similar to lists except that they are created using parenthesis instead of brackets. Because you can’t change the elements of a tuple, they are often used so that you don’t inadvertently modify (and lose) critical data. You can think of it as locking a file on your computer to avoid inadvertently modifying it and losing the original content.\nBelow is a tuple containing the Balmer series, which are the wavelengths of visible light emitted by Hydrogen gas. These values are well known and you most likely wouldn’t want to make any modifications to this list which makes them a prime candidate for a tuple. Storing them in a tuple will help prevent you from inadvertently modifying the list. Indexing and slicing work exactly the same as with lists and strings, so we can still use the values inside of a tuple to perform simple calculations. There are only two methods associated with tuples: count(element) and index(element). Their usage is identical to the list methods.\n\nbalmer = (383.5384,388.9049,397.0072,410.174,434.047,486.133,656.272,656.2852)\nbalmer.index(410.174)\nlen(balmer)\n\n8\n\n\nYou can transform a list into a tuple using the tuple function.\n\nbalmer = [383.5384,388.9049,397.0072,410.174,434.047,486.133,656.272,656.2852]\n\nbalmerTup = tuple(balmer)",
    "crumbs": [
      "Basic Python",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Lists and Tuples</span>"
    ]
  },
  {
    "objectID": "chapters/dictionarySet.html",
    "href": "chapters/dictionarySet.html",
    "title": "6  Dictionaries and Sets",
    "section": "",
    "text": "6.1 Dictionaries\nJupyter Notebook",
    "crumbs": [
      "Basic Python",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Dictionaries and Sets</span>"
    ]
  },
  {
    "objectID": "chapters/dictionarySet.html#dictionaries",
    "href": "chapters/dictionarySet.html#dictionaries",
    "title": "6  Dictionaries and Sets",
    "section": "",
    "text": "6.1.1 Creating a Dictionary\nA dictionary is a multi-element object just like a list or tuple but instead of connecting each element to an integer index value, a keyword is used. Dictionaries allow you to access data without knowing anything about the order of the items. For example, maybe you want to store the orbital radius of all the planets in the solar system. Using a dictionary you can associate the name of the planet with its orbital radius. A string containing the planet’s name could serve as the key and the associated radius as the value.\nDictionaries are built using curly braces ({}) instead of square brackets (lists) or parentheses (tuples). Each item in the dictionary is a key:value pair and the items are separated by commas just like lists. Below is an example\n\norbitalRadii = {\"Mercury\":0.39, \"Venus\":0.72, \"Earth\":1.0, \"Mars\":1.5,\"Jupiter\":5.2,\"Saturn\":9.5, \"Uranus\":19.2,\"Neptune\":30.1, \"Pluto\": 39.5}\n\nThe keys don’t have to be strings, but can be any data type. For example, maybe you’d like the keys to be the orbital radii of the planets and the values to be the associated orbital period (in Earth days).\n\nradiiandPeriod = {0.39: 88, 0.72: 224.7 , 1.0: 365.2 , 1.5: 687 ,5.2: 4331 ,9.5: 10_747 , 19.2: 30_589 ,30.1: 59_800 ,39.5: 90_560 }\n\nAccessing an element of a dictionary is done with square brackets ([]) just like lists, but instead of placing an integer index the key value is used.\n\norbitalRadii = {\"Mercury\":0.39, \"Venus\":0.72, \"Earth\":1.0, \"Mars\":1.5,\"Jupiter\":5.2,\"Saturn\":9.5, \"Uranus\":19.2,\"Neptune\":30.1, \"Pluto\": 39.5}\n\njupiterRadius = orbitalRadii[\"Jupiter\"]\n\n\nTo Do:\n\nUse a print statement to verify that the correct orbital radius was extracted.\nCan you extract the orbital radius of Pluto from the list?\n\n\nAdditional key:value pairs can be added to an existing dictionary by calling the key and assigning it to a value\n\norbitalRadii = {\"Mercury\":0.39, \"Venus\":0.72, \"Earth\":1.0, \"Mars\":1.5,\"Jupiter\":5.2,\"Saturn\":9.5, \"Uranus\":19.2,\"Neptune\":30.1, \"Pluto\": 39.5}\n\norbitalRadii[\"Moon\"] = 0.384  \n\n\n\n6.1.2 keys, items and values methods\nThree dictionary methods are so heavily used that they are worth mentioning here. The keys method will return a list1 of all keys that are present in the dictionary. The values method will return a list of all values present in the list and the items method will return a nested list containing all key:value pairs.\n1 Actually it produces an iterator that can be used in conjunction with a loop. If you want a list you must use the list function.\norbitalRadii = {\"Mercury\":0.39, \"Venus\":0.72, \"Earth\":1.0, \"Mars\":1.5,\"Jupiter\":5.2,\"Saturn\":9.5, \"Uranus\":19.2,\"Neptune\":30.1, \"Pluto\": 39.5}\n\nvals = orbitalRadii.values()\nkeys = orbitalRadii.keys()\nitems = orbitalRadii.items()\n\n\nTo Do:\n\nUse print statements in the cell above to see what the keys, items, and values methods produce.\nAsk questions as needed.\n\n\n\n\n6.1.3 Other useful dictionary methods\nThere are a few other useful dictionary methods worth mentioning and I’ll place them in the cell below so that you can investigate what they do.\n\norbitalRadii = {\"Mercury\":0.39, \"Venus\":0.72, \"Earth\":1.0, \"Mars\":1.5,\"Jupiter\":5.2,\"Saturn\":9.5, \"Uranus\":19.2,\"Neptune\":30.1, \"Pluto\": 39.5}\n\nradii = {\"Moon\":0.384, \"Venus\": 0.71}\norbitalRadii.pop(\"Mercury\")\norbitalRadii.popitem()\noRadii = dict.fromkeys([\"Mercury\", \"Venus\", \"Earth\"])\nprint(oRadii)\norbitalRadii.update(radii)\n\n{'Mercury': None, 'Venus': None, 'Earth': None}\n\n\n\nTo Do:\n\nUse print statements to determine what each dictionary method in the cell above does.\nAdd comments next to each line explaining the method.",
    "crumbs": [
      "Basic Python",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Dictionaries and Sets</span>"
    ]
  },
  {
    "objectID": "chapters/dictionarySet.html#sets",
    "href": "chapters/dictionarySet.html#sets",
    "title": "6  Dictionaries and Sets",
    "section": "6.2 Sets",
    "text": "6.2 Sets\nA set is another python data type that is used occasionally. They are multi-element objects similar to lists and tuples with one key difference: there can be no repeated elements in a set.\n\n6.2.1 Creating a Set\nSets are created using curly braces ({}) just like dictionaries but instead of placing key:value pairs inside, single values are used. Any repeated elements will be automatically deleted when the set is created.\n\nmySet = {1,2,4,2,1,3,4}\n\n\nTo Do:\n\nPredict what the set defined above will contain.\nUse a print statement to check yourself and adjust your thinking as needed.\n\n\nThe set function can be used to turn a list or tuple into a set and any repeated elements will be deleted. This can be a handy way to remove unwanted duplicates from a list.\n\nelements = [\"H\", \"He\", \"Ne\", \"He\", \"N\", \"Ag\", \"Pt\", \"Ag\"]\n\nmySet = set(elements)\n\nprint(mySet)\n\n{'Pt', 'N', 'Ag', 'Ne', 'H', 'He'}\n\n\n\n\n6.2.2 Modifying a set\nElements can be added to a set using the add and/or update methods. The add method will add a single element to the set and update will allow you to add more than one element.\n\nelements = {\"H\", \"He\", \"Ne\", \"He\", \"N\", \"Ag\", \"Pt\", \"Ag\"}\n\nelements.add(\"Au\")\n\nelements.update([\"In\",\"Cu\",\"Os\",\"He\"])\n\n\nTo Do:\n\nPredict what the set will look like after the add method executes. Then add a print statement to verify that you’re correct.\n\nWhat happens if you try to add an element that is already in the set?\nPredict what the set will look like after the update method executes. Then add a print statement to verify that you’re correct.\n\n\nElements can be removed from a set using the remove and/or discard methods. The difference between these methods is very subtle. They will both remove an element, but the remove method will throw an error if the element you are attempting to remove isn’t in the set. discard won’t throw an error even if the element isn’t present. The clear method will remove all entries from the set.\n\nelements = {\"H\", \"He\", \"Ne\", \"He\", \"N\", \"Ag\", \"Pt\", \"Ag\"}\n\nelements.remove(\"H\")\nelements.discard(\"He\")\nelements.discard(\"Cu\")\nelements.remove(\"Cu\")\nelements.clear()\n\n\nTo Do:\nPredict what the set will look like after each statement in the cell above. Then add a print statement to verify that you’re correct.\n\n\n\n6.2.3 Mathematical Set Operations\nSets are a well-known mathematical idea and there are four mathematical operations that are commonly used with sets. They are: union, intersection, difference, and symmetric difference. We’ll investigate them one at a time.\n\n6.2.3.1 Union\nThe union of two sets is the set of all unique elements between both sets. The union of two sets can be found using the | operator.\n\nfibonacci = {1,1,2,3,5,8,13,21,34,55,89,147,236}\ntriangles = {1, 3, 6, 10, 15, 21, 28, 36, 45, 55, 66, 78, 91, 105, 120, 136, 153, 171, 190}\n\nunion = fibonacci|triangles\n\n\n\n6.2.3.2 Intersection\nThe intersection of two sets is the set of elements that are common to both sets. The intersection of two sets can be found using the & operator\n\nfibonacci = {1,1,2,3,5,8,13,21,34,55,89,147,236}\ntriangles = {1, 3, 6, 10, 15, 21, 28, 36, 45, 55, 66, 78, 91, 105, 120, 136, 153, 171, 190}\n\nintersect = fibonacci&triangles\n\n\n\n6.2.3.3 Difference and Symmetric Difference\nAnd finally, the difference of two sets is the set of elements that are found in one set but not in the other. The difference of two sets can be found using the - operator. Note that A - B will produce a different set than B - A. A- B will produce a set with all of the elements from set A that are not in set B. B - A will do just the opposite, forming a set with all the elements from set B that are not in set A. If you want the set of elements that are in A and B but not in both (kind of like the opposite of intersection) then you want the symmetric difference operator (^)\n\nfibonacci = {1,1,2,3,5,8,13,21,34,55,89,147,236}\ntriangles = {1, 3, 6, 10, 15, 21, 28, 36, 45, 55, 66, 78, 91, 105, 120, 136, 153, 171, 190}\n\n\ndiff = fibonacci - triangles\ndiffTwo = triangles - fibonacci\nsymdiff = fibonacci ^ triangles\n\n\nTo Do:\n\nPredict what the set will look like after each statement in the cells above.\nAdd print statements to check yourself.\n\n\nAs a final point you should note that set elements cannot be extracted using square brackets like you can with lists and tuples. It’s just not allowed. However, you can iterate over sets even though there is no guarantee about the order they will come in. We’ll see what it means to iterate when we study loops.\n\nelements= {\"Li\",\"Be\",\"B\", \"C\",\"N\", \"O\",\"F\", \"Ne\"}\n\nprint(elements[2])",
    "crumbs": [
      "Basic Python",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Dictionaries and Sets</span>"
    ]
  },
  {
    "objectID": "chapters/loops.html",
    "href": "chapters/loops.html",
    "title": "7  Loops",
    "section": "",
    "text": "7.1 for loops\nJupyter Notebook\nLoops allow programs to rerun the same block of code multiple times. This might seem like a funny thing to want to do but it turns out that there are many important tasks that are repetitive in nature (perhaps with small changes for each successive repetition). A loop provides a succinct and efficient way to perform tasks of this nature.\nThe for loop is probably the most common loop you will encounter and is a good choice when you know beforehand exactly what things you want to loop over. Here is an example of a for loop that is used to add up the elements of a list.\nthesum = 0\nfor i in [3,2,1,9.9]: \n    thesum += i\nThis would be equivalent to the following code:\nthesum = 0\n\nthesum = thesum + 3\nthesum = thesum + 2\nthesum = thesum + 1\nthesum = thesum + 9.9\nwhich isn’t that much longer than using a loop. However, as the list gets longer and/or the mathematical operations being performed get more complex the second method would get unreasonably long.\nThe correct language is to say that we are iterating over the list [3,2,1,9.9]. This means that the loop variable (i in this case but you can choose it to be whatever you want) gets assigned the values of the list elements, one by one, until it reaches the end of the list. You can use for loops to iterate over any multi-element object like lists or tuples. Python uses indentation to indicate where the loop ends. In this case there was only one statement inside to loop, but if you wanted more than one each line should be indented.\nYou can iterate over range objects and strings using for loops.\nfor i in ['Physics', 'is','so','fun']: # Iterate over a list of strings\n    print(i)\n\nPhysics\nis\nso\nfun\nfor i in range(5,50,3):  #Generates a list from 5 -&gt; 50 with a step size of 3\n    print(i)\n\n5\n8\n11\n14\n17\n20\n23\n26\n29\n32\n35\n38\n41\n44\n47\nThese examples are so simple that you might wonder when a loop might actually be useful to you. Let’s see if we can build a loop to calculate the following sum\n\\[ \\sum_{n=1}^{1000} {1\\over n^2} \\tag{7.1}\\]\ntheSum = 0\nfor n in range(1,1000):\n    theSum = theSum + 1/n**2\nprint(theSum)\n\n1.6439335666815615\nHere, n is being assigned the values 1,2,3,4....1000, one by one, until it gets all the way to 1000. Each time through the loop, n is different and the expression 1/n**2 evaluates to a new value. The variable theSum is updated each time through to be the running total of all calculations performed thus far. Here’s another example of a loop used to calculate the value of \\(20!\\):\ntheProduct = 1\nfor n in range(1,21):\n    theProduct = theProduct * n #Multiply theProduct by n\nprint(theProduct)\n\n2432902008176640000\nRemember that the range function creates a list starting at \\(1\\), going up to \\(21\\) but not including it. The math library has a function called factorial that does the same thing. Let’s use it to check our answer:\nfrom math import factorial\nfactorial(20)\n\n2432902008176640000",
    "crumbs": [
      "Basic Python",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Loops</span>"
    ]
  },
  {
    "objectID": "chapters/loops.html#for-loops",
    "href": "chapters/loops.html#for-loops",
    "title": "7  Loops",
    "section": "",
    "text": "To Do:\n\nAdd a print statement inside of the loop above to display the value of the variable thesum.\nPredict what the output will be and then run the code and verify that you were correct.\nNow change the loop variable to be named physics and verify that the loop still works as expected.\n\n\n\n\n\n\n\n\n\n\n\n\n\n7.1.1 Boolean Logic Inside Loops\nOften when using loops, we only want a block of code to execute when some condition is satisfied. We can use boolean logic inside of the loop to accomplish this. For example, let’s write a loop to compute the following sum:\n\\[ \\sum_{{n\\over 5} \\in \\text{ Int and } {n\\over 3} \\in \\text{ Int}} {1\\over n^2} \\]\nwhich is similar to the one we did above, but this time we only want to include terms where \\(n\\) is a perfect multiple of both 5 and 3. To check to see if n is a perfect multiple of a number we can calculate the modulo (remainder after division) using the % operator and check that it is equal to zero.\n\ntheSum = 0\nfor n in range(1,1000):\n    if n % 5 == 0 and n % 3 == 0:\n        theSum = theSum + 1/n**2\nprint(theSum)\n\n0.007243985583159138\n\n\n\nTo Do:\nPerform the following modifications to the loop above.\n\nIncrease the upper bound of the sum to go up to and include \\(5000\\).\nOnly include the terms where n is a multiple of 5 and 3 or is a multiple of 7.\nReplace the statement that updates theSum to its shorthand version.\n\n\n\n\n7.1.2 Zipping and Enumerating\nThere are times when it is necessary to iterate over two lists simultaneously. For example, let us say that we have a list of atomic numbers (AN) and a list of approximate atomic masses (mass) of the most abundant isotopes for the first six elements on the periodic table.\nAN = [1,2,3,4,5,6]\nmass = [1,4,7,9,11,12]\nIf we want to calculate the number of neutrons in each isotope, we need to subtract each atomic number from the atomic mass. To accomplish this, it would be nice to iterate over both lists simultaneously\n\n7.1.2.1 Zipping\nThe simplest way to iterate over two lists simultaneously is to combine both lists into a single, iterable object and iterate over it once. The zip function does just that by merging two lists or tuples into a nested list\n\nAN = [1,2,3,4,5,6]\nmass = [1,4,7,9,11,12]\n\nzipped = zip(AN,mass)\n\nfor pair in zipped:\n    print(pair[1] - pair[0])\n\n0\n2\n4\n5\n6\n6\n\n\nThe zip objects are “single use” so you can’t reuse zipped in a later loop. If the two lists being zipped are not the same length, zip stops zipping when it reaches the end of the shorter list.\n\nTo Do:\n\nPrint the variable zipped and inspect closely. Was the output what you expected?\n\nNow do print(tuple(zipped)) and inspect closely. Draw a conclusion.\nAdd a few more entries to the list named AN, but don’t add the corresponding entries to the other list. Now the lists being zipped aren’t the same length. Inspect the output of the print statement to determine what zip does in this scenario.\n\n\n\n\n7.1.2.2 Enumeration\nA close relative to zip is enumerate which zips a list to the index value for that list (read that last statement again). It also returns a “single use” object that can be iterated over.\n\nAN = [1,2,3,4,5,6]\nmass = [1,4,7,9,11,12]\n\nenum = enumerate(mass)\n\nfor idx,val in enum:\n    print(val - AN[idx])\n\n0\n2\n4\n5\n6\n6\n\n\n\nTo Do:\n\nRepeat the previous To-Dos for the cell above.\n\n\n\n\n\n7.1.3 List Comprehension\nIt is fairly common to use a for loop to populate a list with a sequence of numbers.\n\nmyList = []\n\nfor i in range(10):\n    myList.append(i**2)\n\nprint(myList)\n\n[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n\n\nThis entire process can be compressed down into a single line by expressing the for loop in square brackets. This is known as list comprehension. The code below will generate the list as above.\n\nmyList = [i**2 for i in range(10)]\nprint(myList)\n\n[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n\n\nList comprehension can take a little time to get used to but it is well worth it. It saves both time and space and makes code less cluttered. You can even add boolean expressions to your conditionals for further control of the final result.\n\nmyList = [i**2 for i in range(10) if i %2 == 0]  # Include only the evens.\nprint(myList)\n\n[0, 4, 16, 36, 64]\n\n\n\nTo Do:\nThink of your favorite mathematical function and modify the code above to generate a few samples from it.",
    "crumbs": [
      "Basic Python",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Loops</span>"
    ]
  },
  {
    "objectID": "chapters/loops.html#while-loops",
    "href": "chapters/loops.html#while-loops",
    "title": "7  Loops",
    "section": "7.2 while Loops",
    "text": "7.2 while Loops\nLogic can be combined with loops using something called a while loop. A while loop is a good choice when you don’t know beforehand exactly how many iterations of the loop will be executed but rather want the loop to continue to execute until some condition is met. As an example, notice that in Equation 7.1, the terms in the sum get progressively smaller as \\(n\\) gets bigger. It doesn’t make sense to continue adding to the sum once the terms get very small. Let’s compute this sum by looping until the fraction \\({1 \\over n^2}\\) become smaller than \\(1 \\times 10^{-2}\\).\n\nterm = 1  # Load the first term in the sum\ns = term  # Initialize the sum\nn = 1     # Set a counter\nwhile term &gt; 1e-2:  # Loop while term is bigger than 1e-2\n    n = n +  1        #Add 1 to n so that it will count: 2,3,4,5\n    term = 1./n**2    # Calculate the next term to add\n    s = s +  term     # Add 1/n^2 to the running total\n\nThis loop will continue to execute until term&lt;1e-2. Note that unlike the for loop, here you have to do your own counting if you need to know how many iterations have been performed. Be careful about what value n starts at and when it is incremented (n = n + 1). Also notice that term must be assigned prior to the start of the loop. If it wasn’t the loop’s first logical test would fail and the loop wouldn’t execute at all.\n\nTo Do:\n\nDecrease the threshold on the termination condition and observe any changes in the final result and how many more iterations are performed.\n\nAfter toying around with it for a while pick a termination condition that you feel will produce a result that is accurate.\n\n\nwhile loops should be used with caution because you can easily write a faulty termination condition and inadvertently write a loop that runs forever. This happens because your termination condition was never met. An example of this is given below.\nWarning: Do not execute the code block below!!\n\nx = 0\n\nwhile x != 10:\n    x = x + 3\nprint(\"Done\")\n\nThe loop above is intended to end after a few iterations when the value of x is equal to 10. However, closer inspection reveals that the value of x will never be equal to 10. After the first iteration x is equal to 3, then 6,9,12,15 and so on… but never 10. This loop will run forever because the termination condition is never met (x != 10 never produces a False)!! If you choose to use a while loop, triple check your termination condition to make sure you haven’t made a mental error. Avoiding the use of != or == in your termination condition will help too. Use &lt;= or &gt;= instead.\n\nTo Do:\n\nModify the termination condition in the loop above so that it terminates when x gets larger than 15.\nRun the code and verify that you did it correct.",
    "crumbs": [
      "Basic Python",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Loops</span>"
    ]
  },
  {
    "objectID": "chapters/loops.html#continue-break-and-pass-commands",
    "href": "chapters/loops.html#continue-break-and-pass-commands",
    "title": "7  Loops",
    "section": "7.3 continue, break, and pass Commands",
    "text": "7.3 continue, break, and pass Commands\nThe continue, break, and pass commands are used to control the flow of code execution in loops. Here is a description of their usage:\n\n\n\n\n\n\n\nOperator\nDescription\n\n\n\n\nbreak\nExits a for/while loop.\n\n\ncontinue\nSkips the remaining loop block and begins the next iteration.\n\n\npass\nNo action; code contiues on\n\n\n\nThe break statement is useful when you want to completely stop a loop early. Here is our sum loop rewritten with a break statement added to stop the loop after 1000 iterations.\n\nterm = 1  # Load the first term in the sum\ns = term  # Initialize the sum\nn = 1     # Set a counter\nwhile term &gt; 1e-10:  # Loop while term is bigger than 1e-10\n    n +=  1        #Add 1 to n so that it will count: 2,3,4,5\n    term = 1./n**2    # Calculate the next term to add\n    s += term     # Add 1/n^2 to the running total\n    if n &gt; 1000:\n        print('This is taking too long. I''m outta here...')\n        break\n\nThis is taking too long. Im outta here...\n\n\nThe continue statement is similar to break except that instead of stopping the loop, it only stops the current iteration of the loop. All code below the continue statement will be skipped and the next iteration will begin. For example, if you wanted to do the sum from equation ?? but only include those terms for which n is a multiple of 3, it could be done like this:\n\nterm = 1  # Load the first term in the sum\ns = term  # Initialize the sum\nn = 1     # Set a counter\nwhile term &gt; 1e-10:  # Loop while term is bigger than 1e-10\n    n +=  1        #Add 1 to n so that it will count: 2,3,4,5\n    if n % 3 != 0:\n        continue\n    term = 1./n**2    # Calculate the next term to add\n    s += term     # Add 1/n^2 to the running total\n\nNow, when the value of n is not a multiple of 3, the sum will not be updated and the associated terms are effectively skipped.\nFinally, the pass statement does nothing. Seriously!! It is merely a place holder for code that has not bee written yet. Usually, you’ll use the pass statement to run and test code without errors due to missing code.",
    "crumbs": [
      "Basic Python",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Loops</span>"
    ]
  },
  {
    "objectID": "chapters/functions.html",
    "href": "chapters/functions.html",
    "title": "8  Functions",
    "section": "",
    "text": "8.1 Native Functions\nJupyter Notebook\nWe have already been using functions here and there but in this chapter we will introduce them formally and get into the details. A function encapsulates a block of code designed to perform a specific task or set of tasks. To perform the task correctly, most functions require that you provide some information (called arguments) when you call them. To call a function you type the name of the function followed by the needed arguments enclosed in parenthesis (()).\nThe number and type of arguments allowed is different for every function. As a first example, let’s consider the print function, which is the simplest (and most familiar) function that we have used so far.\nThe print function is pretty flexible in what it allows for arguments; the arguments can be any type of data (strings, ints, floats, booleans, and even lists) and the number of arguments can be as large as you want. Most functions are a little more strict on what they allow their arguments to be. For example, the factorial function only allows one argument and that argument must be an integer.1 If you attempt to call the factorial function with a float argument or with more than one argument, the result will be an error.\nPython functions generally fall into three groups: functions that come standard with Python (called native functions), functions that you can import into Python, and functions that you write yourself.\nThere are a few functions that are always ready to go whenever you run Python. They are included with the programming language. We call these functions native functions. You have already been using some of them, like these\nmyList = [5,6,2,1]\na = len(myList)  # 'len' function is native.\n\nb = float(5) # 'float' function is native.\n\nc = str(67.3)  # 'str' function is native.\nThe len, float and str functions are all native and they all take a single argument. Other native function have been mentioned in previous chapters and others will be mentioned in the future.",
    "crumbs": [
      "Basic Python",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Functions</span>"
    ]
  },
  {
    "objectID": "chapters/functions.html#imported-functions",
    "href": "chapters/functions.html#imported-functions",
    "title": "8  Functions",
    "section": "8.2 Imported Functions",
    "text": "8.2 Imported Functions\nMany times, you will need to go beyond what Python can do by itself2. However, that doesn’t mean you have to create everything you need to do from scratch. Most likely, the function that you need has already been coded. Somebody else created the function and made it available to anyone who wants it. Groups of functions that perform similar tasks are typically bundled together into libraries ready to be imported so that the functions that they contain can be used.\n2 For example, Python does not include \\(\\sin()\\) or \\(\\cos()\\) as Native functions.In order to use use a function correctly, you’ll need to know what information(arguments) the function expects you to give it and what information the function intends to return to you as a result. This information can be found in the library’s documentation. Most libraries have great documentation with lists of the included functions, what the functions do, the expected arguments, and examples on how to use the most common ones. You can usually find the library documentation by searching the internet for the library’s name plus “Python documentation”.\nProviding a complete list of all available libraries and function is not really the purpose of this book. Instead, we’ll illustrate how to import functions and use them. As you use Python more and more you should get in the habit of searching out the appropriate library to accomplish the task at hand. When faced with a task to accomplish, your first thought should be, “ I’ll bet somebody has already done that. I’m going to try to find that library.”\nFunctions are imported using the import statement. You’ve already seen how to perform very simple mathematical calculations (\\(5/6\\),\\(84\\), etc..), but for more complex mathematical calculations like \\(\\sin( {\\pi \\over 2} )\\) or \\(e^{2.5}\\) , you’ll need to import these functions from a library.\n\nimport math\n\na = math.sqrt(5.2)\nb = math.sin(math.pi)\nc = math.e**2.5\n\nThe math. before each function is equivalent to telling Python “Use the sqrt() function that you will find in the math book I told you to grab.” If you just type\n\nsqrt(5.2)\n\nPython won’t know where to find the sqrt function and an error message will result. Sometimes the name of the module can be long and typing module. every time you want to use one of it’s functions can be cumbersome. One way around this is to rename the module to a shorter name using the as statement.\n\nimport math as mt\n\na = mt.sqrt(5.2)\nb = mt.sin(mt.pi)\nc = mt.e**2.5\n\nInstead of importing an entire module, you can import only a selection of functions from that module using the from statement. This can make your code even more succinct by eliminating the module. prefix altogether. The trade-off is that it won’t be as clear which function belongs to which module.\n\nfrom math  import sqrt, sin, pi, e\n\na = sqrt(5.2)\nb = sin(pi)\nc = e**2.5\n\nAll of the functions belonging to a module can be imported at once using *.\n\nfrom math import *\n\na = sqrt(5.2)\nb = sin(pi)\nc = e**2.5",
    "crumbs": [
      "Basic Python",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Functions</span>"
    ]
  },
  {
    "objectID": "chapters/functions.html#user-defined-functions",
    "href": "chapters/functions.html#user-defined-functions",
    "title": "8  Functions",
    "section": "8.3 User-defined Functions",
    "text": "8.3 User-defined Functions\nAfter having programmed for a while, you will notice that certain tasks get repeated frequently. For example, maybe in your research project you need to calculate the force exerted on an atom due to many other nearby atoms. You could copy and paste your force-calculation code every time it was needed, but that would likely result in lots of extra code and become very cumbersome to work with. You can avoid this by creating your own function to calculate the force between any two atoms. Then, every time you need another force calculation, you simple call the function again. You only write the force-calculation part of the code once and then you execute it as many times as you need to.\nTo create your own function, you first need to name the function. The name should be descriptive of what it does and makes sense to you and anyone else who might use it. The first line of a function definition starts with the def statement (short for definition) followed by the name of the function with whatever information, called arguments, that needs to be fed into the function enclosed in parenthesis. The last character in this line must be a colon. Everything inside the function is indented four spaces and placed directly below the first line.\n\ndef functionName(arg1,arg2,arg3):\n    # Body of Function\n    # Body of Function\n    # Body of Function\n\nAs an example, let’s construct a function that calculates the distance between two atoms. The function will need to know the location of each atom, which means that there should be two arguments: the xyz coordinates of both atoms passed as a pair of lists or tuples.\n\nimport math\n\ndef distance(coords1,coords2):\n\n    dx = coords1[0] - coords2[0]\n    dy = coords1[1] - coords2[1]\n    dz = coords1[2] - coords2[2]\n    d = math.sqrt(dx**2 + dy**2 + dz**2)\n    print(f\"The distance is {d:5.4f}.\")\n\ndistance([1,2,3],[4,5,6])\n\ndistance([4.2,9.6,4.8],[2.9,2.6,3.4])\n\nThe distance is 5.1962.\nThe distance is 7.2560.\n\n\nThis function works just fine with integers or floats for the coordinates.\n\n8.3.1 The return statement\nThe distance function prints out the value for the distance, but what if we want to use this distance in a subsequent calculation? Maybe we want to calculate the average distance between several pairs of atoms. We can instruct the function to return the final distance using the return statement. If the arguments to the function are the inputs, the return statement specifies what the output is. Let’s modify the function above to include a return statement.\n\nimport math\ndef distance(coords1,coords2):\n    dx = coords1[0] - coords2[0]\n    dy = coords1[1] - coords2[1]\n    dz = coords1[2] - coords2[2]\n    d = math.sqrt(dx**2 + dy**2 + dz**2)\n    return d\n\ndistOne = distance([1,2,3],[4,5,6])\n\ndistTwo = distance([4.2,9.6,4.8],[2.9,2.6,3.4])\n\naverageDistance = (distOne + distTwo)/2\n\nprint(f\"The average distance is {averageDistance:5.4f}.\")\n\nThe average distance is 6.2261.\n\n\n\n\n8.3.2 Local vs Global Variable Scope\nVariables created inside of a function have local scope. This means that they are not accessible outside of the function. In our distance function the variables dx,dy,dz, and d were all local variables that are used inside the function but have no value outside of it. This is convenient because we don’t have to worry about overwriting a variable or using it twice. If someone sends you a function and you want to use it in your code, you don’t have to worry about what variable he/she chose to use inside his function; they won’t affect your code at all.\n\ndef distance(coords1,coords2):\n    dx = coords1[0] - coords2[0]\n    dy = coords1[1] - coords2[1]\n    dz = coords1[2] - coords2[2]\n    d = math.sqrt(dx**2 + dy**2 + dz**2)\n    return d\n\ndistOne = distance([1,2,3],[4,5,6])\n\nprint(dx)  # There is no value associated with this variable outside of the function.\n\nThe down side to all of this is that you don’t have access to function variables unless you pass them out of the function using the return statement.\nAny variables defined outside of a function is called a global variable, which means that Python remembers these assignments from anywhere in your code including inside of functions. Using global variables with the intention to use them inside of functions is usually considered bad form and confusing and is discouraged. One notable exception to this rule are physical constants like \\(g = 9.8\\) m/s\\(^2\\) (acceleration due to gravity on Earth) or \\(k_B = 1.38 \\times 10^{-23}\\) (Boltzmann’s constant which is used heavily in thermodynamics) because these values will never change and may be used repeatedly. Generally speaking every variable that is used in a function ought to be either i) passed in as an argument or ii) defined inside of the function. Below is an example of an appropriate use of a global variable.\n\ndef myFunction(a,b):\n    c=a+g # &lt;--- Notice the reference to 'g' here \n    d = 3.0 * c\n    f = 5.0 * d**4\n    return f\n\n#The variable below are global variables. \nr = 10\nt = 15\ng = 9.8         #&lt;--- g defined to be a global variable\nresult = myFunction(r,t)\n\n\n\n8.3.3 Positional vs. Keyword Arguments\nThe function arguments we have been using so far are called positional arguments because they are required to be in a specific position inside the parenthesis. To see what I mean consider the example below.\n\ndef example(a,b):\n    return a**b\n\n\nresultOne = example(5,2)\nresultTwo = example(2,5)\n\nprint(resultOne, resultTwo)\n\n25 32\n\n\nIn the first call to example the local variable a gets assigned to be 5 and the local variable b gets assigned 2. In the second call the order of the arguments is switched and the subsequent assignments to a and b switch with it. This produces a different result from the function. Positional arguments are very common but the user must know what information goes where when calling the function.3\n3 This is another reason why you want to choose meaningful variable names for your arguments.The other type of argument is the keyword argument. These arguments are attached to a keyword inside of the parenthesis. The advantage of a keyword argument is that the user does not need to be concerned about the location of the argument as long as it has the proper label.\n\ndef example(a=1,b=2):\n    return a**b\n\n\nresultOne = example(a=5,b=2)\nresultTwo = example(b=2,a=5)\n\nprint(resultOne, resultTwo)\n\n25 25\n\n\nAnother advantage to using keyword arguments is that a default value can be coded into the function. This means that we can call the function with some arguments missing and default values will be used for them. In the example above, the default value of b is 2 and if the function is called without specifying a value for that argument, the function will proceed as usual using the default value for b.\n\ndef example(a=1,b=2):\n    return a**b\n\n\nresult = example(a=5)\n\nprint(result)\n\n25\n\n\n\n\n8.3.4 Splatting\nFunctions can potentially require dozens of arguments to be passed in which can make calling the function long and difficult to look at. One way to shorten the code is to put all of the arguments in a list or tuple.\n\ndef func(a,b,c,d):\n\n    return a**b + c/d\nargs  = (5,4,6,3)\n\nresult = func(*args)\n\nprint(result)\n\n627.0\n\n\n\n\n8.3.5 Lambda Functions\nWhen the function you want to construct is very simple (one line), there is a shortcut code for making it called a lambda function. The benefit is that they occupy less lines of code than the standard def functions. A lambda function is defined as shown below with the variable immediately after the lambda statement as the independent variable in the function.\n\nf = lambda x: x**2\n\nprint(f(5))\n\n25\n\n\nAs a simple application of lambda functions let’s consider a function from the scipy.integrate library called quad which will perform a numerical integration of a function. The quad function takes three arguments: the function to be integrated, and the upper and lower bound on the integral. We can use a lambda function for the first argument rather than using several lines of code to build one in the traditional fashion.\n\nfrom scipy.integrate import quad\nfrom math import sin, pi\n\nquad(lambda x: sin(pi * x)**2,0,0.4 )\n\n(0.15322553581056808, 1.7011451781741914e-15)",
    "crumbs": [
      "Basic Python",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Functions</span>"
    ]
  },
  {
    "objectID": "chapters/numpy.html",
    "href": "chapters/numpy.html",
    "title": "9  The numpy module",
    "section": "",
    "text": "9.1 Numpy Arrays\nJupyter Notebook\nNumpy (short for “numerical python” and pronounced “num”-“pie”) is a popular Python library that is heavily used in the scientific/mathematical community. So much so that numpy is typically included as part of the standard bundle of libraries that comes with your Python installation. The functions inside numpy will allow you to solve problems with less effort and will produce faster-executing code.\nYou are already familiar with Python lists but may not have noticed that they are not suitable for mathematical calculations. For example, attempting to multiply a list by a scalar or evaluating a mathematical function like \\(\\sin()\\) on a list will not produce a mathematical result or may produce an error. For example, consider the following code.\nmyList = [4,5,7]\n\nnewList = 2 * myList\nprint(newList)\n\n[4, 5, 7, 4, 5, 7]\nYou probably expected newList to be [8,10,14] but multiplying a list by a number doesn’t do that. Instead it repeats the list and concatenates it to itself. To multiply each element of a list by a number you must use a for loop.\nmyList = [4,5,7]\n\nnewList = []\nfor i in myList:\n    newList.append(i* 2)\n\nprint(newList)\n\n[8, 10, 14]\nbut this seems overly cumbersome for such a simple task. Numpy ndarrays (short for n-dimensional arrays) or just arrays make this task much simpler. Arrays are similar to lists or nested lists except that mathematical operations and numpy functions (but not math functions) automatically propagate to each element instead of requiring a for loop to iterate over it. Because of their power and convenience, arrays are the default object type for any operation performed with NumPy.",
    "crumbs": [
      "Intermediate Python",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>The `numpy` module</span>"
    ]
  },
  {
    "objectID": "chapters/numpy.html#array-creation",
    "href": "chapters/numpy.html#array-creation",
    "title": "9  The numpy module",
    "section": "9.2 Array Creation",
    "text": "9.2 Array Creation\n\n9.2.1 Type Conversion from List\nYou can create an array from a list using numpy’s array function. The list that is to be converted is the argument to the array function. Mathematical operations can then be performed on the array and that operation will propagate through to all of the elements.\n\nfrom numpy import array\n\nmyArray = array([4,5,7])\n\nnewArray = 2 * myArray \n\nprint(newArray)\n\n[ 8 10 14]\n\n\nNested lists, or lists that contain lists as their elements, can be converted to multi-dimensional arrays using the array function.\n\nfrom numpy import array\nmyArray = array([[1,2,3],[4,5,6]])\n\nprint(myArray)\n\n[[1 2 3]\n [4 5 6]]\n\n\n\n\n9.2.2 The arange and linspace Functions\nNumpy has some sequence-generating functions that generate arrays by specifying start, stop, and step size values similar to the way range generates a list. The two most common ones are arange and linspace. The arange function behaves very similar to the native Python range function with a few notable exceptions:\n\narange produces an array whereas range produces a list.\nThe step size for arange does not need to be an integer.\nrange produces an iterator and arange generates a sequence of values immediately.\n\nThe arguments to arange are similar to range\narange(start,stop,step)\nThe linspace function is related to the arange function except that instead of specifying the step size of the sequence, the sequence is generated based on the number of equally-spaced points in the given span of numbers. Additionally, arange excludes the stop value while linspace includes it. The difference between these two functions is subtle and the use of one over the other often comes down to user preference or convenience.\nlinspace(start,stop,number of points)\nBelow is an example that shows the usage of linspace and arange.\n\nfrom numpy import linspace,arange\n\nmyArray = linspace(0,10,20)\nmyArray2 = arange(0,10,0.5)\nprint(myArray)\nprint(myArray2)\n\n[ 0.          0.52631579  1.05263158  1.57894737  2.10526316  2.63157895\n  3.15789474  3.68421053  4.21052632  4.73684211  5.26315789  5.78947368\n  6.31578947  6.84210526  7.36842105  7.89473684  8.42105263  8.94736842\n  9.47368421 10.        ]\n[0.  0.5 1.  1.5 2.  2.5 3.  3.5 4.  4.5 5.  5.5 6.  6.5 7.  7.5 8.  8.5\n 9.  9.5]\n\n\nWhen using linspace you may still want to know what the sequence spacing is. You can request that linspace provide this information by adding the optional argument retstep = True to the argument list. With this addition, linspace not only returns the sequence to you, but also the stepsize.\n\nfrom numpy import linspace,arange\n\nmyArray,mydx = linspace(0,10,20,retstep= True)\nprint(mydx)\nprint(myArray)\n\n0.5263157894736842\n[ 0.          0.52631579  1.05263158  1.57894737  2.10526316  2.63157895\n  3.15789474  3.68421053  4.21052632  4.73684211  5.26315789  5.78947368\n  6.31578947  6.84210526  7.36842105  7.89473684  8.42105263  8.94736842\n  9.47368421 10.        ]\n\n\nTwo other useful functions for generating arrays are zeros and ones which generate arrays populated with exclusively ones or zeros. The functions require shape arguments as a tuple or list to specify the shape of the array.\nzeros((rows,columns))\nIf the array to be created is only one dimensional, the argument can be a single number instead of a tuple.\nzeros(n)\n\nfrom numpy import zeros,ones\n\nmyArray = zeros([3,4])\nmyArray2 = ones(5)\nprint(myArray)\nprint(myArray2)\n\n[[0. 0. 0. 0.]\n [0. 0. 0. 0.]\n [0. 0. 0. 0.]]\n[1. 1. 1. 1. 1.]\n\n\nArrays of any constant (not just one or zero) can then be easily generated by performing the needed math on the original array.\n\nfrom numpy import zeros,ones\n\nmyArray = zeros([3,4]) + 5\nmyArray2 = ones(5) * 12\nprint(myArray)\nprint(myArray2)\n\n[[5. 5. 5. 5.]\n [5. 5. 5. 5.]\n [5. 5. 5. 5.]]\n[12. 12. 12. 12. 12.]\n\n\n\n\n9.2.3 Arrays from Functions\nA third approach is to generate an array from a function using the fromfunction function which generates an array of values using the array indices as the inputs. Ths function requires two arguments: the name of the function being used and the shape of the array being generated.\nfromfunction(function, shape)\nLet’s make a 3 x 3 array where each element is the product of the row and column indices:\n\nfrom numpy import fromfunction\n\ndef prod(x,y):\n    return x * y\n\nmyArray = fromfunction(prod,(3,3))\nprint(myArray)\n\n[[0. 0. 0.]\n [0. 1. 2.]\n [0. 2. 4.]]\n\n\nThe table below gives a summary of useful functions for creating numpy arrays. The required arguments are also described.\n\nCommon functions for generating arrays\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\nlinspace(start,stop,n)\nReturns an array of n evenly-spaced points begining at start and ending at stop.\n\n\narange(start,stop,dx)\nReturns an array beginning at start,ending at stop with a step size of dx.\n\n\nempty(dims)\nReturns an empty array with dimensions dim.\n\n\nzeros(dims)\nReturns an array of zeros with dimensions dim.\n\n\nones(dims)\nReturns an array of ones with dimensions dim.\n\n\nzeros_like(arr)\nReturns an array of zeros with dimensions that match the dimensions of arr.\n\n\nfromfunction(function,dims)\nReturns an array of numbers generated by evaluating function on the indices of an array with dimensions dims.\n\n\ncopy(arr)\nCreates a copy of array arr.\n\n\ngenfromtext(file)\nReads file and loads the text into an array (file must only contain numbers).",
    "crumbs": [
      "Intermediate Python",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>The `numpy` module</span>"
    ]
  },
  {
    "objectID": "chapters/numpy.html#accessing-and-slicing-arrays",
    "href": "chapters/numpy.html#accessing-and-slicing-arrays",
    "title": "9  The numpy module",
    "section": "9.3 Accessing and Slicing Arrays",
    "text": "9.3 Accessing and Slicing Arrays\nAccessing and slicing arrays can be done in exactly the same way as is done with lists. However, there is some additional functionality for accessing and slicing arrays that do not apply to lists.\n\n9.3.1 One-dimensional Arrays\nElements from a one-dimensional array can be extracted using square brackets ([]) just like we have done with lists.\n\nfrom numpy import array\n\nmyArray = array([3,4,7,8])\nprint(myArray[2])\n\n7\n\n\n\n\n9.3.2 Multi-dimensional Arrays\nMulti-dimensional array can be indexed in a similar fashion to nested lists, but because we often encounter multi-dimensional arrays there is a shortcut that makes the syntax simpler and more convenient. Let’s consider a two-dimensional array as an example. To access the entire second row of the array, provide the row index in square brackets just as with one-dimensional arrays.\n\nfrom numpy import array\nmyArray = array([[1,2,3],[4,5,6], [7,8,9]])\n\nprint(myArray[1])\n\n[4 5 6]\n\n\nTo access the second element in the second row, we can add another set of square brackets with the appropriate index inside, just as we did with nested lists. However, for convenience the second set of square brackets can be omitted and the row and column indices can be placed next to each other and separated by a comma.\narray_name[row,column]\n\nfrom numpy import array\nmyArray = array([[1,2,3],[4,5,6], [7,8,9]])\n\nprint(myArray[1][1])  # This works, but is a bit hard on the eyes\nprint(myArray[1,1])  # This works also and is easier to look at.\n\n5\n5\n\n\n\n\n9.3.3 Accessing Multiple Elements\nMultiple elements of an array can be accessed using a list for the index instead of a single number.\n\nfrom numpy import array\n\nmyArray = array([1,2,3,4,5,6,7,8,9,10])\n\nprint(myArray[2])  # Extract element 2\nprint(myArray[ [3,6,9] ])  # Extract elements 3, 6, and 9.\n\n3\n[ 4  7 10]\n\n\nThis can even be done with multi-dimensional arrays. If the index is a single list, the corresponding rows will be extract. If the corresponding list of columns is added to the index list, individual elements will be extracted.\narray_name[[rows]]  # Access set of rows\narray_name[[rows], [columns]]  # Access set of elements\n\nfrom numpy import array\nmyArray = array([[1,2,3],[4,5,6], [7,8,9]])\n\nprint(myArray[[0,1]]) # Extract rows 0 and 1.\n\nprint(myArray[[1,2,0],[0,2,2]])   # Extract elements (1,0), (2,2), and (0,2)  \n\n[[1 2 3]\n [4 5 6]]\n[4 9 3]",
    "crumbs": [
      "Intermediate Python",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>The `numpy` module</span>"
    ]
  },
  {
    "objectID": "chapters/numpy.html#slicing-arrays",
    "href": "chapters/numpy.html#slicing-arrays",
    "title": "9  The numpy module",
    "section": "9.4 Slicing Arrays",
    "text": "9.4 Slicing Arrays\n\n9.4.1 Multi-dimensional Arrays\nWe’ve already shown you how to slice a list using the : operator. The same can be done with arrays. However, for 2D (and higher) arrays the slicing is more powerful (intuitive). It can be helpful to visualize an array as a matrix, even if it is not being treated that way Mathematically. For example, let’s say that you define the following array:\n\nfrom numpy import array\nmyArray = array([[1,2,3],[4,5,6], [7,8,9]])\n\nwhich can be visualized as the following matrix:\n\\[\n\\begin{pmatrix}\n1&2&3\\\\\n4&5&6\\\\\n7&8&9\\\\\n\\end{pmatrix}\n\\]\nTo slice out the following \\(2\\) x \\(2\\) sub matrix:\n\\[\n\\begin{pmatrix}\n5&6\\\\\n8&9\\\\\n\\end{pmatrix}\n\\]\nwe could do\n\nfrom numpy import array\nmyArray = array([[1,2,3],[4,5,6], [7,8,9]])\n\nprint(myArray[1:3,1:3])\n\n[[5 6]\n [8 9]]\n\n\nTo include all of the elements in a given dimension, use the : alone with no numbers surrounding it.\n\nfrom numpy import array\nmyArray = array([[1,2,3],[4,5,6], [7,8,9]])\n\nprint(myArray[:,1:3])  # Extract all rows with columns 1 and 2\n\n[[2 3]\n [5 6]\n [8 9]]\n\n\n\n\n9.4.2 Boolean Slicing\nBoolean operations can be evaluated on arrays to produce corresponding arrays of booleans. The boolean array can then be used to index the original array and extract elements that meet some criteria.\n\nfrom numpy import array\n\na = array([1,2,3,4,5,6])\n\nboolArray = a &gt; 2\n\nprint(boolArray)\n\nprint(a[boolArray])\n\n[False False  True  True  True  True]\n[3 4 5 6]\n\n\nThis also works on multi-dimensional arrays although the result is always one-dimensional regardless of the shape of the original array.\n\nfrom numpy import array\nmyArray = array([[1,2,3],[4,5,6], [7,8,9]])\n\nprint(myArray[myArray&gt;2]) # Extract elements that are greater than 2.\n\n[3 4 5 6 7 8 9]",
    "crumbs": [
      "Intermediate Python",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>The `numpy` module</span>"
    ]
  },
  {
    "objectID": "chapters/numpy.html#vectorization-and-broadcasting",
    "href": "chapters/numpy.html#vectorization-and-broadcasting",
    "title": "9  The numpy module",
    "section": "9.5 Vectorization and Broadcasting",
    "text": "9.5 Vectorization and Broadcasting\nA major advantage of numpy arrays over lists is that operations vectorize across the arrays. This means that mathematical operations propagate through the array instead of requiring a for loop. This speeds up the calculation and makes code easier to write and read. Simple mathematical operations like adding, subtracting, etc can be performed on arrays as you would expect and the operation propagates through to all elements.\n\nfrom numpy import array\n\na = array([1,2,3])\nb = array([4,5,6])\n\nc = a + b\nd = a**2\ne = 2 * b\nf = 2/b\ng = a * b\n\nprint(c,d,e,f,g)\n\n[5 7 9] [1 4 9] [ 8 10 12] [0.5        0.4        0.33333333] [ 4 10 18]\n\n\nAll of the common mathematical operations that you learned for numbers now apply to arrays. Cool!\n\n9.5.1 Numpy Functions\nThe numpy library has a massive collection of vectorized mathematical functions and these functions should be used instead of similar functions from other libraries that are not vectorized (like math).\n\nfrom numpy import array\nfrom numpy import sqrt as nsqrt\nfrom math import sqrt as mathsqrt\n\nsquares = array([1,4,9,16,25])\n\nprint(nsqrt(squares))\n#print(mathsqrt(squares))  #This will fail because it wasn't a numpy function.\n\n[1. 2. 3. 4. 5.]\n\n\n\n\n9.5.2 Arrays of same Dimensions\nIf a mathematical operation is performed between two arrays of the same dimensions, the mathematical operation is performed between corresponding elements in the two arrays. For example, if two \\(2\\) x \\(2\\) arrays are added together, element (0,0) of the first array gets added to the corresponding element in the second and so forth for all elements:\n\\[\n\\begin{pmatrix}\n1&2\\\\\n3&4\\\\\n\\end{pmatrix}+\n\\begin{pmatrix}\n5&6\\\\\n7&8\\\\\n\\end{pmatrix}=\n\\begin{pmatrix}\n6&8\\\\\n10&12\\\\\n\\end{pmatrix}\n\\]\n\nfrom numpy import array\n\na = array([[1,2],[3,4]])\nb = array([[5,6],[7,8]])\n\nc = a + b  # Add the elements of the arrays together.\nd = a * b  # Multiply the elements of the arrays together.\n\nprint(c)\nprint(d)\n\n[[ 6  8]\n [10 12]]\n[[ 5 12]\n [21 32]]\n\n\n\n\n9.5.3 Arrays of Different Dimensions\nWhen a mathematical operation between two arrays of different dimensions is attempted, Python has to figure out how to make them have the same shape before performing the operation. Broadcasting refers to the set of rules used for operations like this. To handle arrays with different dimensions, NumPy pads or clones the array with fewer dimensions to make it have the same dimensions as the larger array. For example, what would happen if you attempted this operation:\n\\[\n\\begin{pmatrix}\n1&2\\\\\n3&4\\\\\n\\end{pmatrix}+\n\\begin{pmatrix}\n2&2\\\\\n\\end{pmatrix}\n\\]\nOne array is \\(2\\) x \\(2\\) and the other is \\(1\\) x \\(2\\). Before the addition can take place, NumPy clones the smaller array and repeats it until it has the same size as the bigger array.\n\\[\n\\begin{pmatrix}\n1&2\\\\\n3&4\\\\\n\\end{pmatrix}+\n\\begin{pmatrix}\n2&2\\\\\n2&2\\\\\n\\end{pmatrix}\n\\]\n\nfrom numpy import array\n\na = array([[1,2],[3,4]])\nb = array([2,2])\nc = a + b\n\nprint(c)\n\n[[3 4]\n [5 6]]\n\n\nThere are some cases where NumPy simply cannot figure out how to broadcast one of the arrays appropriately and an error results. When broadcasting, NumPy must verify that all dimensions are compatible with each other. Two dimensions are compatible when i) they are equal or ii) one of the dimensions is 1. For example, if we tried to perform the following mathematical operation, broadcasting would fail because the first dimension of the first array is 2 and the first dimension of the second array is 3.\n\\[\n\\begin{pmatrix}\n1&2&3\\\\\n3&4&5\\\\\n\\end{pmatrix}+\n\\begin{pmatrix}\n1&1&1\\\\\n2&2&2\\\\\n3&3&3\\\\\n\\end{pmatrix}\n\\]\n\nfrom numpy import array\n\na = array([[1,2,3],[4,5,6]])\nb = array([[1,1,1],[2,2,2],[3,3,3]])\nc = a + b\n\nbut if we attempted\n\\[\n\\begin{pmatrix}\n1&2&3\\\\\n\\end{pmatrix}+\n\\begin{pmatrix}\n1&1&1\\\\\n2&2&2\\\\\n3&3&3\\\\\n\\end{pmatrix}\n\\]\nthe operation would succeed because the first dimension of the first array is 1 and the second dimension of both arrays are 3.\n\n\n9.5.4 Vectorizing user-defined functions\nStandard Python functions are often designed to perform a single calculation rather than iterate over a list to perform many calculations. For example, here is a function to calculate the average acceleration of an object given its final velocity and time of travel.\n\ndef accel(velocity, time):\n    return velocity / time\n\n\nprint(accel(52.6,5.6))\n\n9.392857142857144\n\n\nNow what if I have a list of many times that I’d like to feed into this function and get an acceleration value for each one.\n\ndef accel(velocity, time):\n    return velocity / time\n\n\ntimes = [4.6,7.9,3.2,8.5,9.2,4.7]\nprint(accel(52.6,times))  # Produces an error because you can't divide by a list\n\nAn error results here because Python does not know how to divide by a list. We can NumPy-ify this function using a function called vectorize. The resulting function will behave just like the other functions from the NumPy library, vectorizing across the list of times.\n\nfrom numpy import vectorize\ndef accel(velocity, time):\n    return velocity / time\n\n\ntimes = [4.6,7.9,3.2,8.5,9.2,4.7]\nvaccel = vectorize(accel)  # Vectorize the function!\nprint(vaccel(52.6,times))  # Succeeds because NumPy knows how to vectorize.\n\n[11.43478261  6.65822785 16.4375      6.18823529  5.7173913  11.19148936]\n\n\nOf course, we also could have just converted our times list into an array and used the original function.\n\nfrom numpy import array\ndef accel(velocity, time):\n    return velocity / time\n\n\ntimes = array([4.6,7.9,3.2,8.5,9.2,4.7])\nprint(accel(52.6,times))  # Succeeds because times is an array not a list.\n\n[11.43478261  6.65822785 16.4375      6.18823529  5.7173913  11.19148936]",
    "crumbs": [
      "Intermediate Python",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>The `numpy` module</span>"
    ]
  },
  {
    "objectID": "chapters/numpy.html#manipulating-and-modifying-arrays",
    "href": "chapters/numpy.html#manipulating-and-modifying-arrays",
    "title": "9  The numpy module",
    "section": "9.6 Manipulating and Modifying Arrays",
    "text": "9.6 Manipulating and Modifying Arrays\nA wealth of functions exist to perform routine manipulation tasks on arrays once they are created. Often these tasks will involve changing the number of rows or columns or merging two arrays into one. The size and shape of an array are the number of elements and dimensions, respectively. These can be determined using the shape and size methods.\n\nfrom numpy import array\n\na = array([[1,2,3],[4,5,6]])\nprint(a.size)\nprint(a.shape)\n\n6\n(2, 3)\n\n\n\n9.6.1 Reshaping Arrays\nThe dimensions of an array can be modified using the reshape function. This methods maintains the number of elements and the order of elements but repacks them into a different number of rows and columns. Because the number of elements is maintained, the size of the new array has to be the same as the original. Let’s see an example.\n\nfrom numpy import array, reshape\n\na = array([[1,2,3],[4,5,6]])\n\nb = reshape(a,[3,2])\n\nprint(a)\nprint(b)\n\n[[1 2 3]\n [4 5 6]]\n[[1 2]\n [3 4]\n [5 6]]\n\n\nThe original array (a) was a \\(2\\) x \\(3\\) and had \\(6\\) elements and the reshaped array also has \\(6\\) elements but is a \\(3\\) x \\(2\\). You can start with a one-dimensional array and reshape it to a higher dimensional array.\n\nfrom numpy import linspace, reshape\n\na = linspace(0,10,12)\n\nb = reshape(a,[3,4])\n\nprint(a)\nprint(b)\n\n[ 0.          0.90909091  1.81818182  2.72727273  3.63636364  4.54545455\n  5.45454545  6.36363636  7.27272727  8.18181818  9.09090909 10.        ]\n[[ 0.          0.90909091  1.81818182  2.72727273]\n [ 3.63636364  4.54545455  5.45454545  6.36363636]\n [ 7.27272727  8.18181818  9.09090909 10.        ]]\n\n\n\n\n9.6.2 Flattening Arrays\nFlattening an array takes a higher-dimensional array and squishes it into a one-dimensional array. You can “flatten” an array with the flatten method, but note that flatten doesn’t actually modify the original array.\n\nfrom numpy import array\n\na = array([[1,2,3],[4,5,6]])\na.flatten()\n\nprint(a)  # 'a' remains unchanged\n\na = a.flatten() # If you want to change the definition of a, redifine it.\nprint(a)\n\n[[1 2 3]\n [4 5 6]]\n[1 2 3 4 5 6]\n\n\n\n\n9.6.3 Transposing Arrays\nTransposing an array rotates it across the diagonal and can be accomplished with the transpose function. There is also a shortcut method for this of array.T to accomplish the same thing but just as with flatten it does not modify the original array. (neither does transpose)\n\nfrom numpy import array,transpose\n\na = array([[1,2,3],[4,5,6]])\ntranspose(a)\n\nprint(a)  # 'a' remains unchanged\n\na = a.T # If you want to change the definition of a, redefine it.\nprint(a)\n\n[[1 2 3]\n [4 5 6]]\n[[1 4]\n [2 5]\n [3 6]]\n\n\n\n\n9.6.4 Merging Arrays\nSeveral function exist for combining multiple arrays into a single array. We’ll give examples for a couple and mention the others in reference tables. The most commonly used functions for this task are vstack (vertical stacking) and hstack (horizontal stacking). vstack will stack the original arrays vertically to create the new array and hstack will stack them horizontally. Here are some examples.\n\nfrom numpy import linspace, hstack, vstack\n\na = linspace(0,10,10)\nb = linspace(0,5,10)\n\nc = vstack((a,b))\nprint(c)  # 'a' remains unchanged\n\nd = hstack((a,b))\nprint(a.T)\nprint(d)\n\n[[ 0.          1.11111111  2.22222222  3.33333333  4.44444444  5.55555556\n   6.66666667  7.77777778  8.88888889 10.        ]\n [ 0.          0.55555556  1.11111111  1.66666667  2.22222222  2.77777778\n   3.33333333  3.88888889  4.44444444  5.        ]]\n[ 0.          1.11111111  2.22222222  3.33333333  4.44444444  5.55555556\n  6.66666667  7.77777778  8.88888889 10.        ]\n[ 0.          1.11111111  2.22222222  3.33333333  4.44444444  5.55555556\n  6.66666667  7.77777778  8.88888889 10.          0.          0.55555556\n  1.11111111  1.66666667  2.22222222  2.77777778  3.33333333  3.88888889\n  4.44444444  5.        ]",
    "crumbs": [
      "Intermediate Python",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>The `numpy` module</span>"
    ]
  },
  {
    "objectID": "chapters/numpy.html#commonly-used-array-methods-and-functions",
    "href": "chapters/numpy.html#commonly-used-array-methods-and-functions",
    "title": "9  The numpy module",
    "section": "9.7 Commonly-used Array Methods and Functions",
    "text": "9.7 Commonly-used Array Methods and Functions\nNumPy contains an extensive listing of array methods and functions and it would be impractical to list them all here. However, below you will find some tables of some of the commonly used ones that can serve as a reference.\n\nArray Attribute Methods and Functions\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\nshape(array) or array.shape\nReturns the dimensions of the array.\n\n\nndim(array) or array.ndim\nReturns the number of dimensions (i.e. a 2D array is \\(2\\)).\n\n\nsize(array) or array.size\nReturns the number of elements in an array.\n\n\n\n\nArray Modification Methods and Functions\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\narray.flatten()\nReturns a flattened view of array.\n\n\nreshape(array,dims) or array.reshape(dims)\nReturns a view of array reshaped into an array with dimensions given by dims.\n\n\narray.resize(dims)\nModifies array to be a resized array with dimensions dims.\n\n\ntranspose(array) or array.T\nReturns a view of the transpose of array.\n\n\nsort(array)\nReturns a view of a sorted version of array.\n\n\narray.sort()\nModifies array to be sorted.\n\n\nargsort(array)\nReturns index values that will sort array.\n\n\narray.fill(x)\nModifies array so that all elements are equal to x.\n\n\nvstack(a,b)\nVertically stack arrays a and b to form the new array.\n\n\nhstack(a,b)\nHorizontally stack arrays a and b to form the new array.\n\n\nvsplit(array,n)\nSplits array vertically into n equal parts.\n\n\nhsplit(array,n)\nSplits array horizontally into n equal parts.\n\n\nappend(array,x)\nReturns a view of array with x added to the end of the array.\n\n\ninsert(array,n,x)\nReturns a view of array with x inserted at location n.\n\n\ndelete(array,n)\nReturns a view of array with element at location n removed.\n\n\nunique(array)\nReturns a view of the unique elements of array.\n\n\n\n\nArray Measurement Methods and Functions\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\nmin(array) or array.min()\nReturns the minimum value in an array.\n\n\nmax(array) or array.max()\nReturns the maximum value in an array.\n\n\nargmin(array) or array.argmin()\nReturns the location of the minimum value in an array.\n\n\nargmax(array) or array.argmax()\nReturns the location of the maximum value in an array.\n\n\nfmin(array1,array2)\nReturns the minimum between two arrays of the same size. (Arrays are compared element wise.)\n\n\nfmax(array1,array2)\nReturns the maximum between two arrays of the same size. (Arrays are compared element wise.)\n\n\nmean(array) or array.mean()\nReturns the mean of array.\n\n\nmedian(array) or array.median()\nReturns the median of array.\n\n\nstd(array) or array.std()\nReturns the standard deviation of array.\n\n\ncumprod(array) or array.cumprod()\nReturns the cumulative product of array.\n\n\ncumsum(array) or array.cumsum()\nReturns the cumulative sum of array.\n\n\nsum(array) or array.sum()\nReturns the sum of all elements in array.\n\n\nprod(array) or array.prod()\nReturns the product of all elements in array.\n\n\nfloor(array)\nReturns the floor (i.e., rounds down) of all elements in array.\n\n\nceil(array)\nReturns the ceiling (i.e., rounds up) of all elements in array.",
    "crumbs": [
      "Intermediate Python",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>The `numpy` module</span>"
    ]
  },
  {
    "objectID": "chapters/numpy.html#flashcards-part-i",
    "href": "chapters/numpy.html#flashcards-part-i",
    "title": "9  The numpy module",
    "section": "9.8 Flashcards Part I",
    "text": "9.8 Flashcards Part I\n\nIn what ways are arrays “better” than lists? (better might be too strong.)\nHow do you create an array from a list?\nExplain the usage of the linspace function.\nExplain the usage of the arange function.\nExplain the usage of the zeros_like function.\nHow do you access a single element from a two-dimensional array?\nHow do you access multiple array elements at once in a one-dimensional array?\nHow do you access multiple array elements at once in a two-dimensional array?\nHow do you slice a two-dimensional array?\nWhat is boolean slicing? Given an example.\nWhat is broadcasting?\nWhat has President Nelson taught us about the meaning of the word Israel?",
    "crumbs": [
      "Intermediate Python",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>The `numpy` module</span>"
    ]
  },
  {
    "objectID": "chapters/numpy.html#flashcards-part-ii",
    "href": "chapters/numpy.html#flashcards-part-ii",
    "title": "9  The numpy module",
    "section": "9.9 Flashcards Part II",
    "text": "9.9 Flashcards Part II\n\nHow can you determine the shape and size of an array?\nWhat does the reshape function do? Give an example to show the usage.\nWhat does the flatten function do? Give an example to show the usage.\nWhat does the transpose function do? Give an example to show the usage.\nWhat does the vstack function do? Give an example to show the usage.\nWhat does the hstack function do? Give an example to show the usage.\nWhat do the argmax and argmin functions do?\nWhat does the cumsum function do?\nHow many temples does the church have in operation currently?",
    "crumbs": [
      "Intermediate Python",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>The `numpy` module</span>"
    ]
  },
  {
    "objectID": "chapters/numpy.html#exercises",
    "href": "chapters/numpy.html#exercises",
    "title": "9  The numpy module",
    "section": "9.10 Exercises",
    "text": "9.10 Exercises\n\nHere you will find a picture of the unit circle.\n\nUse the arange function to generate all of the angles (in degrees) on the unit circle displayed in blue or black text.\nUsing a single line of code, convert all of the angle from part 1 into radians.\nUse the linspace function to generate all of the angles (in degrees) on the unit circle displayed in red or black text.\nUsing a single line of code, convert all of the angle from part 3 into radians.\nUsing a single line of code, evaluate \\(\\sin()\\) onto both sets of angles and verify that they agree with the values on the unit circle.\nUsing a single line of code, evaluate \\(\\cos()\\) onto both sets of angles and verify that they agree with the values on the unit circle.\nUsing a single line of code, evaluate \\({\\sin(\\theta)\\over \\cos(\\theta)}\\) for all of the angles in your arrays. This should be equal to \\(\\tan(\\theta)\\)\n\n\n\n# Python code here\n\n\nIn the cell below you will find three arrays containing the masses, lengths, and radii for a collection of cylinders. The moment of inertia for each cylinder can be calculated as \\[ I = {1\\over 4} M R^2 + {1\\over 12} M L^2\\].\n\nUsing a single line of code, calculate the moment of inertia for all of the values in the arrays.\nDetermine the largest, smallest, and average of the calculated values.\n\n\n\nfrom numpy.random import uniform\nmass = uniform(3,8,1000)\nradius = uniform(0.5,1.2,1000)\nlength = uniform(0.8,3,1000)\n\n\nConstruct a two-dimensional array with the following entries: \\[\\begin{bmatrix}\n1& 5 & 7 & 2\\\\\n3& 9 & 1 & 4\\\\\n4& 2 & 2 & 8\\\\\n9& 1 & 6 & 3\\\\\n\\end{bmatrix}\\]\n\nNow access the number in the third column and second row. (It’s a \\(1\\))\nSlice the array from columns \\(2 \\rightarrow 4\\) and rows \\(1 \\rightarrow 3\\).\n\nThe following temperatures are prominent on the Fahrenheit scale: [0,32,100,212,451].\n\nCreate an array that contains these temperatures.\nUsing a single line of code, convert these temperatures into degrees Celsius using the following formula \\[T_C =  {5\\over 9}(T_F - 32)\\]\nUsing a single line of code, convert the temperatures from part 2 into Kelvins using the following formula \\[T_K = T_C + 273.15\\]\n\nUsing a single line of code, convert the temperatures from part 1 into Kelvins using the following formula \\[T_K = {5\\over 9} ( T_F - 32) + 273.15\\]\n\n\n\n# Python code here.\n\n\nThe equation below defines the relationship between energy (\\(E\\)) in Joules of a photon and its wavelength (\\(\\lambda\\)) in meters. The \\(h\\) is Plank’s constant (\\(6.626 \\times 10^{-34}\\) J \\(\\cdot\\) s) and \\(c\\) is the speed of light in a vacuum (\\(2.998 \\times 10^8\\) m/s). \\[E = {h c \\over \\lambda}\\]\n\nGenerate an array of wavelength values for visible light (\\(400\\) nm \\(\\rightarrow 800\\) nm) in \\(50\\) nm increments. (“nm” stands for nanometers or \\(10^{-9}\\) m)\nGenerate a second array containing the energy of each wavelength of light from part 1. Does the energy of a photon increase or decrease with wavelength?\n\n\n\n# Python code here\n\n\nA boat is out at sea with the following location and velocity vectors: \\[x_i =\n\\begin{bmatrix}\n5 \\\\\n2\n\\end{bmatrix} \\text{ km}\\] \\[v_i =\n\\begin{bmatrix}\n-13 \\\\\n25\n\\end{bmatrix}  \\text{ m/s}\\] when a gust of wind causes the boat to accelerate for approximately \\(3\\) minutes with the following acceleration vector:\\[a =\n\\begin{bmatrix}\n-8 \\\\\n-5\n\\end{bmatrix} \\text{ m/s}^2\\] We can find the position and velocity vectors of the boat after the wind has died back down with the following equation: \\[ \\vec{x_f} = \\vec{x_i} + \\vec{v_i} \\Delta t + {1\\over 2} \\vec{a} \\Delta t^2\\] \\[ \\vec{v_f} = \\vec{v_i} + \\vec{a} \\Delta t\\]\n\nCreate arrays containing the initial position, initial velocity, and acceleration of the boat in SI units.\nUsing a single line of code, calculate the final position of the boat. (Watch out: You must convert \\(3\\) minutes to seconds before performing the calculation.)\nUsing a single line of code, calculate the final velocity of the boat. (Watch out: You must convert \\(3\\) minutes to seconds before performing the calculation.)\n\nPredict the outcome of the following operations between two arrays. Then test your prediction.\n\\[\\begin{bmatrix}\n1&8&9\\\\\n8&1&9\\\\\n1&8&1\\\\\n\\end{bmatrix}+ \\begin{bmatrix}\n1&1\\\\\n1&1\\\\\n\\end{bmatrix} \\] \\[\n\\begin{bmatrix}\n1&1\\\\\n2&2\\\\\n\\end{bmatrix}\n+ \\begin{bmatrix}\n1\\\\\n\\end{bmatrix}\\] \\[\n\\begin{bmatrix}\n1&8&9\\\\\n8&1&9\\\\\n1&8&1\\\\\n\\end{bmatrix} +  \\begin{bmatrix}\n1\\\\\n2\\\\\n3\\\\\n\\end{bmatrix}\\] \\[\n\\begin{bmatrix}\n1&8&9\\\\\n8&1&9\\\\\n1&8&1\\\\\n\\end{bmatrix}\n+     \\begin{bmatrix}\n1&2&3\\\\\n\\end{bmatrix}\\]\n\n\n# Python code here\n\n\nIn quantum mechanics you will learn that the allowed energy levels for the harmonic oscillator are given by:\\[E_n = \\hbar \\sqrt{k \\over m} (n + {1\\over 2})\\] where \\(k = 4 \\pi^2\\) and \\(m = 1\\) gram.\n\nGenerate an array of \\(n\\) values from \\(1 \\rightarrow 10\\) (inclusive).\nUsing a single line of code, calculate the first 10 allowed energies for this harmonic oscillator. (Don’t forget to convert the mass to kg so everything is in SI units.)\nCombine these two arrays into a single \\(10\\) x \\(2\\) array with the first column containing \\(n\\) values and the second column containing the corresponding energies.\n\n\n\n# Python code here.\n\n\nGenerate an array containing integers \\(0 \\rightarrow 14\\) (inclusive)\n\nReshape the array to be a \\(3\\) x \\(5\\) array.\nTranspose the array from part 1 so that it is \\(5\\) x \\(3\\).\nMake the array from part 2 one-dimensional.\n\nThe \\(\\cos()\\) function can be written as an infinite sum: \\[ \\cos(x) = 1 - {x^2 \\over 2!} + {x^4 \\over 4!} - {x^6 \\over 6!} + \\dots = \\sum_{n = 0}^\\infty {(-1)^n x^{2n} \\over (2n)!}\\]. (As it turns out, any function can be written as a sum like this.)\n\nMake an array of integer \\(n\\) values from \\(0 \\rightarrow 10\\).\nUsing a single line of code, generate the terms in the sum for \\(x = \\pi\\). Note: scipy.special has a factorial function that will work on arrays.\n\nUse cumsum to evaluate the sum.\nInterpret the results and verify that as you include more terms in the sum the approximation to \\(\\cos(x)\\) gets better and better.",
    "crumbs": [
      "Intermediate Python",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>The `numpy` module</span>"
    ]
  },
  {
    "objectID": "chapters/io.html",
    "href": "chapters/io.html",
    "title": "10  File I/O (Input/Output)",
    "section": "",
    "text": "10.1 The os module\nJupyter Notebook\nUp to now, we have been working with computer-generated or manually typed data sets. Often in a scientific setting your data will be stored in a file and you will need to read the contents of the file into Python so you can perform an analysis. Most data files are text files, but there is a large variety of these that differ mostly in the way the information is formatted. The file extension (i.e., the 3 or 4 letters after the period at the end of a file name) specifies the formatting of the file. For example, a .csv file (short for comma-separated values) has commas to separate the information.\nBefore we learn how to read and write data files, we should first learn how to navigate our computer’s file system from within Python. For this, we will use a module called os (short for operating system). The os module allows you to perform standard operations on the files and folders on your computer. When opening files from a python script, the default search path is the directory where the current file is located. If you want to open files located in other directories, you may need to use the os module to navigate there first. The following functions are the most commonly used ones\nIn the cell below, we show the usage of these functions.\nfrom os import getcwd,chdir,listdir\n\ncurrentdir = getcwd()  \nmyfiles = listdir()\n#chdir(/path/to/new/directory)\nThe os module has many, many more functions that do useful things but you will mostly use the functions mentioned above. As you get more experience using your computer at the command line, you will be better equipped to understand the usefulness of the rest of this library.",
    "crumbs": [
      "Intermediate Python",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>File I/O (Input/Output)</span>"
    ]
  },
  {
    "objectID": "chapters/io.html#the-os-module",
    "href": "chapters/io.html#the-os-module",
    "title": "10  File I/O (Input/Output)",
    "section": "",
    "text": "Function\nDescription\n\n\n\n\ngetcwd()\nShort for get current working directory. Returns a string of the current directory.\n\n\nchdir(path)\nChange the current working direction to be at path.\n\n\nlistdir()\nList all of the files and folders in the current working directory.\n\n\nmkdir(path)\nMake an new directory at location path.\n\n\n\n\n\n\nTo Do:\n\nAdd print statements to the cell above and inspect the results to understand what each function does.\nModify the third statement above (the one that uses chdir) to change the current working directory to one that actually exists on your machine.\nEveryone has a “Downloads” folder on their computer. Use the chdir function to change the current working directory to the Downloads folder.",
    "crumbs": [
      "Intermediate Python",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>File I/O (Input/Output)</span>"
    ]
  },
  {
    "objectID": "chapters/io.html#reading-files",
    "href": "chapters/io.html#reading-files",
    "title": "10  File I/O (Input/Output)",
    "section": "10.2 Reading Files",
    "text": "10.2 Reading Files\n\n10.2.1 Reading Line by Line\nThe first way to read a file is using a for loop to iterate over the file line by line. Admittedly, this is not the most elegant or efficient way to read a file but we present it first because it always works. First, the file is opened using the open command. The file should be attached to a variable for later use. Next, the readlines() function is used to read the file in as a list of strings; one string for each line in the file. We should use a for loop for to iterate over this list, effectivley parsing the file line by line. Finally, the file should be closed when you’re finished reading it. Let’s see an example for reading in the following file, which will be named squares.csv. (You can download squares.csv here if you want to execute the cells below without an error.)\n1, 1\n2, 4\n3, 9\n4, 16\n5, 25\n6, 36\n7, 49\n\nfile = open(\"squares.csv\")\nlines = file.readlines() # Read the file into a list of strings, one string for each line in the file.\nfor line in lines:  # Iterate over the list of strings.\n    print(line)    # Do something \n\nfile.close()\n\n1,1\n\n2,4\n\n3,9\n\n4,16\n\n5,25\n\n6,36\n\n7,49\n\n8,64\n\n9,81\n\n10,100\n\n\nYou can see how each line gets read separately and printed off. But this isn’t super useful yet because we’d probably like to have the numbers stored in lists for our forthcoming analysis. We can fix this by creating some empty lists and appending the appropriate values as they are read in.\n\nnumbers = []\nsquares = []\n\nfile = open(\"squares.csv\")\nfor line in file.readlines():\n    numbers.append( int(line.split(',')[0]) )\n    squares.append( int(line.split(',')[1]) )\n\nfile.close()\n\nprint(numbers)\nprint(squares)\n\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n\n\nNow the data from the file is saved in Python lists and our analysis can proceed.\nOne final note: if all you ned to do is read the first few lines of a file, the readline() function can be used (not readlines()) and each call to this function will read the next line in the file.\n\nfile = open(\"squares.csv\")\nlineOne = file.readline()\nlineTwo = file.readline()\nlineThree = file.readline()\nfile.close()\n\n\n\n10.2.2 Using NumPy’s genfromtxt function\nIf the data file is highly structured (every line looks the same, separator character is consistent across the file, etc) then NumPy’s genfromtxt function can read the data very efficiently into something called an array. The genfromtxt function requires only one argument (the file name) with another optional argument (delimiter) that is typically included to specify the character used to separate the data. Below is an example for using this function to read in the .csv data we have been working with.\n\nimport numpy as np\n\ndata = np.genfromtxt('squares.csv',delimiter = \",\")\n\n\nprint(data)\n\n[[  1.   1.]\n [  2.   4.]\n [  3.   9.]\n [  4.  16.]\n [  5.  25.]\n [  6.  36.]\n [  7.  49.]\n [  8.  64.]\n [  9.  81.]\n [ 10. 100.]]\n\n\nThe data from the file is stored in something called a 2D numpy array which is similar to a nested list. It’s best to think of a 2D numpy array as having rows and columns, and to index them the desired row and column must be provided. We can index these arrays similar to how we index nested lists but instead of using multiple sets of brackets ([]), simply place the desired row and column number in a single set of brackets, as shown in the cell below. Use a colon (:) to select an entire row or column.\n\nimport numpy as np\n\ndata = np.genfromtxt('squares.csv',delimiter = \",\")\n\n\nnumbers = data[:,0]  # Extract the entire first column of the array\nsquares = data[:,1]  # Extract the entire second column of the array.\nmySlice = data[1:3,1] # Extract the first and second row of the 2nd column.\nprint(numbers)\nprint(squares)\nprint(mySlice)\n\n[ 1.  2.  3.  4.  5.  6.  7.  8.  9. 10.]\n[  1.   4.   9.  16.  25.  36.  49.  64.  81. 100.]\n[4. 9.]\n\n\nAnother useful feature of arrays is that you can do math with them and the mathematical operations are performed on every number in the array automatically. This is in contrast to lists which cannot be used to perform mathematical operations. See the example in the cell below:\n\nimport numpy as np\n\ndata = np.genfromtxt('squares.csv',delimiter = \",\")\n\nnumbers = data[:,0]  # Extract the entire first column of the array\nsquares = data[:,1]  # Extract the entire second column of the array.\n\ncalc = np.sqrt(squares)  # Take the square root of all of the number in the \"squares array\"\nprint(calc)\n\n[ 1.  2.  3.  4.  5.  6.  7.  8.  9. 10.]\n\n\nOther optional arguments that can be used with the genfromtxt function are given in the table below:\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\ndelimiter\nThe string used to separate value. By default, whitespace acts as the delimiter.\n\n\nskip_header\nThe number of lines to skip at the beginning of a file.\n\n\nskip_footer\nThe number of lines to skip at the end of a file.\n\n\nusecols\nSpecify which columns to read with 0 being the first. For example, usecols = (0,2,5) will read the 1st, 3rd, and 6th columns.\n\n\ncomments\nThe character used to indicate the start of a comment. Lines beginning with this character will be discarded.",
    "crumbs": [
      "Intermediate Python",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>File I/O (Input/Output)</span>"
    ]
  },
  {
    "objectID": "chapters/io.html#writing-files",
    "href": "chapters/io.html#writing-files",
    "title": "10  File I/O (Input/Output)",
    "section": "10.3 Writing Files",
    "text": "10.3 Writing Files\nWriting Python data to file is as simple as is reading a file. Just like when you are reading a file, determining which method to use will be determined by the type of data that you are writing. If your data is strictly numerical information stored in an array, Numpy has a function that will quickly save the data to a file. If your data is rife with inconsistencies, non-numerical data, etc, you’ll have to use Python’s native write function.\n\n10.3.1 Writing Line by Line\nSometimes the data file that you want to write includes some text or other non-numerical data. For example, what if you wanted to write the following data to file:\n\n\n\nPlanet\nAcceleration due to gravity (m/s\\(^2\\)\n\n\n\n\nEarth\n9.8\n\n\nMoon\n1.6\n\n\nMars\n3.7\n\n\nVenus\n8.83\n\n\nSaturn\n11.2\n\n\nUranus\n10.5\n\n\nNeptune\n13.3\n\n\nPluto\n0.61\n\n\nJupiter\n24.5\n\n\nSun\n275\n\n\n\nIn this case you must open the file you want to write through and write each line of the file one by one. This requires that you use a loop to iterate over the data. An example is given below.\n\nplanets = [\"Earth\",\"Moon\",\"Mars\",\"Venus\",\"Saturn\",\"Uranus\",\"Neptune\",\"Pluto\",\"Jupiter\",\"Sun\"]\ng=[9.8,1.6,3.7,8.83,11.2,10.5,13.3,0.61,24.5,275]\n\nf= open(\"planets.txt\",\"w\")\n\nf.write(\"Planet   g (m/s^2)\\n\")\nf.write(\"------------------\\n\")\n\nfor idx,planet in enumerate(planets):\n    f.write(f\"{planet:10s}  {g[idx]:5.2f} \\n\" )\n\nf.close()\n\n\n\n10.3.2 The writelines function\nIf the data you are wanting to write to file is already in a list of strings, the writelines() function can be used once to write all of the lines in the file.\n\nplanets = [\"Planet   g (m/s^2)\",\"------------------\", \"Earth   9.8\",\"Moon   1.6\",\"Mars   3.7\",\"Venus  8.83\",\"Saturn   11.2\",\"Uranus   10.5\",\"Neptune   13.3\",\"Pluto   0.61\",\"Jupiter   24.5\",\"Sun   275\"]\n\nf= open(\"planets.txt\",\"w\")\n\nf.writelines(planets)\n\nf.close()",
    "crumbs": [
      "Intermediate Python",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>File I/O (Input/Output)</span>"
    ]
  },
  {
    "objectID": "chapters/io.html#the-with-statement",
    "href": "chapters/io.html#the-with-statement",
    "title": "10  File I/O (Input/Output)",
    "section": "10.4 The with statement",
    "text": "10.4 The with statement\nForgetting to close a file that you are writing to can be problematic so you should always include the close() function when you are done. If you are worried about forgetting it, you can use a with block that will automatically close the file once the block terminates. An example is given below:\n\nplanets = [\"Earth\",\"Moon\",\"Mars\",\"Venus\",\"Saturn\",\"Uranus\",\"Neptune\",\"Pluto\",\"Jupiter\",\"Sun\"]\ng=[9.8,1.6,3.7,8.83,11.2,10.5,13.3,0.61,24.5,275]\n\nwith open(\"planets.txt\",\"w\") as f:\n    f.write(\"Planet   g (m/s^2)\\n\")\n    f.write(\"------------------\\n\")\n\n    for idx,planet in enumerate(planets):\n        f.write(f\"{planet:10s}  {g[idx]:5.2f} \\n\" )\n\nEven though no close() function is called, the file planets.txt will be automatically closed once the with block is terminated. A with block can also be used when reading data files.\n\n10.4.1 Using NumPy’s savetxt function\nIf the data is strictly numerical and contains no text, the savetxt function is a fast and efficient way to write the data to file. For example, maybe you have a two dimensional array containing various columns of planetary data.\n\n\n\n\n\n\n\n\nRadius ( \\(\\times 10^{6}\\) meters )\nMass ( \\(\\times 10^{23}\\) kg )\nAcceleration due to gravity (m/s\\(^2\\))\n\n\n\n\n6.37\n59.8\n9.8\n\n\n1.74\n0.736\n1.6\n\n\n3.38\n6.42\n3.7\n\n\n6.07\n48.8\n8.83\n\n\n58.2\n5680\n11.2\n\n\n23.5\n868\n10.5\n\n\n22.7\n1030\n13.3\n\n\n1.15\n0.131\n0.61\n\n\n69.8\n19000\n24.5\n\n\n696\n19890000\n275\n\n\n\n\nfrom numpy import savetxt\n\ndata =[[6.37,59.8,9.8],[1.74,0.736,1.6],[3.38,6.42,3.7],[6.07,48.8,8.83],[58.2,5680,11.2],[23.5,868,10.5],[22.7,1030,13.3],[1.15,.131,0.61],[69.8,19000,24.5],[696,19890000,275]]\n\nsavetxt(\"planetsData.txt\",data,fmt = \"%5.2e\")\n\nThe fmt keyword argument can be be added to specify how to format the data. If the data is stored in separate one-dimensional arrays, you can pack them into a single list(tuple) when using the savetxt function and it will write each data set to its own line in the file.\n\nimport numpy as np\n\nradius = [6.37,1.74,3.38,6.07,58.2,23.5,22.7,1.15,69.8,696]\nmass = [59.8,0.736,6.42,48.8,5680,868,1030,0.131,19000,19890000]\ng = [9.8,1.6,3.7,8.83,11.2,10.5,13.3,0.61,24.5,275]\n\nnp.savetxt(\"planetsDataTwo.txt\",(radius,mass,g),fmt = \"%5.2e\")\n\nIn this example, radius, mass, and g will be written to file in seperate rows. If you’d like them to be writen in separate columns, you must use np.transpose to flip the array before writing it to file, as shown below:\n\nimport numpy as np\nradius = [6.37,1.74,3.38,6.07,58.2,23.5,22.7,1.15,69.8,696]\nmass = [59.8,0.736,6.42,48.8,5680,868,1030,0.131,19000,19890000]\ng = [9.8,1.6,3.7,8.83,11.2,10.5,13.3,0.61,24.5,275]\n\nnp.savetxt(\"planetsDataTwo.txt\",np.transpose((radius,mass,g)),fmt = \"%5.2e\")\n\nOther optional arguments that can be used with the savetxt function are given in the table below:\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\ndelimiter\nString or character to separate columns.\n\n\nnewline\nString or character to separate lines.\n\n\nheader\nString to be written at the beginning of the file.\n\n\nfooter\nString to be written at the end of the file.\n\n\ncomments\nString that will be prepended to the header and footer string to mark them as comments.",
    "crumbs": [
      "Intermediate Python",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>File I/O (Input/Output)</span>"
    ]
  },
  {
    "objectID": "chapters/basicPlotting.html",
    "href": "chapters/basicPlotting.html",
    "title": "11  Basic Plotting",
    "section": "",
    "text": "11.1 Plotting Functions of a Single Variable\nJupyter Notebook\nCreating plots is an important task in science and engineering. The old adage “A picture is worth a thousand words!” is wrong…. it’s worth way more than that if you do it right. When making plots of functions on a computer it is important to remember that computers don’t plot functions, rather they plot individual points. Only when you connect those points does the image look like the function you are used to seeing. In this chapter we will use a library called matplotlib for plotting. More specifically, we will import the pyplot function inside of matplotlib. It is customary to use plt as an alias for pyplot.\nThe %matplotlib inline statement is a Jupyter notebook command. It tells Jupyter to display any plots generated directly in the notebook instead of in a separate window. If you use matplotlib in another environment, you should remove this line and instead place plt.show() after the plot commands.\nIn order to make a plot, matplotlib needs lists of the x and y coordinates for the points that are going to be plotted. If you want to plot a function, the list of x coordinates should be chosen to be a dense array of points spanning the function’s domain and the list of y coordinates should be the function values at those points. A good choice for generating the x-coordinates is either linspace or arange from NumPy. Let’s consider an example. The function shown below is called the Lennard-Jones equation and it gives the energy of two atoms interacting as a function of separation distance\n\\[ E = 4\\sigma\\left[ \\left({\\epsilon\\over r} \\right)^{12} - \\left({\\epsilon\\over r} \\right)^{6}\\right]\\]\nLet’s plot this function from \\(0.9\\) to \\(4.0\\).\nfrom matplotlib import pyplot as plt\n%matplotlib inline\nfrom numpy import linspace,sqrt\n\nsigma = 1\nepsilon = 1\nr = linspace(0.9,4,20)\nenergy = 4 * sigma* ((epsilon/r)**12 - (epsilon/r)**6)\n\nplt.figure()\nplt.plot(r,energy)",
    "crumbs": [
      "Intermediate Python",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Basic Plotting</span>"
    ]
  },
  {
    "objectID": "chapters/basicPlotting.html#plotting-functions-of-a-single-variable",
    "href": "chapters/basicPlotting.html#plotting-functions-of-a-single-variable",
    "title": "11  Basic Plotting",
    "section": "",
    "text": "To Do:\n\nYou may have noticed that the plot doesn’t appear very smooth. Think about what modifications you might make so that the plot is smoother.\nRun the code to verify that you did it correct.\n\n\n\n11.1.1 Linestyles, Markers, and Colors\nThree optional arguments can help you control the look of the plot: marker, linestyle, and color. All of these arguments take strings. The linestyle argument determines if the line is solid or dashed and what type of dashing to use. The marker argument specifies the shape of the plot marker to be used. Below are tables listing possible options for these arguments.\n\nCommon Marker Styles\n\n\nArgument\nDescription\n\n\n\n\no\ncircle\n\n\n*\nstar\n\n\np\npentagon\n\n\n^\ntriangle\n\n\ns\nsquare\n\n\n\n\nCommon Line Styles\n\n\nArgument\nDescription\n\n\n\n\n-\nsolid\n\n\n--\ndashed\n\n\n-.\ndash-dot\n\n\n:\ndotted\n\n\n\n\nCommon Colors\n\n\nArgument\nDescription\n\n\n\n\nb\nblue\n\n\nr\nred\n\n\nk\nblack\n\n\ng\ngreen\n\n\nm\nmagenta\n\n\nc\ncyan\n\n\ny\nyellow\n\n\n\nSeveral other keyword arguments exist for helping you customize the look of your plots. They are summarized in the table below.\n\nA Few Common plot keyword arguments\n\n\nArgument\nDescription\n\n\n\n\nlinestyle or ls\nline style\n\n\nmarker\nmarker shape\n\n\nlinewidth or lw\nline width\n\n\ncolor or c\nline color\n\n\nmarkersize or ms\nmarker size\n\n\n\nHere is the plot from above with some of these keyword arguments added.\n\nfrom matplotlib import pyplot as plt\n%matplotlib inline\nfrom numpy import linspace,sqrt\n\nr = linspace(0.9,4,50)\nenergy = 4 * ((1/r)**12 - (1/r)**6)\n\nplt.figure()\nplt.plot(r,energy,linestyle = '-', marker = 'o', color = 'r')\n\n\n\n\n\n\n\n\n\n\n11.1.2 Labeling Plots\nAll good plots have axes labels and a title and you can add them to a matplotlib plot using the xlabel(), ylabel(), and title() functions which are placed on their own line after the plot command.\n\nfrom matplotlib import pyplot as plt\n%matplotlib inline\nfrom numpy import linspace,sqrt\n\nr = linspace(0.9,4,50)\nenergy = 4 * ((1/r)**12 - (1/r)**6)\n\nplt.figure()\nplt.plot(r,energy,marker = 'o')\nplt.xlabel(\"Separation Distance\")\nplt.ylabel(\"Energy\")\nplt.title(\"Lennard-Jones Potential\")\n\nText(0.5, 1.0, 'Lennard-Jones Potential')\n\n\n\n\n\n\n\n\n\n\n\n11.1.3 Greek Letters\nIn physics, Greek letters get used all the time and you may find yourself wanting to use one in a plot title or axes label. This can be accomplished by placing an r in front of the title string and then placing the name of the greek variable inside of $ with a backslash in front of it. This is better illustrated with an example.\n\nfrom matplotlib import pyplot as plt\n%matplotlib inline\nfrom numpy import linspace,sqrt\n\nr = linspace(0.9,4,50)\nenergy = 4 * ((1/r)**12 - (1/r)**6)\n\nplt.figure()\nplt.plot(r,energy,marker = 'o')\nplt.xlabel(\"Separation Distance\")\nplt.ylabel(\"Energy\")\nplt.title(r\"Lennard-Jones Potential ($\\theta$)\")\n\nText(0.5, 1.0, 'Lennard-Jones Potential ($\\\\theta$)')\n\n\n\n\n\n\n\n\n\nYou can subscript any character using the _ character followed by the subscript. \\(\\theta_1\\) can be written as \\theta_1. If the subscript is more than one character, you’ll need to enclose it in curly braces. \\(\\theta_{12}\\) is written as \\theta_{12}. Superscripts work the same way only using the ^ character instead of the underscore.\n\nLowercase greek letters\n\n\nArgument\nDescription\n\n\n\n\n\\(\\alpha\\)\n\\alpha\n\n\n\\(\\beta\\)\n\\beta\n\n\n\\(\\gamma\\)\n\\gamma\n\n\n\\(\\delta\\)\n\\delta\n\n\n\\(\\epsilon\\)\n\\epsilon\n\n\n\\(\\phi\\)\n\\phi\n\n\n\\(\\theta\\)\n\\theta\n\n\n\\(\\kappa\\)\n\\kappa\n\n\n\\(\\lambda\\)\n\\lambda\n\n\n\\(\\mu\\)\n\\mu\n\n\n\\(\\nu\\)\n\\nu\n\n\n\\(\\pi\\)\n\\pi\n\n\n\\(\\rho\\)\n\\rho\n\n\n\\(\\sigma\\)\n\\sigma\n\n\n\\(\\tau\\)\n\\tau\n\n\n\\(\\xi\\)\n\\xi\n\n\n\\(\\zeta\\)\n\\zeta\n\n\n\n\n\n11.1.4 Controlling the Axes\nBy default, matplotlib will size the plot window to include all of the points. If you want to zoom in our out, you can do so with the xlim and ylim functions. These functions should be placed after the plot command on their own line just like the label commands.\n\nfrom matplotlib import pyplot as plt\n%matplotlib inline\nfrom numpy import linspace,sqrt\n\nr = linspace(0.9,4,50)\nenergy = 4 * ((1/r)**12 - (1/r)**6)\n\nplt.figure()\nplt.plot(r,energy,marker = 'o')\nplt.xlim(0.5,3)\nplt.ylim(-1.25,5)\nplt.xlabel(\"Separation Distance\")\nplt.ylabel(\"Energy\")\nplt.title(\"Lennard-Jones Potential\")\n\nText(0.5, 1.0, 'Lennard-Jones Potential')\n\n\n\n\n\n\n\n\n\n\n\n11.1.5 Overlaying Plots\nOften you will want to plot more than one set of data on the same set of axes. This can be accomplished two ways. The first way is to call the plot function twice in the same Jupyter notebook cell. Matplotlib will automatically place the plots on the same figure and scale it appropriately. Below you will find a plot of the Lennard-Jones potential for two choices of the parameters \\(\\sigma\\) and \\(\\epsilon\\).\n\nfrom matplotlib import pyplot as plt\n%matplotlib inline\nfrom numpy import linspace,sqrt\n\nr = linspace(0.9,4,50)\n\nsigmaOne = 1\nepsilonOne = 1\nsigmaTwo = 2\nepsilonTwo = 2\nenergyOne = 4 * sigmaOne* ((epsilonOne/r)**12 - (epsilonOne/r)**6)\nenergyTwo = 4 * sigmaTwo * ((epsilonTwo/r)**12 - (epsilonTwo/r)**6)\n\nplt.figure()\nplt.plot(r,energyOne,marker = 'o')\nplt.plot(r,energyTwo,marker = '+')\nplt.xlim(0.5,3.5)\nplt.ylim(-2,5)\nplt.xlabel(\"Separation Distance\")\nplt.ylabel(\"Energy\")\nplt.title(\"Lennard-Jones Potential\")\n\nText(0.5, 1.0, 'Lennard-Jones Potential')\n\n\n\n\n\n\n\n\n\nThe other way to overlay plots is to include both sets of data into a single plot command.\n\nfrom matplotlib import pyplot as plt\n%matplotlib inline\nfrom numpy import linspace,sqrt\n\nr = linspace(0.9,4,50)\n\nsigmaOne = 1\nepsilonOne = 1\nsigmaTwo = 2\nepsilonTwo = 2\nenergyOne = 4 * sigmaOne* ((epsilonOne/r)**12 - (epsilonOne/r)**6)\nenergyTwo = 4 * sigmaTwo * ((epsilonTwo/r)**12 - (epsilonTwo/r)**6)\n\nplt.figure()\nplt.plot(r,energyOne,r,energyTwo,marker = 'o')\nplt.xlim(0.5,3.5)\nplt.ylim(-2,5)\nplt.xlabel(\"Separation Distance\")\nplt.ylabel(\"Energy\")\nplt.title(\"Lennard-Jones Potential\")\n\nText(0.5, 1.0, 'Lennard-Jones Potential')\n\n\n\n\n\n\n\n\n\n\n\n11.1.6 Plot Legends\nOften when your figure contains more than one plot, it is helpful to include a plot legend to label the plots. To add a legend, each plot must be a separate command. In each plot command, the keyword argument label should be used to specify the plot’s label. To add the legend, use the command pyplot.ledend() after the plot commands. An example is given below:\n\nfrom matplotlib import pyplot as plt\n%matplotlib inline\nfrom numpy import linspace,sqrt\n\nr = linspace(0.9,4,50)\n\nsigmaOne = 1\nepsilonOne = 1\nsigmaTwo = 2\nepsilonTwo = 2\nenergyOne = 4 * sigmaOne* ((epsilonOne/r)**12 - (epsilonOne/r)**6)\nenergyTwo = 4 * sigmaTwo * ((epsilonTwo/r)**12 - (epsilonTwo/r)**6)\n\nplt.figure()\nplt.plot(r,energyOne,marker = 'o',label = \"plot1\")\nplt.plot(r,energyTwo,marker = 'x',label = \"plot2\")\nplt.xlim(0.5,3.5)\nplt.ylim(-2,5)\nplt.xlabel(\"Separation Distance\")\nplt.ylabel(\"Energy\")\nplt.title(\"Lennard-Jones Potential\")\nplt.legend()",
    "crumbs": [
      "Intermediate Python",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Basic Plotting</span>"
    ]
  },
  {
    "objectID": "chapters/basicPlotting.html#other-plot-types",
    "href": "chapters/basicPlotting.html#other-plot-types",
    "title": "11  Basic Plotting",
    "section": "11.2 Other Plot Types",
    "text": "11.2 Other Plot Types\nBeyond the line plot that we learned about in the previous section, matplotlib can generate many other types of plots that are very useful in a scientific setting. We’ll explore some of them here.\n\n11.2.1 Logarithmic Plots\nSometimes the function being plotted increases or decreases by many orders of magnitude and a normal linear plot would not be particularly useful. Logarithmic plots can be made with the use of the semilogx, semilogy, or loglog functions depending on which axes you want to be on a logarithmic scale. Consider the first plot produced below. Notice that it rises from \\(0\\) at \\(x = 0\\) to \\(10^{45}\\) at \\(x = 100\\). Plotting this function with the y-axis scaled logarithmically will smooth out the plot and make it easier to analyze.\n\nfrom matplotlib import pyplot as plt\n%matplotlib inline\nfrom numpy import linspace,exp\n\nx = linspace(0,100,200)\ny = exp(x)\n\nplt.figure()\nplt.plot(x,y)\nplt.figure() \nplt.semilogy(x,y)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n11.2.2 Scatter Plots\nWe have already generated scatter plots using the plot function but you can also use the scatter command to do the same thing. The only other additional functionality with scatter is the ability to specify the color, shape, and size of each plot marker individually.\n\nfrom matplotlib import pyplot as plt\n%matplotlib inline\nfrom numpy import linspace,log\n\nd = [5.8e10,1.9e11,1.5e11,2.3e11,7.8e11,1.4e12,2.9e12,4.5e12]\n#d = [1,2,3,4,5,6,7,8]\nT = [0.241,0.615,1,1.88,11.9,29.5,84,165]\nmass = [3.2e23,4.9e24,6e24,6.4e23,1.9e27,5.7e26,8.7e25,1e26]\n\nplt.figure()\nplt.scatter(d,T,c = mass,s= 50)\nplt.xlabel(\"Orbital Distance from Sun\")\nplt.ylabel(\"Length of day (in earth days)\")\nplt.title(\"Length of day for planets in our solar system (color indicates mass)\")\nplt.colorbar()\n\n\n\n\n\n\n\n\n\n\n11.2.3 Bar Plots\nA bar plot and a scatter plot are quite similar except that instead of a plot marker indicating the associated value, the height of the bar represents the value. You can make a bar plot using the bar function inside of pyplot.\n\nfrom matplotlib import pyplot as plt\n%matplotlib inline\nfrom numpy import linspace,sqrt\n\n#d = [5.8e10,1.9e11,1.5e11,2.3e11,7.8e11,1.4e12,2.9e12,4.5e12]\nd = [1,2,3,4,5,6,7,8]\nT = [0.241,0.615,1,1.88,11.9,29.5,84,165]\n\nplt.figure()\nplt.bar(d,T,tick_label = [\"Mercury\",\"Venus\",\"Earth\",\"Mars\",\"Jupyter\",\"Saturn\",\"Uranus\",\"Neptune\"])\nplt.xlabel(\"Planet Name\")\nplt.ylabel(\"Length of day (in earth days)\")\nplt.title(\"Length of day for planets in our solar system\")\n\nText(0.5, 1.0, 'Length of day for planets in our solar system')\n\n\n\n\n\n\n\n\n\nNotice the optional argument tick_label used to add labels to the bars. If that were left off, the bars would be labeled using the numbers supplied. Other optional arguments that are available for the bar command are given below.\n\nA Few Common bar keyword arguments\n\n\nArgument\nDescription\n\n\n\n\nwidth\nbar width\n\n\ncolor\nbar color\n\n\nxerr\nX error bar\n\n\nyerr\nY error bar\n\n\ncapsize\nsize of caps on error bars\n\n\n\n\n\n11.2.4 Errorbar Plots\nTo make plots with error bars use matplotlilb’s errorbar function. You can choose to add error bars on the x or y axis using the keyword arguments xerr and yerr.\n\nfrom matplotlib import pyplot as plt\n\nfrom numpy import arange\n\nx = arange(0,8,0.5)\ny = x**2\n\nx_err = 0.05 # Same error for all points\ny_error = 2 # Different error for each point\n\nplt.errorbar(x,y,linestyle = '-.', marker = 'o',markersize = 3,yerr=y_error,capsize = 5)\n\n\n\n\n\n\n\n\nThe linestyle, marker, and markersize arguments work with this plot type also.\n\n\n11.2.5 Histograms\nHistograms display bars representing the frequency of values in a given data set. Unlike bar plots, the width of the bar is meaningful since the each bar represents the number of x-values that fall within a range given by the width of the bar. A histogram can be constructed using the hist function. There is only one required argument, which is the data set. Some commonly used keyword arguments are bins which specifies how many equally-spaced groups (called bins) to generate and edgecolor which can be used to specify the color of the bar’s edges.\n\nfrom matplotlib import pyplot as plt\n%matplotlib inline\nfrom numpy import linspace,log\n\ndensities = [0.00009,0.000178,0.00125,0.001251,0.001293,0.001977,0.534,0.810,0.900,0.920,0.998,1.000,1.03,1.03,1.25,1.600,1.7,2.6,2.7,3.5,5.515,7.8,7.8,8.6,8.5,11.3,13,13.6,18.7,19.3,21.4,22.4,22.6]\n\nplt.figure()\nplt.hist(densities,bins = 5,edgecolor = 'r')\nplt.xlabel(\"Material Densities\")\nplt.title(r\"Histogram of Material Densities (g/cm$^3$)\")\n\nText(0.5, 1.0, 'Histogram of Material Densities (g/cm$^3$)')\n\n\n\n\n\n\n\n\n\nHere we have used bins = 5 which will produce a histogram with \\(5\\) equal-size bins. Alternatively, we can specify the exact locations of all the bin edges by placing them in a list.\n\nfrom matplotlib import pyplot as plt\n%matplotlib inline\nfrom numpy import linspace,log\n\ndensities = [0.00009,0.000178,0.00125,0.001251,0.001293,0.001977,0.534,0.810,0.900,0.920,0.998,1.000,1.03,1.03,1.25,1.600,1.7,2.6,2.7,3.5,5.515,7.8,7.8,8.6,8.5,11.3,13,13.6,18.7,19.3,21.4,22.4,22.6]\n\nplt.figure()\nplt.hist(densities,bins = [0,2.5,5,7.5,10,12.5,15,17.5,20,22.5],edgecolor = 'r')\nplt.xlabel(\"Material Densities\")\nplt.title(r\"Histogram of Material Densities (g/cm$^3$)\")\n\nText(0.5, 1.0, 'Histogram of Material Densities (g/cm$^3$)')\n\n\n\n\n\n\n\n\n\n\n\n11.2.6 Polar Plots\nIn a polar plot instead of providing \\((x,y)\\) coordinates, you provide \\((r,\\theta)\\) coordinates, where \\(r\\) is the radial distance from the origin and \\(\\theta\\) is the angular location on the unit circle.\n\nfrom matplotlib import pyplot as plt\n%matplotlib inline\nfrom numpy import linspace,pi,sin\n\ntheta = linspace(0,4 * pi,150)\nr = sin(2* theta)\n\nplt.figure()\nplt.polar(theta,r)",
    "crumbs": [
      "Intermediate Python",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Basic Plotting</span>"
    ]
  },
  {
    "objectID": "chapters/basicPlotting.html#multifigure-plots",
    "href": "chapters/basicPlotting.html#multifigure-plots",
    "title": "11  Basic Plotting",
    "section": "11.3 Multifigure Plots",
    "text": "11.3 Multifigure Plots\nTo generate multiple, independent plots in the same figure a few more lines of code are necessary to specify how you want the plots arranged. We start with the figure function which generates the canvas upon which the plots will appear. Assign this object to a variable so you can refer to it later. To create each subplot, the fig.add_subplot(rows,columns, plot_number) function is used. There are three arguments to this function; the first two indicate the shape of the grid and the third indicates which position on the grid this plot will be assigned.\nfig.add_subplot(rows,columns,plot_location)\nAfter the axes object has been created, we can call the plot function again, and a plot will be generated at its location. Here is an example that will generate two plots side by side.\n\nfrom matplotlib import pyplot as plt\n%matplotlib inline\nfrom numpy import linspace,sqrt\n\nr = linspace(0.9,4,50)\n\nsigmaOne = 1\nepsilonOne = 1\nsigmaTwo = 2\nepsilonTwo = 2\nenergyOne = 4 * sigmaOne* ((epsilonOne/r)**12 - (epsilonOne/r)**6)\nenergyTwo = 4 * sigmaTwo * ((epsilonTwo/r)**12 - (epsilonTwo/r)**6)\n\nfig = plt.figure()\nax1 = fig.add_subplot(1,2,1)\nax2 = fig.add_subplot(1,2,2)\n\nax1.plot(r,energyOne,marker = '+',color = 'k')\nax1.set_xlim(0.5,3.0)\nax1.set_ylim(-1.5,5)\nax1.set_xlabel(\"Separation Distance\")\nax1.set_ylabel(\"Energy\")\nax1.set_title(\"Lennard-Jones Potential\")\n\nax2.plot(r,energyTwo,marker = 'o',color = 'r')\nax2.set_xlim(0.5,4.0)\nax2.set_ylim(-2,5)\nax2.set_xlabel(\"Separation Distance\")\nax2.set_ylabel(\"Energy\")\nax2.set_title(\"Lennard-Jones Potential\")\n\nText(0.5, 1.0, 'Lennard-Jones Potential')\n\n\n\n\n\n\n\n\n\nPay close attention to the add_subplot function. ax1=add_subplot(1,2,1) will generate a \\(1\\) x \\(2\\) grid of plots and ax1 will correspond to the plot at the 1st location. Below is an example of a more advanced array of plots.\n\nfrom matplotlib import pyplot as plt\n%matplotlib inline\nfrom numpy import linspace,sqrt\n\nr = linspace(0.9,4,50)\n\nsigmaOne = 1\nepsilonOne = 1\nsigmaTwo = 2\nepsilonTwo = 2\nenergyOne = 4 * sigmaOne* ((epsilonOne/r)**12 - (epsilonOne/r)**6)\nenergyTwo = 4 * sigmaTwo * ((epsilonTwo/r)**12 - (epsilonTwo/r)**6)\n\nfig = plt.figure()\nax1 = fig.add_subplot(2,1,1)\nax2= fig.add_subplot(2,2,3)\nax3 = fig.add_subplot(2,2,4)\n\nax1.plot(r,energyOne,marker = '+',color = 'k')\nax1.set_xlim(0.5,3.0)\nax1.set_ylim(-1.5,5)\nax1.set_xlabel(\"Separation Distance\")\nax1.set_ylabel(\"Energy\")\nax1.set_title(\"Lennard-Jones Potential\")\n\nax2.plot(r,energyTwo,marker = 'o',color = 'r')\nax2.set_xlim(0.5,4.0)\nax2.set_ylim(-2,5)\nax2.set_xlabel(\"Separation Distance\")\nax2.set_ylabel(\"Energy\")\nax2.set_title(\"Lennard-Jones Potential\")\n\nax3.plot(r,energyTwo,marker = 'o',color = 'r')\nax3.set_xlim(0.5,4.0)\nax3.set_ylim(-2,5)\nax3.set_xlabel(\"Separation Distance\")\nax3.set_ylabel(\"Energy\")\nax3.set_title(\"Lennard-Jones Potential\")\nplt.tight_layout()\n\n\n\n\n\n\n\n\nAlso notice the set_xlim, set_ylim, set_xlabel etc methods that were used to customize each individual plot. There are a host of other methods available for further customization. This website has a comprehensive list of them.",
    "crumbs": [
      "Intermediate Python",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Basic Plotting</span>"
    ]
  },
  {
    "objectID": "chapters/basicPlotting.html#flashcards",
    "href": "chapters/basicPlotting.html#flashcards",
    "title": "11  Basic Plotting",
    "section": "11.4 Flashcards",
    "text": "11.4 Flashcards\n\nDescribe how to make a simple, no frills plot of a function. Give a short example.\nHow do you modify your plot style to be a red dashed line with triangle markers?\nWhat is the ms keyword argument used for when plotting?\nHow do you add axes labels to a plot?\nHow do you add a title to a plot?\nHow do you insert greek letters into a plot title or axes label?\nHow do you control the size of the plot window (i.e. zoom in or out.)\nHow do you plot multiple plots on the same figure?\nList the other types of plots discussed in this chapter.\nHow do you make a multi-figure plot? Give an example showing the functions that should be used.\nWhere can you find the account of Abinadi?",
    "crumbs": [
      "Intermediate Python",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Basic Plotting</span>"
    ]
  },
  {
    "objectID": "chapters/basicPlotting.html#exercises",
    "href": "chapters/basicPlotting.html#exercises",
    "title": "11  Basic Plotting",
    "section": "11.5 Exercises",
    "text": "11.5 Exercises\n\nIf you were to shine a laser through a very narrow slit, you would see a pattern very similar to the one shown below. The function that describes this light pattern is called a sinc function:\\[ y(x) = \\left({\\sin x\\over x}\\right)^2\\]\n\nPlot this function from \\(-20 &lt; x &lt; 20\\). Then make the following customizations to the plots:\n\nSet the color of the line to be green.\nAdd axes labels to the plot. The x-label should be “Location” and the y-label should by “Intensity”.\nAdd the following title to the plot: “Single-Slit diffraction pattern”\n\n\n\n# python code here\n\n\nMax Planck discovered that all objects emit a spectrum of light and the intensity of that spectrum is given by the following function (we did this in a previous homework problem) \\[ I(\\lambda) = {2 \\pi h c^2 \\over \\lambda^5} {1\\over e^{hc \\over \\lambda k_BT} - 1}\\] where\n\n\\(c = 3.0 \\times 10^8\\) m/s is the speed of light.\n\\(h = 6.26 \\times 10^{-34}\\) m\\(^2\\) kg /s is Plank’s constant.\n\\(k_B = 1.38 \\times 10^{-23}\\) m\\(^2\\)kg s\\(^{-2}\\) K\\(^{-1}\\) is the Boltzmann constant.\nT is temperature in Kelvins.\n\\(\\lambda\\) is wavelength in meters.\n\nFollow the steps below to plot this function for several different temperatures:\n\nCopy the function that you made previously into the cell below. (or build it from scratch)\nUse numpy.linspace to generate a grid of 500 \\(\\lambda\\) values from \\(0.1 \\times 10^{-6} \\rightarrow 3 \\times 10^{-6}\\) m.\nUse list comprehension to produce a list of intensities for the \\(\\lambda\\) values generated in step 2. Use \\(T = 5780\\) K (temperature of the sun).\nPlot intensity vs. \\(\\lambda\\) .\n\nRepeat steps 3 and 4 for \\(T = 4500\\) K. You should have two plots on the same figure. Choose the line style and color to be different than the first plot.\nAdd a legend to the figure. Use the temperatures as the labels.\nGo here and compare your results with the plots there to make sure you did it right.\n\n\n\n# Python code here\n\n\nThis file contains telemetry data for a weather balloon that was launched by the BYU-Idaho High Altitude Research Team (HART). The 5th and 7th columns in the file contain the speed and altitude of the balloon respectively. Read the data file and extract the speed and altitude of the balloon into lists or arrays. Then make a scatter plot of speed vs. altitude. Add axes labels and plot labels to your plot.\n\n\n# Python code here\n\n\nThis file contains worldwide earthquake data from the years 1973 to 2021. The fourth column in the file contains the magnitude of the earthquakes. Read the file and plot a histogram of this column. Set bins = 200 to make 200, equally-spaced bins on the histogram. Then write a single statement summarizing what this plot is communicating to you. Note: The file is zipped so you’ll need to unzip it before you can read it in.\n\n\n# Python code here\n\n\nThe position and velocity coordinates for a projectile launched at angle \\(\\theta\\) are given by: \\[x(t) = x_i + v_i \\cos \\theta t \\] \\[ y(t) = y_i + v_i \\sin \\theta  t + {1\\over 2} a  t^2\\] \\[v_x(t) = v_i \\cos \\theta\\] \\[v_y(t) = v_i \\sin \\theta + g  t\\] where \\(g = -9.8\\) m/s\\(^2\\). Place the following plots on a 3 x 2 grid for \\(0 &lt; t &lt; 5.5\\) seconds: \\(x\\) vs \\(y\\) (first row, spans both columns), \\(x\\) vs \\(t\\) (second row, first column), \\(y\\) vs \\(t\\)(second row, second column), \\(v_x\\) vs \\(t\\)(third row, first column), and \\(v_y\\) vs \\(t\\)(third row, second column). Make sure that all of the plots have titles and axes labels. Use the following initial conditions: \\[v_i = 60 \\text{ m/s}\\] \\[\\theta = 22^\\circ\\] \\[x_i = 0 \\text{ m}\\] \\[y_i = 15 \\text{ m}\\]\n\n\n# Python code here\n\n\n(Extra Credit) The 7th column in the Earthquakes data file contains the date of the earthquake. Write a code to plot the number of earthquakes that occurred each year from 1973 to 2021. (The horizontal axis is year and the vertical axis is the number of earthquakes.)\n\n\n# Python code here",
    "crumbs": [
      "Intermediate Python",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Basic Plotting</span>"
    ]
  },
  {
    "objectID": "chapters/advancedPlotting.html",
    "href": "chapters/advancedPlotting.html",
    "title": "12  Advanced Plotting",
    "section": "",
    "text": "12.1 Making 2-D Grids\nJupyter Notebook\nIn this chapter you will learn how to plot functions of more than one variable \\(F(x,y)\\). Functions like this can be visualized by making a contour plots (like a topographic map) or by displaying the function value as height above the \\(x-y\\) plane like a perspective drawing. You can also display vector-valued function \\(\\mathbf{F}(x,y)\\) using vector field plots.\nWhen plotting a function of one variable, recall that the first step was to use linspace or arange to construct a grid of points spanning the domain of the function. For a function of two variables the domain is two-dimensional and hence the grid will also need to be two-dimensional. In other words, we need to construct a set of x-y pairs that spans the two-dimensional domain. We can do this using numpy.meshgrid and numpy.mgrid. Let’s see an example and then explain the pieces. Below you will find some code to plot the function: \\[f(x,y) = \\cos({\\pi \\over 2} x) \\exp(-y^2)\\] (see the code comments)\nfrom numpy import arange,meshgrid,cos,exp,pi,mgrid\nfrom matplotlib import pyplot as plt\n#from mpl_toolkits.mplot3d import Axes3D  #&lt;- You need this to make 3D plots\n# Define the arrays x and y\n# Don't make the step size too small or you will kill the\n# system (you have a large, but finite amount of memory)\nx=arange(-2,2,0.1)\ny=arange(-2,2,0.1)\n# Use meshgrid to convert these 1-d arrays into 2-d matrices\n# of x and y values over the plane\nX,Y=meshgrid(x,y)\n#X,Y=mgrid[-1:1:0.1,0:1.5:0.1]  # You could also do this in place of meshgrid\n# Get F(x,y) by using F(X,Y).\n# rather than with x and y\nF=cos(pi/2*X)*exp(-Y**2)\n# Plot the function\nfig = plt.figure()\nax = plt.axes(projection = '3d')\nax.plot_surface(X,Y,F)\nplt.xlabel('x')\nplt.ylabel('y')\nplt.show()\nLet’s break down this block of code one piece at a time. First, notice that anytime you want a 3 dimensional plot, you have to create a three-dimensional set of axes with the following command\nax=pyplot.axes(projection='3d')  # Set the axes to be 3 dimensional\nNext, meshgrid turns the one-dimensional arrays x and y into two-dimensional arrays X and Y. As an example, inspect the output from the cell below:\nfrom numpy import meshgrid\nx = [1,2,3]\ny = [4,5]\n\nX,Y = meshgrid(x,y)\nprint(X)\nprint(Y)\n\n[[1 2 3]\n [1 2 3]]\n[[4 4 4]\n [5 5 5]]\nThese two arrays provide a set of x-y coordinate pair that span the domain, as illustrated in the figure.\nNumpy also has a command called mgrid which is similar to meshgrid but does the conversion to two dimensions the other way around. As an example, inspect the output in the cell below.\nfrom numpy import mgrid\n\nX,Y = mgrid[1:4,4:6]\nprint(X)\nprint(Y)\n\n\nX,Y = mgrid[1:4:0.5,4:6:0.5]  \nprint(X)\nprint(Y)\n\n\nX,Y = mgrid[1:4:10j,4:6:10j] \nprint(X)\nprint(Y)\n\n[[1 1]\n [2 2]\n [3 3]]\n[[4 5]\n [4 5]\n [4 5]]\n[[1.  1.  1.  1. ]\n [1.5 1.5 1.5 1.5]\n [2.  2.  2.  2. ]\n [2.5 2.5 2.5 2.5]\n [3.  3.  3.  3. ]\n [3.5 3.5 3.5 3.5]]\n[[4.  4.5 5.  5.5]\n [4.  4.5 5.  5.5]\n [4.  4.5 5.  5.5]\n [4.  4.5 5.  5.5]\n [4.  4.5 5.  5.5]\n [4.  4.5 5.  5.5]]\n[[1.         1.         1.         1.         1.         1.\n  1.         1.         1.         1.        ]\n [1.33333333 1.33333333 1.33333333 1.33333333 1.33333333 1.33333333\n  1.33333333 1.33333333 1.33333333 1.33333333]\n [1.66666667 1.66666667 1.66666667 1.66666667 1.66666667 1.66666667\n  1.66666667 1.66666667 1.66666667 1.66666667]\n [2.         2.         2.         2.         2.         2.\n  2.         2.         2.         2.        ]\n [2.33333333 2.33333333 2.33333333 2.33333333 2.33333333 2.33333333\n  2.33333333 2.33333333 2.33333333 2.33333333]\n [2.66666667 2.66666667 2.66666667 2.66666667 2.66666667 2.66666667\n  2.66666667 2.66666667 2.66666667 2.66666667]\n [3.         3.         3.         3.         3.         3.\n  3.         3.         3.         3.        ]\n [3.33333333 3.33333333 3.33333333 3.33333333 3.33333333 3.33333333\n  3.33333333 3.33333333 3.33333333 3.33333333]\n [3.66666667 3.66666667 3.66666667 3.66666667 3.66666667 3.66666667\n  3.66666667 3.66666667 3.66666667 3.66666667]\n [4.         4.         4.         4.         4.         4.\n  4.         4.         4.         4.        ]]\n[[4.         4.22222222 4.44444444 4.66666667 4.88888889 5.11111111\n  5.33333333 5.55555556 5.77777778 6.        ]\n [4.         4.22222222 4.44444444 4.66666667 4.88888889 5.11111111\n  5.33333333 5.55555556 5.77777778 6.        ]\n [4.         4.22222222 4.44444444 4.66666667 4.88888889 5.11111111\n  5.33333333 5.55555556 5.77777778 6.        ]\n [4.         4.22222222 4.44444444 4.66666667 4.88888889 5.11111111\n  5.33333333 5.55555556 5.77777778 6.        ]\n [4.         4.22222222 4.44444444 4.66666667 4.88888889 5.11111111\n  5.33333333 5.55555556 5.77777778 6.        ]\n [4.         4.22222222 4.44444444 4.66666667 4.88888889 5.11111111\n  5.33333333 5.55555556 5.77777778 6.        ]\n [4.         4.22222222 4.44444444 4.66666667 4.88888889 5.11111111\n  5.33333333 5.55555556 5.77777778 6.        ]\n [4.         4.22222222 4.44444444 4.66666667 4.88888889 5.11111111\n  5.33333333 5.55555556 5.77777778 6.        ]\n [4.         4.22222222 4.44444444 4.66666667 4.88888889 5.11111111\n  5.33333333 5.55555556 5.77777778 6.        ]\n [4.         4.22222222 4.44444444 4.66666667 4.88888889 5.11111111\n  5.33333333 5.55555556 5.77777778 6.        ]]\nAll three-dimensional plots will require that you first use meshgrid or mgrid to generate a grid over the two-dimensional domain.\nThe default viewing angle can often be less than optimal for viewing the function well. To modify the viewing angle, use the function view_init, which takes up to three arguments: the viewing altitude, the rotation angle about the z-axis, and the rotation angle above the x-y plane.",
    "crumbs": [
      "Intermediate Python",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Advanced Plotting</span>"
    ]
  },
  {
    "objectID": "chapters/advancedPlotting.html#making-2-d-grids",
    "href": "chapters/advancedPlotting.html#making-2-d-grids",
    "title": "12  Advanced Plotting",
    "section": "",
    "text": "To Do:\n\nPrint out X and Y and inspect the output until you understand what meshgrid does.\nReplace the function in the cell above with one of your choosing.\n\n\n\n\n\n\n\n\n\n\nmeshgrid\n\n\n\n\n\nTo Do:\n\nExamine all three sets of output from the cell above until you understand the differences.\nWhat happens when you add a third index to mgrid?\nWhat happens if the third index is imaginary (i.e. 10j)?",
    "crumbs": [
      "Intermediate Python",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Advanced Plotting</span>"
    ]
  },
  {
    "objectID": "chapters/advancedPlotting.html#surface-plots",
    "href": "chapters/advancedPlotting.html#surface-plots",
    "title": "12  Advanced Plotting",
    "section": "12.2 Surface Plots",
    "text": "12.2 Surface Plots\nYou’ve already seen an example of a surface plot above. A similar plot can be generated by replacing plot_surface with plot_wireframe. This plot looks similar to the surface plot shown above. See the cell below for an example.\n\nfrom numpy import arange,meshgrid,cos,exp,pi,mgrid\nfrom matplotlib import pyplot as plt\n\nx=arange(-2,2,0.1)\ny=arange(-1.5,1.5,0.1)\n\nX,Y=meshgrid(x,y)\n\nF=cos(pi/2*X)*exp(-Y**2)\n\nax=plt.axes(projection='3d')\nax.plot_wireframe(X,Y,F)\nax.set_xlabel('x')\nax.set_ylabel('y')\nax.set_zlabel('y')\nplt.show()",
    "crumbs": [
      "Intermediate Python",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Advanced Plotting</span>"
    ]
  },
  {
    "objectID": "chapters/advancedPlotting.html#contour-plots",
    "href": "chapters/advancedPlotting.html#contour-plots",
    "title": "12  Advanced Plotting",
    "section": "12.3 Contour Plots",
    "text": "12.3 Contour Plots\nPython generates contour plots very similarly to surface plots. Instead of using plot_surface or plot_wireframe, the function contour is used. Look at the example below.\n\nfrom numpy import arange,meshgrid,cos,exp,pi,mgrid\nfrom matplotlib import pyplot as plt\n\nx=arange(-2,2,0.1)\ny=arange(-1.5,1.5,0.1)\n\nX,Y=meshgrid(x,y)\n\nF=cos(pi/2*X)*exp(-Y**2)\n\nax=plt.axes()\nax.contour(X,Y,F)\nax.set_xlabel('x')\nax.set_ylabel('y')\nplt.show()\n\n\n\n\n\n\n\n\n\n12.3.1 The levels keyword argument\nThe keyword argument levels can be added to the function call to specify which (or how many) contours are displayed. If levels = n where n is an integer, the contour function will plot n contours. If levels = [a,b,c] then the contour function will lines of constant value equal to the values specified. The code block below gives a few examples.\n\nfrom numpy import arange,meshgrid,cos,exp,pi,mgrid\nfrom matplotlib import pyplot as plt\n\nx=arange(-2,2,0.1)\ny=arange(-1.5,1.5,0.1)\n\nX,Y=meshgrid(x,y)\n\nF=cos(pi/2*X)*exp(-Y**2)\n\nax=plt.axes()\nax.contour(X,Y,F,levels = 5)\nax.set_xlabel('x')\nax.set_ylabel('y')\nplt.show()\n\n\n\n\n\n\n\n\n\nfrom numpy import arange,meshgrid,cos,exp,pi,mgrid\nfrom matplotlib import pyplot\n\nx=arange(-2,2,0.1)\ny=arange(-1.5,1.5,0.1)\n\nX,Y=meshgrid(x,y)\n\nF=cos(pi/2*X)*exp(-Y**2)\n\nax=plt.axes()\nax.contour(X,Y,F,levels = [-0.5,0.25,0.75])\nax.set_xlabel('x')\nax.set_ylabel('y')\nplt.show()",
    "crumbs": [
      "Intermediate Python",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Advanced Plotting</span>"
    ]
  },
  {
    "objectID": "chapters/advancedPlotting.html#vector-field-plots",
    "href": "chapters/advancedPlotting.html#vector-field-plots",
    "title": "12  Advanced Plotting",
    "section": "12.4 Vector-Field Plots",
    "text": "12.4 Vector-Field Plots\nIn electricity and magnetism you’ll encounter functions that produce a vector (\\(\\mathbf{F}(x,y)\\)) instead of a number(\\(F(x,y)\\)) like you may be used to. In other words, instead of associating a number with every (x,y) pair, a vector \\((f_x,f_y)\\) is associated with each pair. You can plot a vector field using the quiver function, which takes four required arguments. The first two are the output from meshgrid just as with the other plots we have done. The third and fourth arguments are the components of the vectors at each (x,y) pair. Below is an example of how to plot the following vector-valued function \\[\\mathbf{B} = (-y/(x^2 + y^2),x/(x^2 + y^2))\\]\n\nfrom numpy import arange, meshgrid,sqrt,log\nfrom matplotlib import pyplot\nx = arange(-5.25,5.25,0.5) # define the x and y grids (avoid (0,0))\ny = arange(-5.25,5.25,0.5) # define the x and y grids (avoid (0,0))\nX,Y=meshgrid(x,y)\n\n# Magnetic field of a long current-carrying wire\nBx=-Y/(X**2+Y**2)\nBy=X/(X**2+Y**2)\n# make the field arrow plot\npyplot.figure()\npyplot.quiver(X,Y,Bx,By)\npyplot.axis('equal')  # make the x and y axes be equally scaled\npyplot.title('B of a long current-carrying wire')\npyplot.show()\n\n\n\n\n\n\n\n\nOften, the lengths of these vectors will be large and that makes it hard to look at the graphic. One option for improving this is to force all of the vectors to have length \\(1\\) and then color the vector according to the true length. To set the color of the arrows, add a fifth argument to the function that contains the vector lengths. You can then add the keyword argument cmap to specify the color spectrum to use. My favorite is gist_rainbow but there are others here.\n\nfrom numpy import arange, meshgrid,sqrt,log\nfrom matplotlib import pyplot\nx = arange(-5.25,5.25,0.5) # define the x and y grids (avoid (0,0))\ny = arange(-5.25,5.25,0.5) # define the x and y grids (avoid (0,0))\nX,Y=meshgrid(x,y)\n\n# Magnetic field of a long current-carrying wire\nBx=-Y/(X**2+Y**2)\nBy=X/(X**2+Y**2)\nB = sqrt(Bx**2 + By**2)  # Find the magnitude of the vectors.\n# make the field arrow plot\npyplot.figure()\npyplot.quiver(X,Y,Bx/B,By/B,B,cmap=\"gist_rainbow\")  # Divide by magnitude to make them equal to 1\npyplot.axis('equal')  # make the x and y axes be equally scaled\npyplot.title('B of a long current-carrying wire')\npyplot.show()",
    "crumbs": [
      "Intermediate Python",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Advanced Plotting</span>"
    ]
  },
  {
    "objectID": "chapters/advancedPlotting.html#animations",
    "href": "chapters/advancedPlotting.html#animations",
    "title": "12  Advanced Plotting",
    "section": "12.5 Animations",
    "text": "12.5 Animations\nOften you will want to see how a plot evolves over time. Maybe you are plotting the waveform on a string and you want to see how it changes in time. Animations can be built by repeatedly constructing a new plot and then waiting before you clear the canvas and plot again. Look at the example below to see how to do this:\n\nfrom numpy import arange,sin,cos\nfrom matplotlib import pyplot as plt\n%matplotlib\n\nt=0\nx = arange(0,5,0.01) #Domain over which I want to plot the function.\nwhile t &lt; 10:\n    y=sin(5*x-3*t)*cos(2*x) #Constructarrayoffunction\n                                         # values at current time.\n    pyplot.clf()  # Clear the canvas, otherwise all plots end up on\n                  # top of each other\n    pyplot.plot(x,y,'r-',linewidth=3)\n    pyplot.xlabel('x')\n    pyplot.ylabel('f(x)')\n    pyplot.title('t = {:.4f}'.format(t))\n    pyplot.draw()\n    pyplot.pause(0.01)\n    t += .1\n# draw the plot, but don't wait for\n# someone to close the window.\n# Wait before plotting the next one.\n# Advance time.",
    "crumbs": [
      "Intermediate Python",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Advanced Plotting</span>"
    ]
  },
  {
    "objectID": "chapters/advancedPlotting.html#flashcards",
    "href": "chapters/advancedPlotting.html#flashcards",
    "title": "12  Advanced Plotting",
    "section": "12.6 Flashcards",
    "text": "12.6 Flashcards\n\nDescribe the use and output of meshgrid.\nWhat is the difference between meshgrid and mgrid?\nWhat are the three lines of code that must be included if you are building a three-dimensional plot?\nWhat is the difference between plot_surface and plot_wireframe?\nWhat does the levels keyword argument do when making a contour plot? (What possible values can this argument take?)\nWhat is a vector-field plot and how do you generate one in python?\nWhat keyword argument controls the color of the vectors in a vector-field plot?\nWhere can you find the parable of the laborers in the vineyard?",
    "crumbs": [
      "Intermediate Python",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Advanced Plotting</span>"
    ]
  },
  {
    "objectID": "chapters/advancedPlotting.html#exercises",
    "href": "chapters/advancedPlotting.html#exercises",
    "title": "12  Advanced Plotting",
    "section": "12.7 Exercises",
    "text": "12.7 Exercises\n\nPlot the following function from \\(-5 &lt; x,y &lt; 5\\) \\[ f(x,y) = {\\sin (x y)\\over x^2 + y^2}\\]\n\n\n# Python code here\n\n\nMake a contour plot of the function from problem 1. The contours you plot should be where \\(f(x,y) = -0.25, 0, 0.25\\).\n\n\n# Python code here\n\n\nThe range of a projectile launched on level ground is given by: \\[ R = {v_i^2 \\sin(2 \\theta)\\over g}\\] where \\(v_i\\) is the launch speed, \\(\\theta\\) is the launch angle, and \\(g = 9.8\\) m/s\\(^2\\) is the acceleration due to gravity. Plot \\(R(v_i,\\theta)\\) for \\(0 &lt; v_i &lt; 50\\) m/s and \\(0 &lt; \\theta &lt; 90^\\circ\\). Now write a single sentence summarizing the results of the plot.\n\n\n# Python code here\n\n\n(Extra Credit) The angle of impact for a projectile launched with initial speed \\(v\\), launch angle \\(\\theta\\), and initial height \\(y_0\\) is given by: \\[ \\phi = \\tan^{-1} \\left( {\\sqrt{v^2 \\sin^2\\theta + 2 g y_0} \\over v \\cos \\theta} \\right) \\] Plot the impact angle as a function of \\(v\\) and \\(\\theta\\) (\\(\\phi(v,\\theta)\\)) for \\(0 &lt; v_i &lt; 50\\) m/s and \\(0 &lt; \\theta &lt; 90^\\circ\\) and \\(y_i = 10\\) m. Then write a single sentence summarizing the results of the plot.\n\n\n# Python code here",
    "crumbs": [
      "Intermediate Python",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Advanced Plotting</span>"
    ]
  },
  {
    "objectID": "chapters/pandas.html",
    "href": "chapters/pandas.html",
    "title": "13  Pandas",
    "section": "",
    "text": "13.1 Creating dataframes\nJupyter Notebook\nPandas is a Python package built to work with spreadsheet-like data, and it is very good at its job. Pandas stores data in something called a “dataframe”. A dataframe is simply data stored in rows and columns. As an example, here is some sample data taken by an accelerometer sitting on an elevator floor:\ntime,gFx,gFy,gFz\n0.007,-0.0056,-0.0046,1.012\n0.008,0.0007,0.0024,1.0022\n0.008,0,0.0059,1.0039\n0.009,0.0054,-0.0022,1.0032\n0.009,-0.0015,-0.0056,1.0042\n0.009,0.0037,-0.002,0.9951\n0.01,-0.002,-0.002,1.002\n0.014,0.009,-0.0024,1.0159\n0.015,0.0012,-0.0037,1.01\n0.017,-0.0115,-0.002,1.0012\n0.019,-0.0022,-0.0015,1.001\n0.021,0.0024,-0.0022,1.0166\nand here is the same data loaded into a dataframe.\nEvery dataframe has labels attached to its columns and rows. In this example, the row labels are just the first 10 integers and the column labels are “time”, “gFx”, “gFy”, and , “gFz”. Labeling the rows and columns is nice because you can access data using the row and column labels instead of indices.\nA dataframe can be initiated in many ways but the most common are: from file, from a dictionary, and from an array or list. We’ll discuss each way separately.",
    "crumbs": [
      "Intermediate Python",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Pandas</span>"
    ]
  },
  {
    "objectID": "chapters/pandas.html#creating-dataframes",
    "href": "chapters/pandas.html#creating-dataframes",
    "title": "13  Pandas",
    "section": "",
    "text": "13.1.1 Reading from a .csv file.\nThe most-used function from the pandas module is read_csv which is used to read a csv-formatted file into a data frame. To use it, simply call the pandas.read_csv function and pass in the path to the .csv file. (Here is a link to the file.)\n\nfrom pandas import read_csv\n\nelevator_data = read_csv(\"elevator.csv\",index_col = 0)\nprint(elevator_data)\n\n    time     gFx     gFy     gFz\n0  0.007 -0.0056 -0.0046  1.0120\n1  0.008  0.0070  0.0024  1.0022\n2  0.008  0.0000  0.0059  1.0039\n3  0.009  0.0054 -0.0022  1.0032\n4  0.009 -0.0015 -0.0056  1.0042\n5  0.009  0.0037 -0.0020  0.9951\n6  0.010 -0.0020 -0.0020  1.0020\n7  0.014  0.0090 -0.0025  1.0159\n8  0.015  0.0012 -0.0037  1.0100\n9  0.017 -0.0115 -0.0020  1.0012\n\n\nThe keyword argument index_col = 0 indicates that the row labels should be taken from the first column in the csv file. There are many, many possible keyword arguments that can be used to customize the way read_csv reads a file into a dataframe. I’ll highlight just a few and refer you to the documentation for the rest:\n\ndelimiter- use this to specify the character that separates the data from each other. The default is “,” for .csv files.\nheader - use this to specify which row contains the column names. Usually this occurs on the first row (header = 0) but not always.\nusecols - use this to specify which columns from the file should be included in the dataframe.\nskiprows - line numbers to skip when building the dataframe. Can be either a single integer (skip the first n lines) or a list of integers and it will skip all rows in the list.\n\nThe rename() function can be used if you don’t like the default index values (integers if you read from file) and want to reassign them.\n\nfrom pandas import read_csv\n\nelevator_data = read_csv(\"elevator.csv\",index_col = 0)\nelevator_data = elevator_data.rename(index = {0:\"A\",1:\"B\",2:\"C\",3:\"D\",4:\"E\",5:\"F\",6:\"G\",7:\"H\",8:\"I\",9:\"J\"})\nprint(elevator_data)\n\n    time     gFx     gFy     gFz\nA  0.007 -0.0056 -0.0046  1.0120\nB  0.008  0.0070  0.0024  1.0022\nC  0.008  0.0000  0.0059  1.0039\nD  0.009  0.0054 -0.0022  1.0032\nE  0.009 -0.0015 -0.0056  1.0042\nF  0.009  0.0037 -0.0020  0.9951\nG  0.010 -0.0020 -0.0020  1.0020\nH  0.014  0.0090 -0.0025  1.0159\nI  0.015  0.0012 -0.0037  1.0100\nJ  0.017 -0.0115 -0.0020  1.0012\n\n\n\n\n13.1.2 Create from a dictionary\nIf your data is in a dictionary you can use the DataFrame function (case sensitive) to initialize the dataframe. Key values in the dictionary correspond to columns in the dataframe.\n\nfrom pandas import DataFrame\nelevator = {\"time\":[0.007,0.008,0.008,0.009,0.009,0.009,0.01,0.014,0.015,0.017],\"gFx\":[-0.0056,0.007,0,0.0054,-0.0015,0.0037,-0.002,0.009,0.0012,-0.0115],\"gFy\":[-0.0046,0.0024,0.0059,-0.0022,-0.0056,-0.002,-0.002,-0.0025,-0.0037,-0.002],\"gFz\":[1.012,1.0022,1.0039,1.0032,1.0042,0.9951,1.002,1.0159,1.01,1.0012]}\nelevator_data = DataFrame(elevator)\nprint(elevator_data)\n\n    time     gFx     gFy     gFz\n0  0.007 -0.0056 -0.0046  1.0120\n1  0.008  0.0070  0.0024  1.0022\n2  0.008  0.0000  0.0059  1.0039\n3  0.009  0.0054 -0.0022  1.0032\n4  0.009 -0.0015 -0.0056  1.0042\n5  0.009  0.0037 -0.0020  0.9951\n6  0.010 -0.0020 -0.0020  1.0020\n7  0.014  0.0090 -0.0025  1.0159\n8  0.015  0.0012 -0.0037  1.0100\n9  0.017 -0.0115 -0.0020  1.0012\n\n\nThe row indices will default to the a set of integers starting at 0. If you want to index the rows with other labels, use the index keyword argument.\n\nfrom pandas import DataFrame\nelevator = {\"time\":[0.007,0.008,0.008,0.009,0.009,0.009,0.01,0.014,0.015,0.017],\"gFx\":[-0.0056,0.007,0,0.0054,-0.0015,0.0037,-0.002,0.009,0.0012,-0.0115],\"gFy\":[-0.0046,0.0024,0.0059,-0.0022,-0.0056,-0.002,-0.002,-0.0025,-0.0037,-0.002],\"gFz\":[1.012,1.0022,1.0039,1.0032,1.0042,0.9951,1.002,1.0159,1.01,1.0012]}\nelevator_data = DataFrame(elevator,index = [\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\",\"H\",\"J\",\"K\"])\nprint(elevator_data)\n\n    time     gFx     gFy     gFz\nA  0.007 -0.0056 -0.0046  1.0120\nB  0.008  0.0070  0.0024  1.0022\nC  0.008  0.0000  0.0059  1.0039\nD  0.009  0.0054 -0.0022  1.0032\nE  0.009 -0.0015 -0.0056  1.0042\nF  0.009  0.0037 -0.0020  0.9951\nG  0.010 -0.0020 -0.0020  1.0020\nH  0.014  0.0090 -0.0025  1.0159\nJ  0.015  0.0012 -0.0037  1.0100\nK  0.017 -0.0115 -0.0020  1.0012\n\n\n\n\n13.1.3 Create from a list\nSometimes you have data in a list or multiple list and would like to combine all of that data and form a dataframe. This can also be done using the DataFrame function (case sensitive remember!). When initializing with lists, you have to also use the columns keyword argument to specify what you want the column labels to be.\n\nfrom pandas import DataFrame\nfrom numpy import transpose\n\ntime = [0.007,0.008,0.008,0.009,0.009,0.009,0.01,0.014,0.015,0.017]\ngFx = [-0.0056,0.007,0,0.0054,-0.0015,0.0037,-0.002,0.009,0.0012,-0.0115]\ngFy = [-0.0046,0.0024,0.0059,-0.0022,-0.0056,-0.002,-0.002,-0.0025,-0.0037,-0.002]\ngFz = [1.012,1.0022,1.0039,1.0032,1.0042,0.9951,1.002,1.0159,1.01,1.0012]\nelevator_data = DataFrame(transpose([time,gFx,gFy,gFz]),columns = [\"time\", \"gFx\",\"gFy\", \"gFz\"])\n\nThe row labels will default to integers unless you specify otherwise with the index keyword.\n\nfrom pandas import DataFrame\nfrom numpy import transpose\n\ntime = [0.007,0.008,0.008,0.009,0.009,0.009,0.01,0.014,0.015,0.017]\ngFx = [-0.0056,0.007,0,0.0054,-0.0015,0.0037,-0.002,0.009,0.0012,-0.0115]\ngFy = [-0.0046,0.0024,0.0059,-0.0022,-0.0056,-0.002,-0.002,-0.0025,-0.0037,-0.002]\ngFz = [1.012,1.0022,1.0039,1.0032,1.0042,0.9951,1.002,1.0159,1.01,1.0012]\nelevator_data = DataFrame(transpose([time,gFx,gFy,gFz]),columns = [\"time\", \"gFx\",\"gFy\", \"gFz\"],index = [\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\",\"H\",\"J\",\"K\"])",
    "crumbs": [
      "Intermediate Python",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Pandas</span>"
    ]
  },
  {
    "objectID": "chapters/pandas.html#extracting-data",
    "href": "chapters/pandas.html#extracting-data",
    "title": "13  Pandas",
    "section": "13.2 Extracting data",
    "text": "13.2 Extracting data\nExtracting data from the dataframe could mean several things. The most common possibilities include:\n\naccessing a single number using row and column labels or row and column indices.\naccessing one or several columns of the dataframe.\naccessing one or several rows of the dataframe.\nslicing from the “middle” of the dataframe. (i.e. Not entire columns or entire rows.)\naccessing only elements in the dataframe that meet a certain criteria.\n\nWe’ll cover each of these tasks one at a time.\n\n13.2.1 Extracting General Information\nSometimes the dataframe is quite large and you’d like to inspect just a small portion of it. You can use dataframe.head(n) to look at the first n rows in the dataframe and dataframe.tail(n) to look at the last n rows.\n\nelevator_data.head(3)\nelevator_data.tail(4)\n\n\n\n\n\n\n\n\ntime\ngFx\ngFy\ngFz\n\n\n\n\nG\n0.010\n-0.0020\n-0.0020\n1.0020\n\n\nH\n0.014\n0.0090\n-0.0025\n1.0159\n\n\nJ\n0.015\n0.0012\n-0.0037\n1.0100\n\n\nK\n0.017\n-0.0115\n-0.0020\n1.0012\n\n\n\n\n\n\n\nTo get a list of the column or row labels, use the variables dataframe.columns and dataframe.index.\n\nelevator_data.columns\nelevator_data.index\n\nIndex(['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'J', 'K'], dtype='object')\n\n\n\n\n13.2.2 Extracting a single number\nTo extract a single number from a dataframe, use the dataframe.at[] or dataframe.iat[] objects. The at object should be used if you want to locate the number using row and column labels and iat should be used when you want to access the number using row and column indices. Let’s see an example:\n\nfrom pandas import DataFrame\nfrom numpy import transpose\n\ntime = [0.007,0.008,0.008,0.009,0.009,0.009,0.01,0.014,0.015,0.017]\ngFx = [-0.0056,0.007,0,0.0054,-0.0015,0.0037,-0.002,0.009,0.0012,-0.0115]\ngFy = [-0.0046,0.0024,0.0059,-0.0022,-0.0056,-0.002,-0.002,-0.0025,-0.0037,-0.002]\ngFz = [1.012,1.0022,1.0039,1.0032,1.0042,0.9951,1.002,1.0159,1.01,1.0012]\nelevator_data = DataFrame(transpose([time,gFx,gFy,gFz]),columns = [\"time\", \"gFx\",\"gFy\", \"gFz\"],index = [\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\",\"H\",\"J\",\"K\"])\n\nelevator_data.at[\"A\",\"time\"]\nelevator_data.iat[0,0]\n\nnp.float64(0.007)\n\n\nThe loc and iloc dictionaries (see below) can also be used to extract a single entry in the dataframe.\n\n\n13.2.3 Extracting entire columns\nAn entire column of the dataframe can be extract by indexing it like a dictionary, using the column name as the key value\nelevator_data[\"gFz\"]\nelevator_data[\"time\"]\nelevator_data[\"time\"][0:3]\nYou can bundle the column names into a list and extract multiple columns at once.\nelevator_data[[\"gFx\", \"gFy\", \"gFz\"]]\n\n\n13.2.4 Accessing entire rows\nAccessing rows in a dataframe is done with the help of the dataframe.loc[n] or dataframe.iloc[n] dictionary. loc should be used if you want to slice using row and column labels whereas iloc should be used if you want to slice out using indices.\n\nfrom pandas import DataFrame\nfrom numpy import transpose\n\ntime = [0.007,0.008,0.008,0.009,0.009,0.009,0.01,0.014,0.015,0.017]\ngFx = [-0.0056,0.007,0,0.0054,-0.0015,0.0037,-0.002,0.009,0.0012,-0.0115]\ngFy = [-0.0046,0.0024,0.0059,-0.0022,-0.0056,-0.002,-0.002,-0.0025,-0.0037,-0.002]\ngFz = [1.012,1.0022,1.0039,1.0032,1.0042,0.9951,1.002,1.0159,1.01,1.0012]\nelevator_data = DataFrame(transpose([time,gFx,gFy,gFz]),columns = [\"time\", \"gFx\",\"gFy\", \"gFz\"],index = [\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\",\"H\",\"J\",\"K\"])\n\nelevator_data.loc[\"A\"]\nelevator_data.iloc[0]  \n\ntime    0.0070\ngFx    -0.0056\ngFy    -0.0046\ngFz     1.0120\nName: A, dtype: float64\n\n\nMultiple rows can be accessed using the A:B syntax to slice out the desired rows.\n\nfrom pandas import DataFrame\nfrom numpy import transpose\n\ntime = [0.007,0.008,0.008,0.009,0.009,0.009,0.01,0.014,0.015,0.017]\ngFx = [-0.0056,0.007,0,0.0054,-0.0015,0.0037,-0.002,0.009,0.0012,-0.0115]\ngFy = [-0.0046,0.0024,0.0059,-0.0022,-0.0056,-0.002,-0.002,-0.0025,-0.0037,-0.002]\ngFz = [1.012,1.0022,1.0039,1.0032,1.0042,0.9951,1.002,1.0159,1.01,1.0012]\nelevator_data = DataFrame(transpose([time,gFx,gFy,gFz]),columns = [\"time\", \"gFx\",\"gFy\", \"gFz\"],index = [\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\",\"H\",\"J\",\"K\"])\n\nelevator_data.loc[\"A\":\"D\"]\nelevator_data.iloc[0:4]  \n\n\n\n\n\n\n\n\ntime\ngFx\ngFy\ngFz\n\n\n\n\nA\n0.007\n-0.0056\n-0.0046\n1.0120\n\n\nB\n0.008\n0.0070\n0.0024\n1.0022\n\n\nC\n0.008\n0.0000\n0.0059\n1.0039\n\n\nD\n0.009\n0.0054\n-0.0022\n1.0032\n\n\n\n\n\n\n\n\n\n13.2.5 Slicing rows and columns\nThe loc and iloc dictionaries can be used to slice across rows and columns. Simple separate the two slices with a comma:\n\nfrom pandas import DataFrame\nfrom numpy import transpose\n\ntime = [0.007,0.008,0.008,0.009,0.009,0.009,0.01,0.014,0.015,0.017]\ngFx = [-0.0056,0.007,0,0.0054,-0.0015,0.0037,-0.002,0.009,0.0012,-0.0115]\ngFy = [-0.0046,0.0024,0.0059,-0.0022,-0.0056,-0.002,-0.002,-0.0025,-0.0037,-0.002]\ngFz = [1.012,1.0022,1.0039,1.0032,1.0042,0.9951,1.002,1.0159,1.01,1.0012]\nelevator_data = DataFrame(transpose([time,gFx,gFy,gFz]),columns = [\"time\", \"gFx\",\"gFy\", \"gFz\"],index = [\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\",\"H\",\"J\",\"K\"])\n\nelevator_data.loc[\"A\":\"D\",\"time\":\"gFy\"]\nelevator_data.iloc[0:4,0:2]  \n\n\n\n\n\n\n\n\ntime\ngFx\n\n\n\n\nA\n0.007\n-0.0056\n\n\nB\n0.008\n0.0070\n\n\nC\n0.008\n0.0000\n\n\nD\n0.009\n0.0054\n\n\n\n\n\n\n\n\n\n13.2.6 Boolean Slicing\nWe have already seen boolean slicing in Numpy Arrays and we can use something similar on Pandas. Let’s see an example:\n\nfrom pandas import DataFrame\nfrom numpy import transpose\n\ntime = [0.007,0.008,0.008,0.009,0.009,0.009,0.01,0.014,0.015,0.017]\ngFx = [-0.0056,0.007,0,0.0054,-0.0015,0.0037,-0.002,0.009,0.0012,-0.0115]\ngFy = [-0.0046,0.0024,0.0059,-0.0022,-0.0056,-0.002,-0.002,-0.0025,-0.0037,-0.002]\ngFz = [1.012,1.0022,1.0039,1.0032,1.0042,0.9951,1.002,1.0159,1.01,1.0012]\nelevator_data = DataFrame(transpose([time,gFx,gFy,gFz]),columns = [\"time\", \"gFx\",\"gFy\", \"gFz\"],index = [\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\",\"H\",\"J\",\"K\"])\n\nelevator_data[elevator_data[\"time\"] &lt; 0.01]  # Slice only the rows where time &lt; 0.01\n\n\n\n\n\n\n\n\ntime\ngFx\ngFy\ngFz\n\n\n\n\nA\n0.007\n-0.0056\n-0.0046\n1.0120\n\n\nB\n0.008\n0.0070\n0.0024\n1.0022\n\n\nC\n0.008\n0.0000\n0.0059\n1.0039\n\n\nD\n0.009\n0.0054\n-0.0022\n1.0032\n\n\nE\n0.009\n-0.0015\n-0.0056\n1.0042\n\n\nF\n0.009\n0.0037\n-0.0020\n0.9951\n\n\n\n\n\n\n\nThe statement elevator_data[\"time\"] &lt; 0.01 produces a boolean sequence which can be used as a set of indices to access only those entries where time is less than 0.01.\nMore complex boolean slicing can be done with the use of the query function which allows you to be more specific about your boolean conditions. The example below will extract all rows in the dataframe where time &gt; 0.008 and gFz is greater than 1.\n\nfrom pandas import DataFrame\nfrom numpy import transpose\n\ntime = [0.007,0.008,0.008,0.009,0.009,0.009,0.01,0.014,0.015,0.017]\ngFx = [-0.0056,0.007,0,0.0054,-0.0015,0.0037,-0.002,0.009,0.0012,-0.0115]\ngFy = [-0.0046,0.0024,0.0059,-0.0022,-0.0056,-0.002,-0.002,-0.0025,-0.0037,-0.002]\ngFz = [1.012,1.0022,1.0039,1.0032,1.0042,0.9951,1.002,1.0159,1.01,1.0012]\nelevator_data = DataFrame(transpose([time,gFx,gFy,gFz]),columns = [\"time\", \"gFx\",\"gFy\", \"gFz\"],index = [\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\",\"H\",\"J\",\"K\"])\n\nelevator_data.query(\"time &gt; 0.008 and gFz &gt; 1\")\n\n\n\n\n\n\n\n\ntime\ngFx\ngFy\ngFz\n\n\n\n\nD\n0.009\n0.0054\n-0.0022\n1.0032\n\n\nE\n0.009\n-0.0015\n-0.0056\n1.0042\n\n\nG\n0.010\n-0.0020\n-0.0020\n1.0020\n\n\nH\n0.014\n0.0090\n-0.0025\n1.0159\n\n\nJ\n0.015\n0.0012\n-0.0037\n1.0100\n\n\nK\n0.017\n-0.0115\n-0.0020\n1.0012\n\n\n\n\n\n\n\n\n\n13.2.7 Special Characters in Column Name\nOften you will find that your column labels will contain spaces and/or other special characters in them. To correctly specify the column label in these cases, you must enclose the name in graves accents (It’s located above the tab key on your keyboard.). For example, if your column label was ” time-s” instead of just “time” like in the example above, you could use the query function like this:\n\nfrom pandas import DataFrame\nfrom numpy import transpose\n\ntime = [0.007,0.008,0.008,0.009,0.009,0.009,0.01,0.014,0.015,0.017]\ngFx = [-0.0056,0.007,0,0.0054,-0.0015,0.0037,-0.002,0.009,0.0012,-0.0115]\ngFy = [-0.0046,0.0024,0.0059,-0.0022,-0.0056,-0.002,-0.002,-0.0025,-0.0037,-0.002]\ngFz = [1.012,1.0022,1.0039,1.0032,1.0042,0.9951,1.002,1.0159,1.01,1.0012]\nelevator_data = DataFrame(transpose([time,gFx,gFy,gFz]),columns = [\" time-s\", \"gFx\",\"gFy\", \"gFz\"],index = [\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\",\"H\",\"J\",\"K\"])\n\nelevator_data.query(\"` time-s` &gt; 0.008 and gFz &gt; 1\")\n\n\n\n\n\n\n\n\ntime-s\ngFx\ngFy\ngFz\n\n\n\n\nD\n0.009\n0.0054\n-0.0022\n1.0032\n\n\nE\n0.009\n-0.0015\n-0.0056\n1.0042\n\n\nG\n0.010\n-0.0020\n-0.0020\n1.0020\n\n\nH\n0.014\n0.0090\n-0.0025\n1.0159\n\n\nJ\n0.015\n0.0012\n-0.0037\n1.0100\n\n\nK\n0.017\n-0.0115\n-0.0020\n1.0012\n\n\n\n\n\n\n\n\n\n13.2.8 Using Query to match strings\nOften your dataframe will contain strings as the data instead of numbers. If you are trying to use query to find dataframe entries that contain a specified string, you’ll have enclose the boolean expression in single quotes (’’) and enclose the string you are trying to match in double quotes (““). As an example, imagine a dataframe very similar to the one used in the previous example, but with an additional column that specifies whether the object\n\nfrom pandas import DataFrame\nfrom numpy import transpose\n\ndataDict = {\" time-s\":[0.007,0.008,0.008,0.009,0.009,0.009,0.01,0.014,0.015,0.017], \"gFx\":[-0.0056,0.007,0,0.0054,-0.0015,0.0037,-0.002,0.009,0.0012,-0.0115],\"gFy\":[-0.0046,0.0024,0.0059,-0.0022,-0.0056,-0.002,-0.002,-0.0025,-0.0037,-0.002],\"gFz\":[1.012,1.0022,1.0039,1.0032,1.0042,0.9951,1.002,1.0159,1.01,1.0012], \"Here\":[\"Yes\",\"Yes\",\"No\",\"No\",\"Yes\",\"No\",\"Yes\",\"No\",\"Yes\",\"No\"]}\n\nelevator_data = DataFrame(dataDict,index = [\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\",\"H\",\"J\",\"K\"])\n\nelevator_data.query('` time-s` &gt; 0.008 and Here == \"No\"')\n\n\n\n\n\n\n\n\ntime-s\ngFx\ngFy\ngFz\nHere\n\n\n\n\nD\n0.009\n0.0054\n-0.0022\n1.0032\nNo\n\n\nF\n0.009\n0.0037\n-0.0020\n0.9951\nNo\n\n\nH\n0.014\n0.0090\n-0.0025\n1.0159\nNo\n\n\nK\n0.017\n-0.0115\n-0.0020\n1.0012\nNo\n\n\n\n\n\n\n\n\nTo Do:\n\nAdd print statements to the cell above until you understand what each line of code does.\nAdd comments next to the line of code to help you remember.",
    "crumbs": [
      "Intermediate Python",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Pandas</span>"
    ]
  },
  {
    "objectID": "chapters/pandas.html#performing-calculations",
    "href": "chapters/pandas.html#performing-calculations",
    "title": "13  Pandas",
    "section": "13.3 Performing Calculations",
    "text": "13.3 Performing Calculations\nDataframes are similar to numpy arrays in that you can do math across an entire dataset. This makes mathematical calculations very easy. Look at the example below and try to guess what calculation is being performed\n\nfrom numpy import sqrt\n\nelevator_data[[\"gFx\", \"gFy\", \"gFz\"]] *= 9.8\na_magnitude  = sqrt(elevator_data[[\"gFx\", \"gFy\", \"gFz\"]]**2).sum(axis = 1)\n\nmax_accel = a_magnitude.max()\n\nelevator_data\n\n\n\n\n\n\n\n\ntime-s\ngFx\ngFy\ngFz\nHere\n\n\n\n\nA\n0.007\n-0.05488\n-0.04508\n9.91760\nYes\n\n\nB\n0.008\n0.06860\n0.02352\n9.82156\nYes\n\n\nC\n0.008\n0.00000\n0.05782\n9.83822\nNo\n\n\nD\n0.009\n0.05292\n-0.02156\n9.83136\nNo\n\n\nE\n0.009\n-0.01470\n-0.05488\n9.84116\nYes\n\n\nF\n0.009\n0.03626\n-0.01960\n9.75198\nNo\n\n\nG\n0.010\n-0.01960\n-0.01960\n9.81960\nYes\n\n\nH\n0.014\n0.08820\n-0.02450\n9.95582\nNo\n\n\nJ\n0.015\n0.01176\n-0.03626\n9.89800\nYes\n\n\nK\n0.017\n-0.11270\n-0.01960\n9.81176\nNo\n\n\n\n\n\n\n\nYou may have noticed that sum method that was used to sum up each column. The keyword argument axis = 1 indicates that you want to sum over rows, not over columns. (axis = 0 would result in summing over columns.) There are a few other handy methods for common mathematical operations.\n\nmin() - Find the minimum value.\nmax() - Find the maximum value.\ncumsum() - Cumulative sum, just like in numpy.\nstd() - Standard deviation.\nmean() - Mean or average.\nquantile(q) - Find value of a give quantile q.\n\nThere are a multitude of other useful math functions available. See here for a more comprehensive list. Basically, any function that numpy has, pandas will also have.",
    "crumbs": [
      "Intermediate Python",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Pandas</span>"
    ]
  },
  {
    "objectID": "chapters/pandas.html#modifying-the-dataframe",
    "href": "chapters/pandas.html#modifying-the-dataframe",
    "title": "13  Pandas",
    "section": "13.4 Modifying the dataframe",
    "text": "13.4 Modifying the dataframe\n\n13.4.1 Adding new columns\nA new column can be added to a dataframe by typing dataframe[columnname] = followed by a list,tuple, or array containing the new entries. For example:\n\nelevator_data[\"a_mag\"]  = sqrt( (elevator_data[[\"gFx\", \"gFy\", \"gFz\"]]**2).sum(axis = 1))\n\n\n\n13.4.2 Adding a new row\nTo add a single (or multiple) rows to a dataframe you should use the concat() function (short for concatenate). This function will join multiple dataframes into one. Below is an example of the usage.\n\nfrom pandas import DataFrame,concat\n\nto_add = DataFrame({\" time-s\":0.02,\"gFx\":-0.028,\"gFy\":0.018,\"gFz\":1.028},index = [\"L\"]) # Build the dataframe to be added.\nfinal = concat([elevator_data,to_add])  # Append using a dictionary.\n\nelevator_data2 = DataFrame({\"time\":[0.02,0.025],\"gFx\":[-0.028,-0.022],\"gFy\":[0.018,-0.012],\"gFz\":[1.028,1.042]})\n\nfinal2 = concat([elevator_data,to_add,elevator_data2]) #Combine all three data frames into one.",
    "crumbs": [
      "Intermediate Python",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Pandas</span>"
    ]
  },
  {
    "objectID": "chapters/pandas.html#other-useful-methods",
    "href": "chapters/pandas.html#other-useful-methods",
    "title": "13  Pandas",
    "section": "13.5 Other useful methods",
    "text": "13.5 Other useful methods\n\n13.5.1 Getting a summary of your dataframe.\nThe describe() function will calculate several useful statistical quantities and display them in a dataframe.\n\nelevator_data.describe()\n\n\n\n\n\n\n\n\ntime-s\ngFx\ngFy\ngFz\na_mag\n\n\n\n\ncount\n10.000000\n10.000000\n10.000000\n10.000000\n10.000000\n\n\nmean\n0.010600\n0.005586\n-0.015974\n9.848706\n9.848937\n\n\nstd\n0.003438\n0.060314\n0.033201\n0.059088\n0.059124\n\n\nmin\n0.007000\n-0.112700\n-0.054880\n9.751980\n9.752067\n\n\n25%\n0.008250\n-0.018375\n-0.033320\n9.820090\n9.820186\n\n\n50%\n0.009000\n0.005880\n-0.020580\n9.834790\n9.834958\n\n\n75%\n0.013000\n0.048755\n-0.019600\n9.883790\n9.883886\n\n\nmax\n0.017000\n0.088200\n0.057820\n9.955820\n9.956241\n\n\n\n\n\n\n\n\n\n13.5.2 Plotting your dataframe.\nA histogram of each column can be easily generate with the dataframe.hist() function.\n\nelevator_data.hist()\n\narray([[&lt;Axes: title={'center': ' time-s'}&gt;,\n        &lt;Axes: title={'center': 'gFx'}&gt;],\n       [&lt;Axes: title={'center': 'gFy'}&gt;, &lt;Axes: title={'center': 'gFz'}&gt;],\n       [&lt;Axes: title={'center': 'a_mag'}&gt;, &lt;Axes: &gt;]], dtype=object)\n\n\n\n\n\n\n\n\n\nTo make a scatter plot of two columns in your dataframe, use dataframe.plot.scatter(). The x and y keyword arguments should be used to specify which columns to plot.\n\nelevator_data.plot.scatter(x = \" time-s\", y = \"gFz\")\n\n\n\n\n\n\n\n\nYou can also plot a single column vs. the row labels using the plot function\n\nelevator_data[\"gFz\"].plot()\n\n\n\n\n\n\n\n\nYou can also use this function to plot a single row vs the column labels.\n\nelevator_data.iloc[2][[\" time-s\",\"gFx\",\"gFy\",\"gFz\"]].plot()\n\n\n\n\n\n\n\n\nA wealth of other functions exist for pandas and I will not exemplify or explain them here because it is beyond the scope of the class. A nice summary sheet for pandas can be found here\n\n\n13.5.3 Writing your dataframe to file\nYou have already used savetxt to save an entire array of numbers to a file in one step. If your data is in a pandas dataframe, saving that dataframe to file couldn’t be easier; just use dataframe.to_csv(\"filename\").\n\nelevator_data.to_csv(\"myelevatorData.csv\")\n\nSeveral helpful keyword arguments are available when writing to a file. I’ll list a few of them below.\n\nsep - Delimiter or character used to separate the data as a length-one string. Default is a comma (“,”).\ncolumns - specify which columns in your dataframe to write as a list of column labels.\nindex - True if you want the row labels written and False if you don’t\ncompression - specify the compression scheme as a string. Options are ‘zip’,‘gzip’, ‘bz2’,‘zstd’, and ‘tar’.\n\nDepending on the type of data you are working with, there is a good argument for always using to_csv to write data to file, never needing savetxt.",
    "crumbs": [
      "Intermediate Python",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Pandas</span>"
    ]
  },
  {
    "objectID": "chapters/sympy.html",
    "href": "chapters/sympy.html",
    "title": "14  The sympy module",
    "section": "",
    "text": "14.1 Simple Calculations\nJupyter Notebook\nSympy (pronounced “sim-pie”) is short for symbolic python and can be used to do symbolic math calculations. You may be familiar with other symbolic math packages like Mathematica or Maple. Python’s sympy package will do all of the same things that they will do and it’s nice to not have to switch between two different coding languages.\nYou should be very comfortable performing simple calculations by now. Up to this point all of the calculations that you have performed have been represented approximately, rather than exactly. For example, \\(\\cos({\\pi \\over 6}) = {\\sqrt{3} \\over 2} \\text{ (exact)} \\approx 0.8660254 \\text{ (approximate)}\\) and when you perform this calculation in Python using the math module, the result is approximate:\nfrom math import cos,pi\n\ncos(pi/6)\n\n0.8660254037844387\n\\(0.8660254\\) is an approximate result; it’s very close to the true value but not exact. Sympy can also perform this calculation and the results are represented exactly.\nfrom sympy import cos,pi,init_printing\ninit_printing(use_unicode = True)\n\na=cos(pi/6)\ndisplay(a)\n\n\\(\\displaystyle \\frac{\\sqrt{3}}{2}\\)\nThe init_printing(use_unicode=True) function call tells sympy to display mathematical expressions using “pretty” formatting. Fractions appear with the numerator on top of the denominator, powers are displayed as superscripts, and other mathematical symbols are rendered to make the mathematical expression look right. Sympy can even simplify expressions. For example, \\(\\sqrt{8} = 2 \\sqrt{2}\\) and sympy automatically performs this simplification for us:\nfrom sympy import sqrt\n\nsqrt(8)\n\n\\(\\displaystyle 2 \\sqrt{2}\\)\nIf you prefer to have your expression approximated numerically, you can use the N function.\nfrom sympy import sqrt,N\n\nN(sqrt(8))\n\n\\(\\displaystyle 2.82842712474619\\)",
    "crumbs": [
      "Intermediate Python",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>The `sympy` module</span>"
    ]
  },
  {
    "objectID": "chapters/sympy.html#forming-mathematical-expressions",
    "href": "chapters/sympy.html#forming-mathematical-expressions",
    "title": "14  The sympy module",
    "section": "14.2 Forming Mathematical Expressions",
    "text": "14.2 Forming Mathematical Expressions\n\n14.2.1 Defining Symbols (Mathematical Variables)\nA common equation that comes up in physics is quadratic function with constant coefficients \\[ax^2 + bx + c.\\] To form this expression, we must first define the variables that appear in the expression: x, a, b, and c. The Symbol function (case sensitive) can be used to define these mathematical variables. The argument to the Symbol function should be a string containing the desired name of the variable.\n\nfrom sympy import Symbol\nx = Symbol(\"x\")\na = Symbol(\"a\")\nb = Symbol(\"b\")\nc = Symbol(\"c\")\nx,a,b,c\n\n\\(\\displaystyle \\left( x, \\  a, \\  b, \\  c\\right)\\)\n\n\nInstead of using the Symbol function to initialize variables one at a time, you can initialize multiple variables in one line using the symbols function. The argument to the symbols function should be a string with the names of each variables inside the string and separated by a space.\n\nfrom sympy import symbols\n\nx,a,b,c = symbols(\"x a b c\")\nx,a,b,c\n\n\\(\\displaystyle \\left( x, \\  a, \\  b, \\  c\\right)\\)\n\n\n\n\n14.2.2 Mathematical Expressions\nA mathematical expression, which is composed of multiple mathematical variables (symbols), can now be created using the python variables that we just created\n\nfrom sympy import symbols\nx,a,b,c = symbols(\"x a b c\")\nexpression = a * x**2 + b * x + c\nexpression\n\n\\(\\displaystyle a x^{2} + b x + c\\)\n\n\nExpressions can be used to form new expressions by performing mathematical operations on them\n\nfrom sympy import symbols\n\nx,a,b,c = symbols(\"x a b c\")\nexpression = a * x**2 + b * x + c\n\nnewexpression = x * expression\nnewexpression\n\n\\(\\displaystyle x \\left(a x^{2} + b x + c\\right)\\)",
    "crumbs": [
      "Intermediate Python",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>The `sympy` module</span>"
    ]
  },
  {
    "objectID": "chapters/sympy.html#simplifying-expressions",
    "href": "chapters/sympy.html#simplifying-expressions",
    "title": "14  The sympy module",
    "section": "14.3 Simplifying Expressions",
    "text": "14.3 Simplifying Expressions\nsympy has several handy functions that can perform algebraic manipulations to your expressions. Below you will find some of the most useful functions for simplifying expressions.\n\n14.3.1 Evaluating expressions\nOnce an expression is defined, you can evaluate the expression using the subs method. The argument to this method is a dictionary containing the values to be inserted for the associated variables. An example is given below\n\nfrom sympy import symbols\n\nx,a,b,c = symbols(\"x a b c\")\nexpression = a * x**2 + b * x + c\n\nevalDict ={a:2,b:4,c:9,x:4}\nexpression.subs(evalDict)\n\n\\(\\displaystyle 57\\)\n\n\n\n\n14.3.2 The simplify function\nIf you don’t know exactly how you want your expression simplified, you should first try the simplify function. simplify attempts to apply all of the more specialized functions in a smart way to produce a simpler looking result. To use simplify simply send the desired expression in as an argument.\nsimplify(expression)\n\nfrom sympy import symbols,cos,sin,simplify\nx,y,z = symbols(\"x y z\")\na = simplify(x**2 * z + 4 * x *y*z + 4*y**2*z)\nb = simplify(cos(x)**2 + sin(x)**2)\ndisplay(a)\ndisplay(b)\n\n\\(\\displaystyle z \\left(x^{2} + 4 x y + 4 y^{2}\\right)\\)\n\n\n\\(\\displaystyle 1\\)\n\n\nWhen simplify doesn’t do what you were hoping, you’ll have to think a little bit harder about how you want to simplify your expression. The functions described in the rest of this section will help you in your choice.\n\n\n14.3.3 The expand function\nThe expand function will put a polynomial function into its canonical monomial form. For example, expanding the following polynomial \\[(x + 1)^2\\] will produce the standard form of the polynomial \\[x^2 + 2x + 1\\]. This may not seem like a simplification but nevertheless it can be helpful at times. To expand a polynomial, call the expand function and send in the expression that you want expanded.\nexpand(expression)\n\nfrom sympy import symbols,expand\nx = symbols(\"x\")\na = expand((x + 2) * (x - 3))\nb = expand((x+3)**2)\ndisplay(a)\ndisplay(b)\n\n\\(\\displaystyle x^{2} - x - 6\\)\n\n\n\\(\\displaystyle x^{2} + 6 x + 9\\)\n\n\nSometimes expanding an expression can result in a single number due to cancellation.\n\nfrom sympy import Symbol,expand\nx = Symbol(\"x\")\nexpand((x + 1)*(x - 2) - (x - 1)*x)\n\n\\(\\displaystyle -2\\)\n\n\n\n\n14.3.4 The factor function\nThe factor function does the opposite of expand, taking a canonical polynomial and attempting to factor it into its irreducible parts. For example, factoring the expression below \\[x^3 - x^2 + x -1\\] will produce \\[(x-1)(x^2 + 1)\\]\n\nfrom sympy import symbols,factor\nx,y,z = symbols(\"x y z\")\nfactor(x**2 * z + 4 * x *y*z + 4*y**2*z)\n\n\\(\\displaystyle z \\left(x + 2 y\\right)^{2}\\)\n\n\nYou can also factor an expression that isn’t a polynomial. The following trigonometric function can be factored \\[\\cos(x)^2 + 2 \\cos(x)\\sin(x) + \\sin(x)^2\\] into \\[(\\sin(x) + \\cos(x))^2\\]\n\nfrom sympy import symbols,factor,cos,sin\nx,y,z = symbols(\"x y z\")\nfactor(cos(x)**2 + 2 * cos(x) * sin(x) + sin(x)**2)\n\n\\(\\displaystyle \\left(\\sin{\\left(x \\right)} + \\cos{\\left(x \\right)}\\right)^{2}\\)\n\n\n\n\n14.3.5 The collect function\nThe collect function gathers terms with common powers in an expression. The function takes two arguments: the first is the expression and the second specifies which variable’s powers should be collected.\ncollect(expression, variable)\n\nfrom sympy import symbols,collect\nx,y,z = symbols(\"x y z\")\ncollect(x*y + x - 3 + 2 * x**2 - z *x**2 + x**3,x)\n\n\\(\\displaystyle x^{3} + x^{2} \\left(2 - z\\right) + x \\left(y + 1\\right) - 3\\)\n\n\n\n\n14.3.6 The cancel function\nThe cancel function is helpful for simplifying an expression by canceling out like terms where possible. This function takes just a single argument, which is the expression to be simplified. The code below will simplify the following expression by canceling the common (x+1) that appears in both the numerator and denominator. \\[{x^2 + 2 x + 1 \\over x^2 + x}\\]\n\nfrom sympy import symbols,cancel\nx,y,z = symbols(\"x y z\")\ncancel((x**2 + 2*x + 1)/(x**2 + x))\n\n\\(\\displaystyle \\frac{x + 1}{x}\\)\n\n\n\n\n14.3.7 The trigsimp function\nIf you want to use trigonometric identities to simplify your expression use the trigsimp function. For example, most of us know that \\(\\cos(x)^2 + \\sin(x)^2 = 1\\). trigsimp will perform this simplification for us.\n\nfrom sympy import symbols,trigsimp,cos,sin\nx = symbols(\"x\")\ntrigsimp(cos(x)**2 + sin(x)**2)\n\n\\(\\displaystyle 1\\)\n\n\n\n\n14.3.8 The expand_trig function\nexpand_trig is the opposite of trigsimp and usually makes trig functions longer, but that can still be a useful way to view the function. Below we expand the expression \\[\\sin(x + y)\\] using a trig identity.\n\nfrom sympy import symbols,expand_trig\nx,y = symbols(\"x y\")\nexpand_trig(sin(x + y))\n\n\\(\\displaystyle \\sin{\\left(x \\right)} \\cos{\\left(y \\right)} + \\sin{\\left(y \\right)} \\cos{\\left(x \\right)}\\)",
    "crumbs": [
      "Intermediate Python",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>The `sympy` module</span>"
    ]
  },
  {
    "objectID": "chapters/sympy.html#calculus",
    "href": "chapters/sympy.html#calculus",
    "title": "14  The sympy module",
    "section": "14.4 Calculus",
    "text": "14.4 Calculus\nsympy can do common calculus operations on symbolic expressions. We’ll cover: derivatives, integrals, and limits.\n\n14.4.1 Derivatives\nTo calculate the derivative of an expression, use the diff function, which takes two arguments. The first is the expression that you want to take the derivative of and the second is the differentiating variable. In the cell below we calculate the derivative \\[{d\\over dx} \\cos(x)\\]\n\nfrom sympy import symbols,diff,cos\nx = symbols(\"x\")\ndiff(cos(x),x)\n\n\\(\\displaystyle - \\sin{\\left(x \\right)}\\)\n\n\nTo take multiple derivatives, simply add more xs to the diff function call. Below we calculate the derivative \\[{d^2\\over dx^2} \\cos(x)\\]\n\nfrom sympy import symbols,diff,cos\nx = symbols(\"x\")\ndiff(cos(x),x,x)\n\n\\(\\displaystyle - \\cos{\\left(x \\right)}\\)\n\n\ndiff can perform partial derivatives too. Below we perform the following partial derivatives \\[{\\partial^2 \\over \\partial z^2} {\\partial \\over \\partial y} {\\partial \\over \\partial x} \\exp(x y z)\\]\n\nfrom sympy import symbols,diff,exp\nx,y,z = symbols(\"x y z\")\ndiff(exp(x * y * z),x,y,z,z)\n\n\\(\\displaystyle x y \\left(x^{2} y^{2} z^{2} + 5 x y z + 4\\right) e^{x y z}\\)\n\n\nA differentiated function is a sympy expression just as good as any other and we can make a plot of it by evaluating the expression over a grid of values.\n\nfrom sympy import symbols,diff\nimport numpy as np\nimport matplotlib.pyplot as plt\nx,a,b,c = symbols(\"x a b c\")\nexpression = a * x**2 + b * x + c\n\nnewexpression = diff(expression,x)\nxarray = np.arange(0,5,0.1)\ny = [expression.subs({a:-2,b:4,c:9,x:X}) for X in xarray]\nyprime = [newexpression.subs({a:-2,b:4,c:9,x:X}) for X in xarray]\nplt.plot(xarray,yprime,'r.-',label= \"y'(x)\")\nplt.plot(xarray,y,'b.-',label= \"y(x)\")\nplt.legend()\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n14.4.2 Integrals\nUse the integrate function to perform definite and indefinite integrals. For definite integral, the function should be called with two arguments; the first is the expression to be integrated and the second is the tuple containing the integration limits. Below we integrate \\[ \\int_0^5 \\exp(-x) dx\\]\n\nfrom sympy import integrate, Symbol\n\nx = Symbol(\"x\")\n\nintegrate(exp(-x),(x,0,5))\n\n\\(\\displaystyle 1 - e^{-5}\\)\n\n\nThe limits of your integral can be at infinity by importing oo and using it in the limit specification.\n\nfrom sympy import integrate, Symbol,oo\n\nx = Symbol(\"x\")\n\nintegrate(exp(-x),(x,0,oo))\n\n\\(\\displaystyle 1\\)\n\n\nMultiple integrations can be carried out by adding more arguments to the integrate function, each one specifying the limits for that variable. Here we integrate \\[\\int_0^\\infty \\int_0^\\infty \\exp(-x^2 -y^2) dx dy \\]\n\nfrom sympy import integrate, symbols,oo\n\nx,y = symbols(\"x y\")\n\nintegrate(exp(-x**2 - y**2),(x,0,oo),(y,0,oo))\n\n\\(\\displaystyle \\frac{\\pi}{4}\\)\n\n\nIndefinite integrals can be performed by omitting the limit specification and just indicating the variable to be integrated over. Below we perform the following indefinite integral \\[\\int \\int x^2 + y^2 dx dy \\]\n\nfrom sympy import integrate, symbols\n\nx,y = symbols(\"x y\")\n\nintegrate(x**2 + y**2,x,y)\n\n\\(\\displaystyle \\frac{x^{3} y}{3} + \\frac{x y^{3}}{3}\\)\n\n\n\n\n14.4.3 Limits\nsympy can compute limits symbolically with the limit function. The function takes three arguments: the expression, the variable of interest, and the limiting value for that variable. Below we take the following limit \\[\\lim_{x \\to 0} {\\sin(x)\\over x}\\]\n\nfrom sympy import limit, Symbol,sin\n\nx = Symbol(\"x\")\n\nlimit(sin(x)/x,x,0)\n\n\\(\\displaystyle 1\\)",
    "crumbs": [
      "Intermediate Python",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>The `sympy` module</span>"
    ]
  },
  {
    "objectID": "chapters/sympy.html#solving-equations",
    "href": "chapters/sympy.html#solving-equations",
    "title": "14  The sympy module",
    "section": "14.5 Solving equations",
    "text": "14.5 Solving equations\nSo far we have seen how to construct expressions but not solve equations. The difference is that an equation is expressing some sort of equality between an multiple expressions. For example, the following is an equation \\[5 x^2 + 3 x - 2 = 10\\] To form an equation, you can use the Eq function. To use it, send in the expression on the left hand side of the equation for the first argument and the expression on the right hand side of the equation for the second argument.\nEq(lhs,rhs)\nBelow we form the equation \\[5 x + 2y = 8\\]\n\nfrom sympy import symbols,Eq\n\nx,y = symbols(\"x y\")\n\nequation = Eq(5 * x + 2 * y , 8)\nequation\n\n\\(\\displaystyle 5 x + 2 y = 8\\)\n\n\n\n14.5.1 Solving single equations\nOnce an equation is created, the solveset function attempts to solve the function for the desired variables. To use solveset, pass the equation as the first argument and the variable being solved for as the second. Here we solve the equation \\[3 x^2 - 5 x =8\\] for \\(x\\)\n\nfrom sympy import symbols,Eq,solveset\n\nx = symbols(\"x\")\n\nequation = Eq(3* x**2 - 5 * x, 8)\nsolveset(equation,x)\n\n\\(\\displaystyle \\left\\{-1, \\frac{8}{3}\\right\\}\\)\n\n\n\n14.5.1.1 No analytic solution\nIn some instances, sympy will not be able to find any solutions to the equation. For example, the solution to \\[{\\sin(x)\\over x} = 1\\] cannot be determined through analytical technique even though there are values of x that solve the equation. For situations like this, sympy will output an expression that is meant to indicate that it can’t find a solution.\n\nfrom sympy import symbols,Eq,solveset,sin\n\nx = symbols(\"x\")\n\nequation = Eq(sin(x)/x, 1)\nsolveset(equation,x)\n\n\\(\\displaystyle \\left\\{x\\; \\middle|\\; x \\in \\mathbb{C} \\wedge - x + \\sin{\\left(x \\right)} = 0 \\right\\} \\setminus \\left\\{0\\right\\}\\)\n\n\n\n\n14.5.1.2 No solution… period\nSome equations really don’t have solutions and sympy can correctly identify these cases. For example, the equation \\[\\exp(x) = 0\\] has no solutions. Let’s see what sympy tells us when we try to solve this one.\n\nfrom sympy import symbols,Eq,solveset,exp\n\nx = symbols(\"x\")\n\nequation = Eq(exp(x), 0)\nsolveset(equation,x)\n\n\\(\\displaystyle \\emptyset\\)\n\n\nThe \\(\\emptyset\\) symbol means an empty set or there are no solutions to this equation.\n\n\n14.5.1.3 Many or Infinite Solutions\nSome equations have infinitely many solutions. For example the following equation \\[x - x = 0\\] is satisfied for any complex or real value of \\(x\\). Let’s see what sympy does when we ask it to solve this one.\n\nfrom sympy import symbols,Eq,solveset\n\nx = symbols(\"x\")\n\nequation = Eq(x-x, 0)\nsolveset(equation,x)\n\n\\(\\displaystyle \\mathbb{C}\\)\n\n\nThe output (\\(\\mathbb{C}\\)) is communicating that the set of all complex numbers are the solution to this equation. (Meaning you can choose any number and it will be a solution to this equation.)\n\n\n\n14.5.2 Solving Systems of equations\nOften you will have multiple equations with multiple unknown variables that you want to solve for. They call this a system of equations. An example would be the following system \\[3 x - 5 y = 8\\] \\[8x + 2y = 3\\]. The normal process for solving this system is to solve one equation for \\(x\\) and then plug the expression that results into the other equation. That equations will only have \\(y\\) as a variable and you can do algebra to solve for it.\n\n14.5.2.1 Linear Systems\nThe example given above is called a linear system because none of the variables are raised to a power. To solve a system like this, use sympy’s linsolve function.\n\nfrom sympy import symbols,Eq,linsolve\n\nx,y = symbols(\"x y\")\n\nequationOne = Eq(3* x - 5 * y, 8)\nequationTwo = Eq(8* x + 2 * y, 3)\nlinsolve([equationOne,equationTwo],(x,y))\n\n\\(\\displaystyle \\left\\{\\left( \\frac{31}{46}, \\  - \\frac{55}{46}\\right)\\right\\}\\)\n\n\nIt isn’t hard to find a system of equations that doesn’t have a solution. \\[12 x - 3 y = 8\\] \\[8x - 2y = 3\\] As with single equations, sympy will indicate this with the empty set symbol (\\(\\emptyset\\)).\n\nfrom sympy import symbols,Eq,linsolve\n\nx,y = symbols(\"x y\")\n\nequationOne = Eq(12* x - 3 * y, 8)\nequationTwo = Eq(8* x - 2 * y, 3)\nlinsolve([equationOne,equationTwo],(x,y))\n\n\\(\\displaystyle \\emptyset\\)\n\n\n\n\n14.5.2.2 Nonlinear Systems\nIf the equations involve variables being raised to powers, we call it a non linear system and you must use sympy’s nonlinsolve to solve the system. For example, here is a nonlinear system \\[3 x^2 + 5 y^2 = 8\\] \\[8x^2 - 12y^2 = 13\\]\n\nfrom sympy import symbols,Eq,nonlinsolve\n\nx,y = symbols(\"x y\")\n\n\neqOne = Eq(3*x**2 + 5*y**2,8)\neqTwo = Eq(8*x**2 - 12*y**2,13)\nnonlinsolve([eqOne,eqTwo],(x,y))\n\n\\(\\displaystyle \\left\\{\\left( - \\frac{\\sqrt{3059}}{38}, \\  - \\frac{5 \\sqrt{19}}{38}\\right), \\left( - \\frac{\\sqrt{3059}}{38}, \\  \\frac{5 \\sqrt{19}}{38}\\right), \\left( \\frac{\\sqrt{3059}}{38}, \\  - \\frac{5 \\sqrt{19}}{38}\\right), \\left( \\frac{\\sqrt{3059}}{38}, \\  \\frac{5 \\sqrt{19}}{38}\\right)\\right\\}\\)",
    "crumbs": [
      "Intermediate Python",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>The `sympy` module</span>"
    ]
  },
  {
    "objectID": "chapters/sympy.html#flashcards",
    "href": "chapters/sympy.html#flashcards",
    "title": "14  The sympy module",
    "section": "14.6 Flashcards",
    "text": "14.6 Flashcards\n\nHow do you define a mathematical variable in Python?\nHow do you form a mathematical expression in Python? (Give an example)\nHow do you form a mathematical equation in Python? (Give an example)\nWhat does the simplify function do?\nWhat does the factor function do?\nHow do you perform a derivative in Python?\nHow do you perform an integral in Python? (definite and indefinite)\nHow do you solve an equation in Python?\nHow do you solve a system of equations in Python?\nHow do you evaluate a definite integral at infinity (\\(\\infty\\))?\nRecite 1 Ne 4:6",
    "crumbs": [
      "Intermediate Python",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>The `sympy` module</span>"
    ]
  },
  {
    "objectID": "chapters/sympy.html#exercises",
    "href": "chapters/sympy.html#exercises",
    "title": "14  The sympy module",
    "section": "14.7 Exercises",
    "text": "14.7 Exercises\n\nDefine a sympy variable for \\(x\\) and then evaluate the following expressions.\n\n\\(\\sin(x + {\\pi \\over 2})\\)\n\\(\\sin(x + \\pi)\\)\n\n\\(\\cos(x + {\\pi \\over 2})\\)\n\\(\\cos(x + \\pi)\\)\n\\(\\sin(-x)\\)\n\n\\(\\cos(-x)\\)\n\\(\\sqrt{1 - \\sin(x)^2}\\)\n\n\n\n# Python code here\n\n\nA projectile is thrown directly downward from the top of a tall building (\\(y_i = 150\\) meters) and lands with a thud on the ground (\\(y_f = 0\\)) \\(4\\) seconds later. The position equation for the projectile is \\[y_f = y_i + v_i \\Delta t + {1\\over 2} g \\Delta t^2\\] Use sympy to solve this equation for the initial velocity. Note \\(g = 9.8\\) m/s\\(^2\\) Answer: You should find the initial speed to be \\(\\approx 18\\) m/s\n\n\n# Python code here\n\n\nA projectile is launched from the top of a building (\\(y_i = 23\\) m) with an initial speed of \\(v_i = 60\\) m/s and a launch angle of \\(\\theta_i = 32^\\circ\\). The vertical position of the projectile is given by \\[y_f = y_i + v_i \\sin \\theta_i \\Delta t - {1\\over 2}g \\Delta t^2\\]. Determine the time it takes before the projectile impacts the ground by solving this equation for \\(\\Delta t\\).\n\n\n# Python code here\n\n\nAn elastic collision is one where the total energy of the particles is the same before and after the collision. The equations that define an elastic collision where one of the objects is initially at rest are \\[{1\\over 2} m_1 (v_1)_i^2 = {1\\over 2} m_1 (v_1)_f^2 +{1\\over 2} m_2 (v_2)_f^2\\] \\[m_1 (v_1)_i = m_1 (v_1)_f  + m_2 (v_2)_f\\]. Consider a situation where particle 1 (\\(m_1 = 5 \\text{ kg}\\)) is initially moving to the right with speed \\((v_1)_i = 10 \\text{ m/s}\\) and particle 2 is stationary (\\(m_2 = 2 \\text{ kg}\\)). Solve this system of equations for\\((v_1)_f\\) and \\((v_2)_f\\). Do the results make sense? Then do the following\n\nMake \\(m_2\\) greater than \\(m_1\\). What do you expect will happen. Verify that the results match your guess.\n\nMake the mass of particle 2 much greater than particle 1. What do you expect will happen? Verify that the results match your guess.\nMake the mass of particle 1 much greater than particle 2. What do you expect will happen? Verify that the results match your guess.\n\n\n\n# Python code here\n\n\nDefine a sympy variable for \\(x\\) and then calculate the following derivatives:\n\n\\({d\\over dx} \\ln(x)\\)\n\\({d\\over dx} e^{5x^2}\\)\n\\({d\\over dx} \\cos(3 x^3)\\)\n\\({d\\over dx} (x^3 - 5x^2 + 10 x)\\)\n\n\n\n# Python code here\n\n\nImpulse is defined as the integral of the Force vs. time graph. \\[I = \\int F dt\\]. Calculate the impulse imparted to an object from \\(0&lt; t &lt; 10\\) if the force that it experiences is given by \\[F(t) = e^{-(t - 4)}\\].\n\n\n# Python code here",
    "crumbs": [
      "Intermediate Python",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>The `sympy` module</span>"
    ]
  },
  {
    "objectID": "chapters/rootFinding.html",
    "href": "chapters/rootFinding.html",
    "title": "15  Root Finding and Optimization Algorithms",
    "section": "",
    "text": "15.1 Bisection\nJupyter Notebook\nOften in science, we find ourselves wanting to do one of the following: (See figure below)\nThese skills are routinely covered in an algebra class but often the equation we encounter cannot be solved using standard algebraic techniques. Instead we have to resort to a class of numerical algorithms generally referred to as root finding or optimization algorithms. In the remainder of this chapter we will discuss various numerical methods for finding the roots of an equation. The algorithms described below can be used to perform any of the tasks mentioned above.\nThe bisection method finds the roots of a function by iteratively narrowing the interval where the zero is found until the interval becomes sufficiently small. If you want to find the location where the function equals something other than zero, you can simply rearrange the function until a zero appears on the right hand side of the equation and proceed with bisection on the new function. To begin the bisection method, the user must choose an interval wherein the function zero is guaranteed to be found. The midpoint of the interval is then found and a new, narrower interval is chosen. By repeating this process until the interval becomes sufficiently small, the algorithm eventually finds the location where the function is equal to zero. The steps to the algorithm are as follows:\nIn the code cell below, try to use the bisection method to solve the following equation. \\[\ny(x) = 5 x^2 - 3x - 2 = 0\n\\]\n# Code here",
    "crumbs": [
      "Numerical Methods",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Root Finding and Optimization Algorithms</span>"
    ]
  },
  {
    "objectID": "chapters/rootFinding.html#bisection",
    "href": "chapters/rootFinding.html#bisection",
    "title": "15  Root Finding and Optimization Algorithms",
    "section": "",
    "text": "Used with permission from: https://commons.wikimedia.org/wiki/File:Bisection_method.svg\n\n\n\n\nChoose an interval wherein the function zero is certain to be located. Call the interval \\((a,b)\\)\nCalculate the midpoint of the interval \\(c = {a+ b \\over 2}\\)\nCalculate the function value at the midpoint (\\(f(c)\\)).\nBy examining the sign of \\(f(c)\\) determine whether the interval \\((a,c)\\) or \\((c,b)\\) contains the zero of the function.\nRepeat steps 2-4 until \\(f(c)\\) is sufficiently small.",
    "crumbs": [
      "Numerical Methods",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Root Finding and Optimization Algorithms</span>"
    ]
  },
  {
    "objectID": "chapters/rootFinding.html#newtons-method",
    "href": "chapters/rootFinding.html#newtons-method",
    "title": "15  Root Finding and Optimization Algorithms",
    "section": "15.2 Newton’s Method",
    "text": "15.2 Newton’s Method\n\n\n\nUsed with permission from: https://commons.wikimedia.org/wiki/File:Newton_iteration.svg\n\n\nNewton’s method uses the slope of the function to estimate a better approximation to the function’s zero. To understand how we can use the slope to approximate the zero, first let’s write down an approximation to the slope of a function \\(f(x)\\).\n\\[\nf'(x_0) \\approx {f(x_1) - f(x_0) \\over x_1 - x_0}\n\\]\nIf the slope of the function were a constant, we could simply set \\(f(x_1) = 0\\) and solve for \\(x_1\\) and we would be done.\n\\[\nx_1 = x_0 - {f(x_0)\\over f'(x_0)}\n\\]\nIn reality, the function will not have a constant slope but this equation will still get us closer to the zero than we were originally. (see figure) By repeatedly evaluating the equation above, always using the most recent estimate as \\(x_0\\), until \\(f(x_0)\\) becomes sufficiently small, the location where the function is zero can be found. \\[\nx_{n+1} = x_n - {f(x_n)\\over f'(x_n)}\n\\]\nTo begin the algorithm, the user must choose an initial guess for the zero that isn’t very far away from the true value. An improvement on this initial guess is calculated using the equation above where \\(f'(x_n)\\) is the derivative of the function evaluated at the current guess. The algorithm continues with repeated evaluation of the equation above until \\(f(x_n)\\) evaluates to a sufficiently small number.\nBelow you will find a code example for solving the following equation:\n\\[\ny(x) = \\cos(x) = 0\n\\]\n\nimport numpy as np\n\nx = 2.3\n\nwhile abs(np.cos(x)) &gt; 1e-5:\n  x = x + np.cos(x)/np.sin(x) \n\nprint(x,np.cos(x))\n\n1.5707963256833193 1.1115773359029342e-09\n\n\nIf the function of interest has multiple zeros (like the cosine function we did above), one must give careful consideration to the initial guess. Making a poor choice can lead to the algorithm finding a different zero than what was intended.",
    "crumbs": [
      "Numerical Methods",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Root Finding and Optimization Algorithms</span>"
    ]
  },
  {
    "objectID": "chapters/rootFinding.html#fixed-point-iteration",
    "href": "chapters/rootFinding.html#fixed-point-iteration",
    "title": "15  Root Finding and Optimization Algorithms",
    "section": "15.3 Fixed-Point Iteration",
    "text": "15.3 Fixed-Point Iteration\n\n\n\nUsed with permission from: https://commons.wikimedia.org/wiki/File:Cosine_fixed_point.svg\n\n\nFixed-point iteration is another algorithm for finding function zeros. To begin, the function of interest must be rearranged to look similar to the function below. \\[\nx = \\cos(x)\n\\] As opposed to the alternate form:\n\\[\ny(x) = x - \\cos(x) = 0\n\\]\nIf the function cannot be manipulated to look like the form above, it is not a good candidate for the fixed-point iteration method. Once the equation is in this form, the user must choose an initial guess for the zero just as with the other algorithms. The algorithm then proceeds by using the initial guess to evaluate the right hand side of the equation. This process repeats with the new guess always being used to evaluate the function until \\(|x - \\cos(x)|\\) is sufficiently small. The equation given above is an example of a transcendental equation, or an equation that cannot be solved using algebraic techniques. No matter how hard you try, you’ll never come up with an expression that solves this equation.\nThe code cell below shows the fixed-point iteration algorithm used to find the zeros of the function mentioned above: \\(x = \\cos(x)\\)\n\nimport numpy as np\nx = 3\ncount = 0\nwhile abs(x - np.cos(x)) &gt; 1e-5:\n  x = np.cos(x)\n  count += 1\n\nTo find the zeros of a function that is not in the form: \\(x = f(x)\\), you must first algebraically manipulate the equation to take this form. For example, the following equation\n\\[\n2x^3 - 2 x - 5 =0\n\\]\nIs equivalent to: \\[\nx = (x+{5\\over 2})^{1\\over 3}\n\\]\nAnd the fixed-point iteration algorithm can now be used to solve for \\(x\\):\n\nimport numpy as np\nx = 3\ncount = 0\nwhile abs(x - (x+5/2)**(1/3)) &gt; 1e-8:\n    x = (x+5/2)**(1/3)\n    count += 1\n    if count &gt; 10000:\n        break",
    "crumbs": [
      "Numerical Methods",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Root Finding and Optimization Algorithms</span>"
    ]
  },
  {
    "objectID": "chapters/rootFinding.html#finding-extrema",
    "href": "chapters/rootFinding.html#finding-extrema",
    "title": "15  Root Finding and Optimization Algorithms",
    "section": "15.4 Finding Extrema",
    "text": "15.4 Finding Extrema\nAny of the methods discussed above can be used to find extrema by finding the zeros of the derivative. For example, to find the minimum of this function:\n\\[\ny(x) = 5 x^3 - 2x^2 - 8 x + 2\n\\]\nWe can find the zeros of the derivative function:\n\\[\ny'(x) = 15 x^2 - 4 x - 8\n\\]\nAnd then used fixed-point iteration, or any of the other methods discussed, to solve this equation for \\(x\\):\n\nimport numpy as np\nx = 3\ncount = 0\nwhile abs(x - np.sqrt(4/15 * x + 8/15)) &gt; 1e-8:\n    x = np.sqrt(4/15 * x + 8/15)\n    count += 1\n    if count &gt; 10000:\n      print(\"Too many iterations. Results may not be correct!\")\n      break\nprint(x)\n\n0.8757019168612669",
    "crumbs": [
      "Numerical Methods",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Root Finding and Optimization Algorithms</span>"
    ]
  },
  {
    "objectID": "chapters/rootFinding.html#exercises",
    "href": "chapters/rootFinding.html#exercises",
    "title": "15  Root Finding and Optimization Algorithms",
    "section": "15.5 Exercises",
    "text": "15.5 Exercises\n\nUse the bisection method to find the zeros of the function \\[ y(x) = 8x^3 - 15 x^2 - 4 x + 5\\] Hint: This function has three zeros; one in the region [-1,0], one in the region [0,1] and another in the region [1.5,2.5]\n\n\n# Code Here\n\n\nUse Newton’s method to find the zero for the following function (slightly different from the one in problem 1) \\[y(x) = 8x^3 - 15 x^2 - 4 x - 5\\] then use sympy to solve the equation and verify that the answer are the same.\nAnswer: You should find that the zero is located at \\(\\approx 2.2257\\)\nHint: The derivative of this function is: \\[\ny'(x) = 24 x^2 - 30 x - 4\n\\]\n\n\n# Code Here\n\n\nUse fixed-point iteration to solve the following equation\\[\\left({1\\over 2}\\right)^x = x^2\\]\n\n\n# Code Here\n\n\nUse Newton’s method to solve the following equation \\[e^x = \\cos(x)\\] Note: This function has three solutions; one in the region [-5,-4], one in the region [-2,-1] and another in the region [-1,1]. See if you can find all of them by varying your initial guess.\n\n\n# Code Here\n\n\nUse a method of your choosing to find the minimum of the function \\[y(x) = 10 x^2 \\cos(\\sqrt{x})\\] Hint: If you choose to use the bisection method, you’ll need the first derivative of this function. If you choose to use Newton’s method, you’ll need the first and second derivatives of this function. Both of these functions are given below.\n\n\\[\ny'(x) = 20 x \\cos(\\sqrt{x}) - 5 x^{3/2} \\sin(\\sqrt{x})\n\\]\n\\[\ny''(x) = 20 \\cos(\\sqrt{x}) - {5\\over 2} x \\cos(\\sqrt{x}) - {35\\over 2} \\sqrt{x} \\sin(\\sqrt{x})\n\\]\n\n# Code Here",
    "crumbs": [
      "Numerical Methods",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Root Finding and Optimization Algorithms</span>"
    ]
  },
  {
    "objectID": "chapters/extrapolation_interpolation.html",
    "href": "chapters/extrapolation_interpolation.html",
    "title": "16  Extrapolation and Interpolation",
    "section": "",
    "text": "16.1 Linear Interpolation and Extrapolation\nJupyter Notebook\nBy now we should be comfortable with representing mathematical functions on discrete grids. For example, the plot below is the location of a projectile as it flies through the air at 11 discrete points in time (red dots). There will be times when we want to find good values of a function between grid points (blue dot) or beyond the last grid point (green dot). The former is called interpolation and the latter is called extrapolation. In this chapter we will learn how to do both.\nThe simplest way to estimate function values is to assume that the function is linear in the neighborhood of the data points. Using the fact that two points define a straight line will allow us to write a linear approximation to the function. For example, suppose that we have function values \\((x_1,y_1)\\) and \\((x_2,y_2)\\), as shown in the figure below.\nIllustration of linear interpolation/extrapolation. The red dots are the known function values. The lack dot is an interpolation and the green dot is an extrapolation.\nThe formula for a straight line that passes through these two points is \\[\ny-y_1 = { (y_2-y_1) \\over (x_2-x_1) } (x-x_1)\n\\] Solving this for \\(y\\) gives \\[\ny(x) = y_1 + { (y_2-y_1) \\over (x_2-x_1) } (x-x_1)\n\\tag{16.1}\\]\nThis function provides a good approximation to the true function \\(y(x)\\) in the neighborhood of the two data points. All we have to do is evaluate it for any \\(x\\) we please. If we evaluate it in between two data points we call it interpolation and if we evaluate it somewhere beyond the last data point we call it extrapolation.",
    "crumbs": [
      "Numerical Methods",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Extrapolation and Interpolation</span>"
    ]
  },
  {
    "objectID": "chapters/extrapolation_interpolation.html#linear-interpolation-and-extrapolation",
    "href": "chapters/extrapolation_interpolation.html#linear-interpolation-and-extrapolation",
    "title": "16  Extrapolation and Interpolation",
    "section": "",
    "text": "16.1.1 Linear Interpolation\nTo linearly interpolate or extrapolate we simply evaluate the equation above at \\(x\\) values between or beyond \\(x_1\\) and \\(x_2\\).\nLet’s evaluate the function above halfway in between two grid points: \\(x = x_1 + {1\\over 2} (x_2 - x_1)\\) \\[\\begin{align}\ny(x_1 + {1\\over 2} (x_2 - x_1)) &= y_1 + { (y_2-y_1) \\over (x_2-x_1) } (x_1 + {1\\over 2} (x_2 - x_1)-x_1) \\\\\n&= y_1 + { (y_2-y_1) (x_2 - x_1) \\over 2(x_2-x_1) } \\\\\n&= y_1 + {1\\over 2} (y_2-y_1) \\\\\n\\end{align}\\]\nThat’s a pretty cool result that we can generalize to \\[\ny(x_1 + ph) = y_1 + p (y_2-y_1)\n\\tag{16.2}\\]\nwhere p is a fraction of the grid spacing.\n\n\n16.1.2 Linear Extrapolation\nNow let’s evaluate the equation above beyond the last grid point at \\(x_2 + h\\) where \\(h = (x_2 - x_1)\\) is the grid spacing.\n\\[\n\\begin{align}\ny(x_2 + (x_2 - x_1)) &= y_1 + { (y_2-y_1) \\over (x_2-x_1) } (x_2 + (x_2 - x_1)-x_1) \\\\\n&= y_1 + { (y_2-y_1) (2x_2 - 2x_1) \\over (x_2-x_1) } \\\\\n&= y_1 + 2 (y_2-y_1) \\\\\n&= 2 y_2 - y_1\n\\end{align}\n\\tag{16.3}\\]\n\n\n16.1.3 Zero Finding\nSometimes you will want to find the x value that produces \\(y(x) = 0\\). We call that finding the zero of the function. We can do this by setting \\(y =0\\) in (Equation 16.1) and solving for x: \\[\n\\begin{align}\n0 &= y_1 + {y_2 - y_1 \\over x_2 - x_1} (x - x_1)\\\\\n-y_1 & = {y_2 - y_1 \\over x_2 - x_1} (x - x_1)\\\\\n-{y_1 (x_2 - x_1)\\over y_2 - y_1} &= x - x_1\\\\\nx_1 - {y_1 (x_2 - x_1)\\over y_2 - y_1} &= x \\\\\n\\end{align}\n\\tag{16.4}\\]",
    "crumbs": [
      "Numerical Methods",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Extrapolation and Interpolation</span>"
    ]
  },
  {
    "objectID": "chapters/extrapolation_interpolation.html#quadratic-interpolation-and-extrapolation",
    "href": "chapters/extrapolation_interpolation.html#quadratic-interpolation-and-extrapolation",
    "title": "16  Extrapolation and Interpolation",
    "section": "16.2 Quadratic Interpolation and Extrapolation",
    "text": "16.2 Quadratic Interpolation and Extrapolation\nA fancier technique for finding values between and beyond grid points is to use a parabola instead of a line. It takes three data points to define a parabola, so we need to start with the function values \\((x_1,y_1)\\), \\((x_2,y_2)\\), and \\((x_3,y_3)\\), as shown in the figure below.\n\n\n\n\n\n\nIllustration of quadratic interpolation/extrapolation. The red dots are the known function values. Black dots indicate interpolations and the green dot represents extrapolation.\n\n\n\n\n\nThe general formula for a parabola is \\[\ny=a + bx + cx^2\n\\tag{16.5}\\] where the coefficients \\(a\\), \\(b,\\) and \\(c\\) need to be chosen so that the parabola passes through our three data points. To determine these constants, you set up three equations that force the parabola to match the data points, like this: \\[\\begin{align}\n    y_1 &= a + bx_1 + cx_1^2\\\\\n    y_2 &= a + bx_2 + cx_2^2\\\\\n    y_3 &= a + bx_3 + cx_3^2\\\\\n\\end{align}\\]\nWe can solve this system of equations for \\(a\\), \\(b\\), and \\(c\\) and then plug these expressions back into (Equation 16.5) to get an approximation to the function in the neighborhood of these points. When we do this (it’s long and not super pretty so I’ll save you from the gory details) we find the following useful results for interpolating: \\[\ny(x_1 + {1\\over 2} h) = {1\\over 8} (3 y_1 + 6 y_2 - y_3)\n\\tag{16.6}\\] \\[\ny(x_2 + {1\\over 2} h) = {1\\over 8} (- y_1 + 6 y_2 + 3 y_3)\n\\tag{16.7}\\] and the following useful results for extrapolating \\[\ny(x_3 +  h) =  y_1 - 3 y_2 + 3y_3\n\\tag{16.8}\\] \\[\ny(x_3 +  {1\\over 2}h) =  {1\\over 8}(3 y_1 - 10 y_2 + 15y_3)\n\\tag{16.9}\\]",
    "crumbs": [
      "Numerical Methods",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Extrapolation and Interpolation</span>"
    ]
  },
  {
    "objectID": "chapters/extrapolation_interpolation.html#an-example",
    "href": "chapters/extrapolation_interpolation.html#an-example",
    "title": "16  Extrapolation and Interpolation",
    "section": "16.3 An Example",
    "text": "16.3 An Example\nLet’s take the example of the projectile that was mentioned at the beginning of this chapter (shown below again). The red dots are the known data points and let’s try to estimate the height of the projectile between the 3rd and 4th data points in the set (the blue dot) using both linear and quadratic methods.\n\n\n\n\n\n\n\n\n\nLet’s evaluate (Equation 16.2) and (Equation 16.6) to perform this interpolation in the cell below.\n\nfrom numpy import linspace,sin,cos,pi\n\nvi = 30\nθ = 40 * pi/180\nt = linspace(0,3.5,10)\nx = vi * cos(θ) * t \ny = vi * sin(θ) * t - 4.9 * t**2\n\nyInterpLinear = y[2] + 1/2 * (y[3]-y[2])\nyInterpQuadratic = 1/8 *(3*y[2] + 6 * y[3] - y[4])\nprint(yInterpLinear)\nprint(yInterpQuadratic)\n\n13.931150961536407\n14.11641330721542\n\n\nNotice that the linear and quadratic interpolations are close to the same number but they aren’t equal; we wouldn’t really expect them to be. Deciding which interpolation method is the best choice is a case-by-case decision. For this case, I would favor the quadratic interpolation since the trajectory is more parabolic than linear. Now let’s use the extrapolation formulas to estimate the projectile’s height past the last data point. For the linear case, the second-to-last data point is playing the role of \\((x_1,y_1)\\) and the last data point is playing the role of \\((x_2,y_2)\\). For the quadratic case, the third-to-last data point is playing the role of \\((x_1,y_1)\\), the second-to-last data point is playing the role of \\((x_2,y_2)\\), and the last data point is playing the role of \\((x_3,y_3)\\). Best to use negative indices to index the data arrays for this case.\n\nfrom numpy import linspace,sin,cos,pi\n\nvi = 30\nθ = 40 * pi/180\nt = linspace(0,3.5,10)\nx = vi * cos(θ) * t \ny = vi * sin(θ) * t - 4.9 * t**2\n\nyExtrapLinear = 2* y[-1] - y[-2]\nyExtrapQuadratic = y[-3] - 3 * y[-2] + 3 * y[-1]\nprint(yExtrapLinear)\nprint(yExtrapQuadratic)\n\n2.3690482905900723\n0.8869495251579806\n\n\nNow the quadratic and the linear extrapolations differ pretty significantly. The linear version is a better value in this case due to the very course grid being used here. Finally, let’s use (Equation 16.4) to estimate the landing location for the projectile.\n\nfrom numpy import linspace,sin,cos,pi\n\nvi = 30\nθ = 40 * pi/180\nt = linspace(0,3.5,10)\nx = vi * cos(θ) * t \ny = vi * sin(θ) * t - 4.9 * t**2\n\nxRange = x[-2] - y[-2] * (x[-1] - x[-2])/(y[-1] - y[-2])\nprint(xRange)\n\n93.52444507627926",
    "crumbs": [
      "Numerical Methods",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Extrapolation and Interpolation</span>"
    ]
  },
  {
    "objectID": "chapters/extrapolation_interpolation.html#flashcards",
    "href": "chapters/extrapolation_interpolation.html#flashcards",
    "title": "16  Extrapolation and Interpolation",
    "section": "16.4 Flashcards",
    "text": "16.4 Flashcards\n\nWhat is the difference between interpolation and extrapolation?\nWhat is the equation for linear interpolation?\nWhat is the equation for linear extrapolation?\nWhat is the equation(s) for quadratic interpolation?\nWhat is the equation(s) for quadratic extrapolation?\nWhat is the equation for finding the zeros of a function?\nRecite Moses 1:39.",
    "crumbs": [
      "Numerical Methods",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Extrapolation and Interpolation</span>"
    ]
  },
  {
    "objectID": "chapters/extrapolation_interpolation.html#exercises",
    "href": "chapters/extrapolation_interpolation.html#exercises",
    "title": "16  Extrapolation and Interpolation",
    "section": "16.5 Exercises",
    "text": "16.5 Exercises\n\n\nIn the cell below, you will find the coordinates for a batted baseball flying through the air while experiencing non-negligible air drag.\n\nPlot the data.\nUse the linear zero-finding formula (Equation 16.4) to estimate the landing location of the ball.\nUse linear interpolation to calculate the height of the projectile between the 2nd and 3rd data point. Make a visual inspection of the plot to ensure that your interpolation is reasonable.\nUse quadratic interpolation to calculate the height of the projectile between the 2nd and 3rd data point. Make a visual inspection of the plot to ensure that your interpolation is reasonable.\n\n\n\nx = [0, 15.805250773081712, 29.98211261814125, 42.526480802646844, 53.54837374010167, 63.375313562732956, 72.28376367575353, 80.43524080501983, 87.9042108343639, 94.71629032437068, 100.88093230888737, 106.41217684263896] \ny = [0, 15.80525077308171, 27.532112618141245, 35.45860314481743, 39.97307745470617, 41.548109055524456, 40.52592795902555, 37.14060411207481, 31.588726752728686, 24.07513301195207, 14.825650490213738, 4.076523019892836]\n\n\nThis file contains worldwide carbon emission data from 1958 to 2017.\n\nRead the data file using any method of your choosing.\nPlot the data so you can see what it looks like.\nUse linear extrapolation to predict what carbon emissions will be in the year 2030.\n\nUse quadratic extrapolation to predict what carbon emissions will be in the year 2030.\n\nHints:\n\nRemember that our extrapolation formulas assume that the spacing between grid points is equal. Hence, to extrapolate to 2030, \\(x_1\\) must correspond to 2004 \\(x_2\\) should correspond to \\(2017\\) for the linear extrapolation.\nFor the quadratic extrapolation, \\(x_1\\) should correspond to 1991, \\(x_2\\) to 2004 and \\(x_3\\) to 2017. You could pick other years if you like as long as they are spaced out evenly.\n\n\n\n# Solution here\n\n\nThis file contains the change in average global temperature from 1958 to 2017.\n\nRead the data file using any method of your choosing.\nPlot the data so you can see what it looks like.\nUse linear extrapolation to predict what average global temperature change will be in the year 2030 if this trend continues.\n\nUse quadratic extrapolation to predict what average global temperature change will be in the year 2030 if this trend continues.\n\n\n\n# Solution here",
    "crumbs": [
      "Numerical Methods",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Extrapolation and Interpolation</span>"
    ]
  },
  {
    "objectID": "chapters/fitting.html",
    "href": "chapters/fitting.html",
    "title": "17  Curve Fitting",
    "section": "",
    "text": "17.1 Fitting to a polynomial\nJupyter Notebook .\nOften in science you will gather data as a way to explore the relationship between two physical quantities and/or to validate your theories. For example, perhaps you are interested how the amount of fertilizer applied to your tomato plants affect the final size of the fruit. Or maybe you want to know how a planet’s distance from the sun affects it’s orbital period. Investigating these kinds of questions are the very essence of science and great scientific discoveries begin with simple questions posed by curious minds. As a brief reminder, the steps to the scientific process are:\n1. Formulate a question.\n2. Form a hypothesis.\n3. Use your hypothesis to make a prediction.\n4. Test your prediction.\n5. Analyze the results and fine tune your theory.\nThe process of gathering data and analyzing it, hoping to draw conclusions and establish physical laws are what steps 4 and 5 are all about. One computational tool that will help you establish firm relationships is called curve fitting. Curve fitting is the process of finding a function that matches your data as closely as possible. Finding a best-fit function that agrees with your hypothesis can be a valuable step in verifying or proving a theory. Other useful mathematical conclusions can be drawn from it as well.\nAs a simple example consider the stopping time for a car with its brakes locked up (most modern cars are designed to prevent this). The question is: How does the stopping time depend on the car’s initial speed. If you are familiar with Newtonian mechanics at all, you might hypothesize that the acceleration of the car should not depend on the initial velocity and hence the stopping time will increase linearly with the initial speed. Furthermore, the following kinematic equation\n\\[\n\\begin{align*}\nv_f &= v_i - a \\Delta t\\\\\n0 &= v_i - \\mu_k g \\Delta t\\\\\n\\Delta t &= {v_i\\over \\mu_k g}\n\\end{align*}\n\\] would suggest that the slope of \\(\\Delta t\\) vs. \\(v_i\\) function is \\({1\\over a} = {1\\over \\mu g}\\). In other words, the theory of kinematics suggest that the acceleration should be independent of initial speed. To prove your idea, you should first measure the stopping time for cars with a variety of initial speeds (shown below).\nWe notice that the data looks linear which matches our hypothesis that the acceleration is constant.\nThe next thing to do is to find the line that passes through the data points as close as possible. When the fit function is a polynomial , we can use the polyfit function from numpy. This function takes three argument: the independent data set, the dependent data set, and the order of the polynomial\nThe polyfit function returns a list of numbers containing the function parameters for the best fit function.\nfrom matplotlib import pyplot as plt\nfrom numpy import polyfit\n\nt = [3.23,3.43,4.67,5.45,6,8.52]\nvi = [12,17,22,25,29,38]\n\nparams = polyfit(vi,t,1)\nslope = params[0]\nyint = params[1]\n\ng=9.8 #Acceleration due to gravity\nmu = 1/(slope * g)\nprint(params)\nprint(mu)\n\n[0.20971747 0.21840032]\n0.4865632640669638\nIn this case, \\(0.2097\\) is the slope of the best-fit function and \\(0.2184\\) is the y-intercept of the best fit function. Remembering our theory from above, we notice that the slope of this fit function can be used to calculate the coefficient of friction between the rubber tires and the roadway. \\[\n\\begin{align*}\nm &= {1\\over \\mu g}\\\\\n\\mu &= {1\\over m g}\n\\end{align*}\n\\] It is often useful to plot the fit function on top of the data to verify that it really matches the data.\nfrom matplotlib import pyplot as plt\nfrom numpy import polyfit,linspace\n\nt = [3.23,3.43,4.67,5.45,6,8.52]\nvi = [12,17,22,25,29,38]\n\nparams = polyfit(vi,t,1)\nvDense = linspace(8,40,100)\ntDense = params[0] * vDense + params[1]\n\nplt.plot(vi,t,'r.',ms = 16)\nplt.plot(vDense,tDense,'k',lw = 3)",
    "crumbs": [
      "Numerical Methods",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Curve Fitting</span>"
    ]
  },
  {
    "objectID": "chapters/fitting.html#fitting-to-a-polynomial",
    "href": "chapters/fitting.html#fitting-to-a-polynomial",
    "title": "17  Curve Fitting",
    "section": "",
    "text": "polyfit(x,y,order)\n\n\n\n\n\n17.1.1 Assessing the quality of the fit\nSometimes it might not be clear what type of function you should fit to. A good way to measure the quality of a fit it so sum the square of the difference between the fit function and the data. \\[\n\\sum_i (y_i - f(x_i))^2\n\\] You can make polyfit do this for you using the full = True keyword argument. Now the function will return a list of 5 things: the first is the list of fitting parameters and the second thing is the sum of the square of the errors. Fits with big values for this sum are not as good as those with lower values.\nfrom matplotlib import pyplot as plt\nfrom numpy import polyfit,linspace\n\nt = [3.23,3.43,4.67,5.45,6,8.52]\nvi = [12,17,22,25,29,38]\n\nparamsLinear = polyfit(vi,t,1,full=True)\nparamsQuadratic = polyfit(vi,t,2,full=True)\nvDense = linspace(8,40,100)\ntDenseLinear = paramsLinear[0][0] * vDense + paramsLinear[0][1]\ntDenseQuadratic = paramsQuadratic[0][0] * vDense**2 + paramsQuadratic[0][1] * vDense + paramsQuadratic[0][2]\n\nerrorLinear = paramsLinear[1][0]\nerrorQuadratic = paramsQuadratic[1][0]\n\nplt.plot(vi,t,'r.',ms = 16)\nplt.plot(vDense,tDenseLinear,'k',lw = 3)\nplt.title(f\"Error: {errorLinear:1.3f}\")\nplt.show()\n\n\nplt.plot(vi,t,'r.',ms = 16)\nplt.plot(vDense,tDenseQuadratic,'b',lw = 3)\nplt.title(f\"Error: {errorQuadratic:1.3f}\")\nplt.show()",
    "crumbs": [
      "Numerical Methods",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Curve Fitting</span>"
    ]
  },
  {
    "objectID": "chapters/fitting.html#other-functions-for-curve-fitting.",
    "href": "chapters/fitting.html#other-functions-for-curve-fitting.",
    "title": "17  Curve Fitting",
    "section": "17.2 Other functions for curve fitting.",
    "text": "17.2 Other functions for curve fitting.\nIf the fit function is a polynomial, polyfit is a great choice but there are times when the hypothesized functions is not a polynomial. In cases like this, the function scipy.optimize.curve_fit should work. As an example, let’s say that you have the following intensity vs. wavelength data.\n\n\n\n\n\n\n\n\n\nIf you suspected that the fit function looked like this \\[I(\\lambda) = a \\lambda^{-5} {1\\over \\exp{b\\over \\lambda} - 1}\\], you could find the values of a and b that made the function fit the data like this:\n\nfrom scipy.optimize import curve_fit\nfrom matplotlib import pyplot as plt\nfrom numpy import exp,log\n\ndef fit_function(wvlength,a,b):\n  return a * wvlength**-5 * 1/(exp(b/wvlength) + 1)\n\nwavelength = [0.1, 0.6, 1.1, 1.6, 2.1, 2.6, 3.1, 3.6, 4.1, 4.6, 5.1, 5.6, 6.1]\nintensity = [0, 7.43023e-7, 0.0000699768, 0.000184459, \\\n0.000211137, 0.000183716, 0.000144493, 0.000109646, 0.0000825034, \\\n0.0000623056, 0.0000474756, 0.0000365799, 0.0000285178]\n\nparams = curve_fit(fit_function,wavelength,intensity)\nprint(params)\nwDense = linspace(0.1,7,100)\niDense = params[0][0] * wDense**-5 * 1/(exp(params[0][1]/wDense) + 1)\n\nplt.plot(wavelength,intensity,'r.',ms = 13)\nplt.plot(wDense,iDense,'k',lw = 2)\n\n(array([ 1.21509047, 10.32796788]), array([[0.00225532, 0.0038109 ],\n       [0.0038109 , 0.00717859]]))\n\n\n\n\n\n\n\n\n\nNotice that the curve_fit function returns more than just the fit paramters. It also returns a \\(2\\) x \\(2\\) matrix containing the uncertainties on the fit parameters. If you want to calculate the fit error, you’ll have to do it manually, using the equation \\[\n\\sum_i (y_i - f(x_i))^2\n\\]\nfrom scipy.optimize import curve_fit\nfrom matplotlib import pyplot as plt\nfrom numpy import exp,log,diagonal,sqrt,array\n\ndef fit_function(wvlength,a,b):\n  return a * wvlength**-5 * 1/(exp(b/wvlength) + 1)\n\ndef fit_function_two(wvlength,a,b):\n  return a * wvlength**-5 * 1/(exp(b/wvlength) - 1)\n\nwavelength = array([0.1, 0.6, 1.1, 1.6, 2.1, 2.6, 3.1, 3.6, 4.1, 4.6, 5.1, 5.6, 6.1])\nintensity = array([0, 7.43023e-7, 0.0000699768, 0.000184459, 0.000211137, 0.000183716, 0.000144493, 0.000109646, 0.0000825034, 0.0000623056, 0.0000474756, 0.0000365799, 0.0000285178])\n\nparamsOne = curve_fit(fit_function,wavelength,intensity)\nparamsTwo = curve_fit(fit_function_two,wavelength,intensity)\nwDense = linspace(0.1,7,100)\niDenseOne = fit_function(wDense,paramsOne[0][0],paramsOne[0][1])\niDenseTwo = fit_function_two(wDense,paramsTwo[0][0],paramsTwo[0][1])\n\nerrorOne = sum((intensity - fit_function(wavelength,paramsOne[0][0],paramsOne[0][1]))**2 )\nerrorTwo = sum( (intensity - fit_function_two(wavelength,paramsTwo[0][0],paramsTwo[0][1]))**2 )\n\nplt.plot(wavelength,intensity,'r.',ms = 13)\nplt.plot(wDense,iDenseOne,'k',lw = 2)\nplt.title(f\"Error: {errorOne:1.3e}\")\nplt.show()\n\n\nplt.plot(wavelength,intensity,'r.',ms = 13)\nplt.plot(wDense,iDenseTwo,'k',lw = 2)\nplt.title(f\"Error: {errorTwo:1.3e}\")\nplt.show()",
    "crumbs": [
      "Numerical Methods",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Curve Fitting</span>"
    ]
  },
  {
    "objectID": "chapters/fitting.html#flashcards",
    "href": "chapters/fitting.html#flashcards",
    "title": "17  Curve Fitting",
    "section": "17.3 Flashcards",
    "text": "17.3 Flashcards\n\nWhat python function should you use to fit a polynomial to your data? Give an example of its usage.\nWhat python function should you use to fit a function that is not a polynomial to your data. Give an example of how to use this function.\nWhat is the output from the polyfit function?\nWhat is the output from the curve_fit function?\nHow can you assess the quality of a fit function?\nWhy did the Savior teach in parables?",
    "crumbs": [
      "Numerical Methods",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Curve Fitting</span>"
    ]
  },
  {
    "objectID": "chapters/fitting.html#exercises",
    "href": "chapters/fitting.html#exercises",
    "title": "17  Curve Fitting",
    "section": "17.4 Exercises",
    "text": "17.4 Exercises\n\nYou push a box with five known forces while using a motion detector to measure the cart’s acceleration. The data are shown below.\n\nPlot the data with force on the vertical axis and acceleration on the horizontal axis.\n\nFit a polynomial function of order one (linear function) to this data.\nFit a polynomial function of order two (quadratic function) to this data.\nDetermine which is the better fit.\nPlot the best-fit functions on top of the data.\nDetermine the mass of the box.\n\n\n\n\n\nForce (N)\nacceleration (m/s)\n\n\n\n\n0.25\n0.5\n\n\n0.50\n0.8\n\n\n0.75\n1.3\n\n\n1.0\n1.8\n\n\n1.25\n2.1\n\n\n\n\n# Solution Here\n\n\nYour friend wants to know the acceleration of his car and asks you to help him. You set up a motion detector that allows you to measure the position of the car at regular intervals. Your data are as follows:\n\nPlot the data with time on the horizontal axis and position on the vertical.\nFit a polynomial function of order one (linear function) to this data.\nFit a polynomial function of order two (quadratic function) to this data.\nDetermine which is the better fit.\nPlot the best-fit functions on top of the data.\nCalculate the acceleration of the car using the best fit.\n\n\n\n\n\nTime (s)\nPosition (m)\n\n\n\n\n0.0\n0.256\n\n\n0.1\n0.249\n\n\n0.2\n0.195\n\n\n0.3\n0.514\n\n\n0.4\n0.538\n\n\n0.5\n0.785\n\n\n0.6\n1.11\n\n\n0.7\n1.31\n\n\n0.8\n1.81\n\n\n0.9\n2.32\n\n\n1.0\n2.74\n\n\n\n\n# Solution Here\n\n\nThe takeoff speed for a passenger airline jet is \\(80\\) m/s. Velocity data measured during takeoff are given in the table below.\n\nPlot the data and fit a linear function to the data set. Do you find good evidence that the acceleration of the airplane is constant.\nPlot the best-fit function on top of the data.\nAt what time will the airplane achieve liftoff?\n\n\n\n\n\nTime (s)\nVelocity (m/s)\n\n\n\n\n0\n0\n\n\n10\n23\n\n\n20\n46\n\n\n30\n69\n\n\n\n\n# Solution Here\n\n\nIn PH123 you’ll learn about ideal gases and the processes associated with them. One such process is called an adiabatic process. The relationship between the temperature and the volume in an adiabatic process is \\[\nT(V) = {C\\over V^{\\gamma -1}}\n\\]\n\nFor your experiment you compress a cylinder of gas four different times and measure the temperature of the gas.\n\n\n\nVolume (m\\(^3\\))\nTemperature (\\(^\\circ\\) C)\n\n\n\n\n0.481\n35\n\n\n0.412\n68\n\n\n0.347\n110\n\n\n0.299\n150\n\n\n\n\nPlot temperature vs. volume. Make sure the volumes are in cubic meters and the temperatures are in Kelvins: \\[T_K = T_C + 273\\].\nFit the function mentioned above to this data.\nPlot the best-fit function on top of the data.\nCalculate gamma. The value of gamma is an indication of what type of gas is present in the cylinder. \\(\\gamma = 1.4\\) for a diatomic gas and \\(\\gamma = 1.67\\) for a monatomic gas.\n\n\n# Solution Here",
    "crumbs": [
      "Numerical Methods",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Curve Fitting</span>"
    ]
  },
  {
    "objectID": "chapters/numericalCalculus.html",
    "href": "chapters/numericalCalculus.html",
    "title": "18  Numerical Calculus",
    "section": "",
    "text": "18.1 Numerical Derivatives\nJupyter Notebook\nIf you have taken a calculus class, you probably know what a derivative and anti-derivative are and how to calculate them. (If you haven’t taken calculus, you will understand these concepts soon.) The techniques that you learned in calculus class are called analytical methods, which means that the derivative (or anti-derivative) are calculated using pencil, paper, and some mathematical rules to guide you. In this chapter, we will explore how to find the derivative (or anti-derivative) of a discrete set of data rather than a continuous function.\nLet’s start with a simple data set that gives the position of an object dropped from a tall building at various times.\nThere are three possible ways that we could find the slope at a single point: the forward difference, the backward difference, and the center difference. \\[\nf'(x) = {f(x + h) - f(x - h)\\over 2h} \\text{ (center-difference)}\n\\] \\[\nf'(x) = {f(x + h) - f(x )\\over h} \\text{ (forward-difference)}\n\\] \\[\nf'(x) = {f(x) - f(x - h)\\over h} \\text{ (backward-difference)}\n\\] We illustrate them in the figure below.\nFigure 1: Illustration of the forward difference derivative (blue solid line), the backward difference (blue dashed line) and the center difference (red dashed line)\nClearly, the centered-difference is the best way to calculate slopes and it is the method you should always strive for. Let’s see how to use the center-difference equation in python to calculate the slope at every point in a data set.\nfrom numpy import linspace,array\nfrom matplotlib import pyplot as plt\n\nt = array([0.0, 0.21052631578947367, 0.42105263157894735, 0.631578947368421, 0.8421052631578947, 1.0526315789473684, 1.263157894736842, 1.4736842105263157, 1.6842105263157894, 1.894736842105263, 2.1052631578947367, 2.3157894736842106, 2.526315789473684, 2.7368421052631575, 2.9473684210526314, 3.1578947368421053, 3.3684210526315788, 3.578947368421052, 3.789473684210526, 4.0])\ny = array([100.0, 99.78282548476454, 99.13130193905818, 98.04542936288088, 96.52520775623269, 94.57063711911357, 92.18171745152354, 89.35844875346261, 86.10083102493076, 82.40886426592797, 78.2825484764543, 73.72188365650969, 68.72686980609419, 63.29750692520776, 57.43379501385042, 51.13573407202215, 44.403324099722994, 37.23656509695292, 29.63545706371191, 21.599999999999994])\n\ndt = t[1] - t[0]\nyprime = (y[2:] - y[:-2])/(2 * dt)\n\nplt.plot(t,y,'r--.',ms = 13)\nplt.plot(t[1:-1],yprime,'b--.',ms = 13)\nplt.xlabel(\"time (s)\")\nplt.ylabel(\"height (m)\")\nplt.show()\nPay special attention to this line: yprime = (y[2:] - y[:-2])/(2 * dt). By slicing the array of function values carefully, I can calculate the center-difference derivative for all points in the data set simultaneously. (see figure below) Also note that when using the center difference formula, you are unable to calculate the slope at the endpoints of the dataset. Hence, your array of slope values is two shorter than your original list. When I plot the derivative, the time array has to be trimmed to get the slopes to match up correctly with times.\nHere is another example for a dataset that exhibits a few more features. Take a second to verify that the blue function is giving the slope of the red function.\nfrom numpy import array\n\nt = array([0.0, 0.10204081632653061, 0.20408163265306123, 0.30612244897959184, 0.40816326530612246, 0.5102040816326531, 0.6122448979591837, 0.7142857142857143, 0.8163265306122449, 0.9183673469387755, 1.0204081632653061, 1.1224489795918369, 1.2244897959183674, 1.3265306122448979, 1.4285714285714286, 1.5306122448979593, 1.6326530612244898, 1.7346938775510203, 1.836734693877551, 1.9387755102040818, 2.0408163265306123, 2.142857142857143, 2.2448979591836737, 2.3469387755102042, 2.4489795918367347, 2.5510204081632653, 2.6530612244897958, 2.7551020408163267, 2.857142857142857, 2.9591836734693877, 3.0612244897959187, 3.163265306122449, 3.2653061224489797, 3.36734693877551, 3.4693877551020407, 3.5714285714285716, 3.673469387755102, 3.7755102040816326, 3.8775510204081636, 3.979591836734694, 4.081632653061225, 4.183673469387755, 4.285714285714286, 4.387755102040816, 4.4897959183673475, 4.591836734693878, 4.6938775510204085, 4.795918367346939, 4.8979591836734695, 5.0, 5.1020408163265305, 5.204081632653061, 5.3061224489795915, 5.408163265306123, 5.510204081632653, 5.612244897959184, 5.714285714285714, 5.816326530612245, 5.918367346938775, 6.020408163265306, 6.122448979591837, 6.224489795918368, 6.326530612244898, 6.428571428571429, 6.530612244897959, 6.63265306122449, 6.73469387755102, 6.836734693877551, 6.938775510204081, 7.040816326530613, 7.142857142857143, 7.244897959183674, 7.346938775510204, 7.448979591836735, 7.551020408163265, 7.653061224489796, 7.755102040816327, 7.857142857142858, 7.959183673469388, 8.061224489795919, 8.16326530612245, 8.26530612244898, 8.36734693877551, 8.46938775510204, 8.571428571428571, 8.673469387755102, 8.775510204081632, 8.877551020408163, 8.979591836734695, 9.081632653061225, 9.183673469387756, 9.285714285714286, 9.387755102040817, 9.489795918367347, 9.591836734693878, 9.693877551020408, 9.795918367346939, 9.89795918367347, 10.0])\n\ny = array([1.0, 0.9867106049449835, 0.9633896110036303, 0.930441653845362, 0.8883647907109408, 0.8377438153135915, 0.7792427802562372, 0.7135968174516216, 0.641603352856869, 0.5641128165642914, 0.4820189528946211, 0.3962488375981065, 0.30775271057607917, 0.217493732695753, 0.12643777430107145, 0.03554334095074269, -0.05424826121944644, -0.1420224222596137, -0.22690029414347004, -0.30804733831471925, -0.38468127466905855, -0.4560793591162092, -0.5215849250188013, -0.5806131324972382, -0.6326558787228784, -0.6772858317939752, -0.7141595604960038, -0.743019742085619, -0.7636964401012755, -0.7761074539906521, -0.7802577519550382, -0.7762380077468505, -0.7642222711259269, -0.7444648101959878, -0.7172961718235661, -0.6831185137135822, -0.6424002684118669, -0.5956702054667365, -0.5435109631591742, -0.4865521255631921, -0.42546292419273285, -0.3609446461065957, -0.29372283206542116, -0.2245393491613234, -0.15414442227722988, -0.083288707794463, -0.012715491177467673, 0.05684691254372852, 0.12469247975946875, 0.19014444921827992, 0.2525618761933174, 0.31134570856282195, 0.36594432944772914, 0.4158585174857275, 0.4606457826610142, 0.49992404277520236, 0.5333746130575407, 0.5607444889909092, 0.5818479100925077, 0.5965672000538682, 0.6048528862341104, 0.60672310893566, 0.6022623380982411, 0.5916194219536842, 0.5750049987241208, 0.5526883085574614, 0.5249934485201562, 0.49229511855756375, 0.45501391084259973, 0.4136111988262666, 0.3685836855487481, 0.32045767334377057, 0.26978311895604673, 0.21712753928331918, 0.16306983344972584, 0.10819408672204209, 0.0530834209080176, -0.0016860456534446109, -0.05555106756061642, -0.10796691308417367, -0.15841272129543982, -0.20639652454758026, -0.2514598895714763, -0.29318213516550146, -0.33118408953590006, -0.36513135572337047, -0.3947370591710421, -0.41976405728705063, -0.4400265967682593, -0.45539141041706666, -0.4657782511379014, -0.4711598666822405, -0.47156142446092897, -0.46705940130261336, -0.45777995835259105, -0.44389682632607497, -0.4256287310064338, -0.4032363931693947, -0.3770191409801755])\n\nfrom matplotlib import pyplot as plt\n\ndt = t[1] - t[0]\nyprime = (y[2:] - y[:-2])/(2 * dt)\n\nplt.plot(t,y,'r',label = 'y(t)')\nplt.plot(t[1:-1],yprime,'b',label = \"y'(t)\")\nplt.xlabel(\"time (s)\")\nplt.ylabel(\"height (m)\")\nplt.legend()",
    "crumbs": [
      "Numerical Methods",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Numerical Calculus</span>"
    ]
  },
  {
    "objectID": "chapters/numericalCalculus.html#numerical-derivatives",
    "href": "chapters/numericalCalculus.html#numerical-derivatives",
    "title": "18  Numerical Calculus",
    "section": "",
    "text": "Illustration of center-difference derivative on a discrete grid. Using array slicing the slope can be calculated at all points simultaneously.\n\n\n\n\n\n18.1.1 Numerical second derivatives\nWe can derive a formula for a second derivative as follows:\n\\[\n\\begin{align*}\nf''(x) &= {f'(x + {h\\over 2}) - f'(x - {h\\over 2}) \\over  h}\\\\\n&= {1\\over h} \\left({f(x + h) - f(x)\\over  h} - {f(x)  - f(x -  h) \\over  h} \\right)\\\\\n&= {1\\over h} \\left({f(x +  h) - 2 f(x) + f(x -  h) \\over  h} - {f(x)  - f'(x -  h) \\over  h} \\right)\\\\\n&= {f(x +  h) - 2 f(x) + f(x -  h) \\over  h^2} \\\\\n\\end{align*}\n\\]\nAnd here is an example of doing this in python.\n\nfrom numpy import array\n\nt = array([0.0, 0.10204081632653061, 0.20408163265306123, 0.30612244897959184, 0.40816326530612246, 0.5102040816326531, 0.6122448979591837, 0.7142857142857143, 0.8163265306122449, 0.9183673469387755, 1.0204081632653061, 1.1224489795918369, 1.2244897959183674, 1.3265306122448979, 1.4285714285714286, 1.5306122448979593, 1.6326530612244898, 1.7346938775510203, 1.836734693877551, 1.9387755102040818, 2.0408163265306123, 2.142857142857143, 2.2448979591836737, 2.3469387755102042, 2.4489795918367347, 2.5510204081632653, 2.6530612244897958, 2.7551020408163267, 2.857142857142857, 2.9591836734693877, 3.0612244897959187, 3.163265306122449, 3.2653061224489797, 3.36734693877551, 3.4693877551020407, 3.5714285714285716, 3.673469387755102, 3.7755102040816326, 3.8775510204081636, 3.979591836734694, 4.081632653061225, 4.183673469387755, 4.285714285714286, 4.387755102040816, 4.4897959183673475, 4.591836734693878, 4.6938775510204085, 4.795918367346939, 4.8979591836734695, 5.0, 5.1020408163265305, 5.204081632653061, 5.3061224489795915, 5.408163265306123, 5.510204081632653, 5.612244897959184, 5.714285714285714, 5.816326530612245, 5.918367346938775, 6.020408163265306, 6.122448979591837, 6.224489795918368, 6.326530612244898, 6.428571428571429, 6.530612244897959, 6.63265306122449, 6.73469387755102, 6.836734693877551, 6.938775510204081, 7.040816326530613, 7.142857142857143, 7.244897959183674, 7.346938775510204, 7.448979591836735, 7.551020408163265, 7.653061224489796, 7.755102040816327, 7.857142857142858, 7.959183673469388, 8.061224489795919, 8.16326530612245, 8.26530612244898, 8.36734693877551, 8.46938775510204, 8.571428571428571, 8.673469387755102, 8.775510204081632, 8.877551020408163, 8.979591836734695, 9.081632653061225, 9.183673469387756, 9.285714285714286, 9.387755102040817, 9.489795918367347, 9.591836734693878, 9.693877551020408, 9.795918367346939, 9.89795918367347, 10.0])\n\ny = array([1.0, 0.9867106049449835, 0.9633896110036303, 0.930441653845362, 0.8883647907109408, 0.8377438153135915, 0.7792427802562372, 0.7135968174516216, 0.641603352856869, 0.5641128165642914, 0.4820189528946211, 0.3962488375981065, 0.30775271057607917, 0.217493732695753, 0.12643777430107145, 0.03554334095074269, -0.05424826121944644, -0.1420224222596137, -0.22690029414347004, -0.30804733831471925, -0.38468127466905855, -0.4560793591162092, -0.5215849250188013, -0.5806131324972382, -0.6326558787228784, -0.6772858317939752, -0.7141595604960038, -0.743019742085619, -0.7636964401012755, -0.7761074539906521, -0.7802577519550382, -0.7762380077468505, -0.7642222711259269, -0.7444648101959878, -0.7172961718235661, -0.6831185137135822, -0.6424002684118669, -0.5956702054667365, -0.5435109631591742, -0.4865521255631921, -0.42546292419273285, -0.3609446461065957, -0.29372283206542116, -0.2245393491613234, -0.15414442227722988, -0.083288707794463, -0.012715491177467673, 0.05684691254372852, 0.12469247975946875, 0.19014444921827992, 0.2525618761933174, 0.31134570856282195, 0.36594432944772914, 0.4158585174857275, 0.4606457826610142, 0.49992404277520236, 0.5333746130575407, 0.5607444889909092, 0.5818479100925077, 0.5965672000538682, 0.6048528862341104, 0.60672310893566, 0.6022623380982411, 0.5916194219536842, 0.5750049987241208, 0.5526883085574614, 0.5249934485201562, 0.49229511855756375, 0.45501391084259973, 0.4136111988262666, 0.3685836855487481, 0.32045767334377057, 0.26978311895604673, 0.21712753928331918, 0.16306983344972584, 0.10819408672204209, 0.0530834209080176, -0.0016860456534446109, -0.05555106756061642, -0.10796691308417367, -0.15841272129543982, -0.20639652454758026, -0.2514598895714763, -0.29318213516550146, -0.33118408953590006, -0.36513135572337047, -0.3947370591710421, -0.41976405728705063, -0.4400265967682593, -0.45539141041706666, -0.4657782511379014, -0.4711598666822405, -0.47156142446092897, -0.46705940130261336, -0.45777995835259105, -0.44389682632607497, -0.4256287310064338, -0.4032363931693947, -0.3770191409801755])\n\nfrom matplotlib import pyplot as plt\n\ndt = t[1] - t[0]\nyprime = (y[2:] - y[:-2])/(2 * dt)\nyprimeprime = (y[2:] - 2 * y[1:-1] + y[:-2])/dt**2\nplt.plot(t,y,'r--.',label = 'y(t)')\nplt.plot(t[1:-1],yprime,'b--.',label = \"y'(t)\")\nplt.plot(t[1:-1],yprimeprime,'m--.',label = \"y''(t)\")\nplt.xlabel(\"time (s)\")\nplt.ylabel(\"height (m)\")\nplt.legend()",
    "crumbs": [
      "Numerical Methods",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Numerical Calculus</span>"
    ]
  },
  {
    "objectID": "chapters/numericalCalculus.html#integration",
    "href": "chapters/numericalCalculus.html#integration",
    "title": "18  Numerical Calculus",
    "section": "18.2 Integration",
    "text": "18.2 Integration\nIn calculus you learn rules for finding anti-derivatives, or undoing the derivative. In this section we will learn how to find anti-derivatives of functions that are represented by discrete sets of data. The mathematical notation for an anti-derivative (also called an integral) is\n\\[\n\\int y(x) dx\n\\]\nFor example, the anti-derivative of \\(x^2\\) is \\({x^3 \\over 3}\\) or\n\\[\n\\int x^2 dx = {x^3\\over 3} + C\n\\]\nAny constant \\(C\\) can be added to the anti-derivative and the equality still holds. You can see this by taking the derivative of the right hand side and noticing that the derivative of the constant is zero.\n\n18.2.1 Definite Integrals\nAn alternate interpretation of the integral is that of the area created by the function and the horizontal axis. When thinking of an anti-derivative like this, we should put bounds on the integral to specify where to start counting the area and when to stop. These bounds show up as a subscript and superscript to the integral symbol (\\(\\int\\)). Here is a definite integral of the function \\(\\sin(x)\\) from \\(0 &lt; x &lt; \\pi\\).\n\\[\n\\int_0^\\pi \\sin(x) dx\n\\]\nTo perform a definite integral, the anti-derivative should first be evaluated at the upper and lower bounds. Then subtract these two numbers to obtain the final result.\n\\[\n\\int_a^b f'(x) dx = f(b) - f(a)\n\\]\nThe definite integral of \\(\\sin(x)\\) from \\(0 &lt; x &lt; \\pi\\) would be.\n\\[\n\\int_0^\\pi \\sin(x) dx = -\\cos(x)|_0^\\pi = -\\cos(\\pi) -(-\\cos(0)) = 2\n\\]\nAnd corresponds to the area shown in the figure below.\n\n\n(np.float64(-0.3141592653589793),\n np.float64(6.5973445725385655),\n np.float64(-1.0998615404412626),\n np.float64(1.0998615404412626))\n\n\n\n\n\n\n\n\n\nWhen working with discrete data, the integral of the underlying function can be approximated as a sum of the area of many rectangles. This can be written mathematically as \\[\n\\begin{align*}\n\\int f(x) dx &\\approx  dx  f(x_1) + dx f(x_2) + \\dots\\\\\n&= dx \\sum_i f(x_i)\n\\end{align*}\n\\]\nThe smaller the width of the rectangles, the better the approximation.\n\n\n(np.float64(-0.6440264939859076),\n np.float64(6.613052535806514),\n np.float64(-1.0998615404412626),\n np.float64(1.0998615404412626))\n\n\n\n\n\n\n\n\n\nLet’s use the rectangle rule to approximate the integral of a simple function and compare to the true answer to check for accuracy. \\[\n\\int_0^\\pi \\sin(x) dx\n\\]\n\nfrom numpy import linspace,sin,cos,pi\nx,dx = linspace(0,pi,100,retstep=True)\ny = sin(x)\n\nintegral = dx * sum(y)\nprint(integral)\nprint(-(cos(pi) - cos(0)))\n\n1.9998321638939924\n2.0\n\n\nNotice that I used the retstep = True keyword argument when calling linspace to retrieve the width of the rectangles.\n\n\n18.2.2 Trapezoid Integration\nWe can improve upon the rectangle approximation to the integral by replacing the rectangles with trapezoids. You may recall that the area of a trapezoid is\n\\[\nA = {\\Delta x \\over 2} \\left( f(a) + f(b)\\right)\n\\]\n\n\n(np.float64(-0.15707963267948966),\n np.float64(3.2986722862692828),\n np.float64(-0.049993706383693756),\n np.float64(1.049867834057569))\n\n\n\n\n\n\n\n\n\nIf we add up the area of all of these trapezoids we get\n\\[\n\\begin{align*}\n\\int_a^b f(x) dx &= {\\Delta x \\over 2} \\left( f(x_0) + f(x_1)\\right) + {\\Delta x \\over 2} \\left( f(x_1) + f(x_2)\\right) + {\\Delta x \\over 2} \\left( f(x_2) + f(x_3)\\right) \\dots \\\\\n&= {\\Delta x \\over 2} \\left( f(x_0) + 2 f(x_1) + 2 f(x_2) + \\dots 2 f(x_{n-1}) + f(x_n)\\right)\n\\end{align*}\n\\]\nLet’s use the trapezoid rule to integrate the function \\[\ny(x) = \\exp{-0.05 x} \\cos(x)\n\\]\nand see how it compares to the rectangle rule. We’ll also use sympy to see that the exact value is for comparison.\n\nfrom numpy import linspace,exp,cos,pi\nimport sympy as sp\nx,dx = linspace(0,pi,6,retstep=True)\ny = exp(-0.05 * x) * cos(x)\n\nintegralrectangle = dx * sum(y)\nintegraltrapezoid = dx /2 * (2 * sum(y[1:-1]) + y[0] + y[-1])\n\nxvar = sp.Symbol(\"x\")\nexpression = sp.exp(-0.05 * xvar) * sp.cos(xvar)\nexact = sp.integrate(expression,(xvar,0,sp.pi))\n\nprint(integralrectangle)\nprint(integraltrapezoid)\ndisplay(sp.N(exact))\n\n0.14127987124712144\n0.0956124235314592\n\n\n\\(\\displaystyle 0.0925005485861962\\)\n\n\nNotice that even with only 6 data points, using trapezoids did quite a bit better than using rectangles. There are other more sophisticated methods for integrating a function that you will learn about in other classes.\n\n\n18.2.3 Indefinite Integrals\nThe result of a definite integral is a single number; the area under the curve from the lower bound to the upper bound. The result of an indefinite integral is a function which gives the area under the curve starting at \\(x = 0\\) and ending at any value of \\(x\\) of your choosing. To perform an indefinite integral using a discrete data set, simply perform a definite integral from \\(x = 0\\) to every other x value in your range separately, saving each value in a list for later use. Let’s demonstrate this in the cell below.\n\nfrom numpy import linspace, sin,cos,pi\nfrom matplotlib import pyplot as plt\n\nx,dx = linspace(0,2 * pi,100,retstep = True)\ny = cos(x)\n\nintegral = [dx * sum(y[:n]) for n in range(len(x))]\nplt.plot(x,y,'r')\nplt.plot(x,integral,'b--.')\nplt.show()\n\n\n\n\n\n\n\n\nThe value of the blue curve gives the area under the red curve from \\(x = 0\\) to any value of x you want to consider. You should verify that this is true for a few points.\n\nfrom numpy import linspace, sin,cos,pi\nfrom matplotlib import pyplot as plt\n\nx,dx = linspace(0,2 * pi,100,retstep = True)\ny = sin(x)\n\nintegral = [dx * sum(y[:n]) for n in range(len(x))]\nplt.plot(x,y,'r')\nplt.plot(x,integral,'b--.')\nplt.show()",
    "crumbs": [
      "Numerical Methods",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Numerical Calculus</span>"
    ]
  },
  {
    "objectID": "chapters/numericalCalculus.html#flashcards",
    "href": "chapters/numericalCalculus.html#flashcards",
    "title": "18  Numerical Calculus",
    "section": "18.3 Flashcards",
    "text": "18.3 Flashcards\n\nWrite down the equation for the center difference first derivative.\nWrite down the equation for the center difference second derivative.\nWrite down the equation for the integral approximation using rectangles.\nWrite down the equation for the integral approximation using trapezoids.",
    "crumbs": [
      "Numerical Methods",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Numerical Calculus</span>"
    ]
  },
  {
    "objectID": "chapters/numericalCalculus.html#exercises",
    "href": "chapters/numericalCalculus.html#exercises",
    "title": "18  Numerical Calculus",
    "section": "18.4 Exercises",
    "text": "18.4 Exercises\n\nFollow the steps below to calculate the first and second derivative of the following function \\[y(x) = {\\sin(x) \\over x}\\]\n\nGenerate a discrete grid of 20 equally-spaced points from \\(0&lt; x &lt; 10\\).\nGenerate an array of function values by evaluating the function above on the grid of points from step 1.\nUse the center-difference equation to generate an array of slope values.\nUse the center-difference second derivative equation to generate an array of second derivatives.\nPlot all three functions on the same axes and verify that they look right.\n\n\n\n# Solution Here\n\n\nFollow the steps below to calculate the definite and indefinite integral of the following function \\[F(t) = cos(t) * e^{-t \\over 2} \\] from \\(0&lt;t&lt;10\\) seconds.\n\nGenerate a discrete grid of 10 equally-spaced points from \\(0&lt; t &lt; 10\\).\nGenerate an array of function values by evaluating the function above on the grid of points from step 1.\nUsing the rectangle equation, approximate the integral.\nUsing the trapezoid equation, approximate the integral.\nUsing sympy evaluate the integral and compare to your approximations.\nModify the number of grid points until your approximations are within \\(0.001\\) of the true result.\n\n\n\n# Solution Here\n\n\nThis file contains data from Felix Baumgartner’s 2012 jump from an altitude of \\(39\\) km above the surface of the earth. Complete the following:\n\nRead the data file into a pandas dataframe.\nPlot altitude vs. time.\nUsing the center-difference formula, calculate the derivative of this data. What quantity do you get when you take a derivative of position vs. time data?\nCalculate the second derivative of this data. What quantity do you get when you take a second derivative of position vs. time data?\nPlot the derivatives and inspect them to verify that they make sense.\nThe original data set has a column that contains the Felix’s airspeed (in km/hour). Plot this column vs. time and compare to the derivative you performed to see if they match (or are close).\n\n\n\n# Solution Here",
    "crumbs": [
      "Numerical Methods",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Numerical Calculus</span>"
    ]
  },
  {
    "objectID": "chapters/eulers.html",
    "href": "chapters/eulers.html",
    "title": "19  Euler’s Method",
    "section": "",
    "text": "19.1 Air Drag - One dimensional\nJupyter Notebook\nIn PH121 you will learn(or have already learned) how the position, velocity, and acceleration of an object are related to one another. One of the more challenging cases occurs when the acceleration of the object is not constant. The acceleration could vary with position, velocity, or time. In these cases, you may not be able to use calculus to find the position and/or velocity of an object. Instead, you’ll have to repeatedly use these equations \\[\nv_{i+1} = v_i  + a_i \\Delta t\n\\] \\[\nx_{i+1} = x_i + v_i \\Delta t\n\\]\nwith a very small \\(\\Delta t\\). If \\(\\Delta t\\) is sufficiently small, assuming that the acceleration is constant is a reasonable approximation. Below we will explain the physics of a few important situations where Euler’s method is a good choice to solve the problem.\nThe drag force (due to air resistance) is given by:\n\\[\nF_\\text{drag} = {1\\over 2} C \\cdot \\rho_\\mathrm{air} \\cdot A \\cdot v^2\n\\]\nwhere \\(C\\) is the drag coefficient, \\(\\rho_\\mathrm{air}\\) is the density of air, and \\(A\\) is the cross-sectional area of the projectile. For an object that is dropped (or thrown) vertically, the acceleration is given by the following\n\\[\n\\begin{align*}\n-m g - {1\\over 2} \\rho A C v^2 &= m a\\\\\n-g - {1\\over 2 m} \\rho A C v^2 &= a\\\\\n\\end{align*}\n\\]\nand we can use the standard kinematic equations with a very small \\(\\Delta t\\) to determine the position and velocity at future times. \\[\ny_\\mathrm{n+1} = y_n + v_n  \\Delta t\n\\] \\[\nv_{n+1} = v_n - a \\Delta t\n\\]\nIn the code cell below you will find an example of Euler’s method for a small styrofoam ball that is dropped from the top of a \\(100\\)-m-tall building. The styrofoam ball has a mass \\(m = 100\\) g, drag constant \\(C = 0.02\\), radius \\(r = 0.25\\) m and the density of air is \\(1.29\\) kg/m\\(^3\\).\nfrom matplotlib import pyplot as plt\nfrom numpy import pi\n\ndt = 0.01\nv = [0]\ny =[100]\nt = [0]\ng = 9.8\nC = 0.02\nrho = 1.29\nr = .25\nA = pi * r**2\nm = .1\n\nwhile y[-1] &gt; 0:\n  a = 1/2/m * rho * A * C * v[-1]**2 - g\n  v.append(v[-1]+ a * dt)\n  y.append(y[-1] + v[-1] * dt)\n  t.append(t[-1] + dt)\n    \nfig = plt.figure()\nax1 = fig.add_subplot(2,1,1)\nax2 = fig.add_subplot(2,1,2)\nax1.plot(t,y,'r.')\nax2.plot(t,v,'r.')\nplt.show()",
    "crumbs": [
      "Numerical Methods",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Euler's Method</span>"
    ]
  },
  {
    "objectID": "chapters/eulers.html#air-drag-two-dimensional",
    "href": "chapters/eulers.html#air-drag-two-dimensional",
    "title": "19  Euler’s Method",
    "section": "19.2 Air Drag (two dimensional)",
    "text": "19.2 Air Drag (two dimensional)\nFor two dimensional motion, we need to decompose the drag force into x and y components.\n\\[\n\\begin{align*}\nF_x &= F_D \\cos(\\theta)\\\\\n&= F_D {v_x\\over v}\\\\\n&= -{1\\over 2} \\rho A C v^2 {v_x\\over v}\\\\\n&= -{1\\over 2} \\rho A C v v_x\\\\\n\\end{align*}\n\\]\nA similar expression for the y component of the drag force is \\[\nF_y = -{1\\over 2} \\rho A C v v_y\\\\\n\\]",
    "crumbs": [
      "Numerical Methods",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Euler's Method</span>"
    ]
  },
  {
    "objectID": "chapters/eulers.html#rocket-propulsion",
    "href": "chapters/eulers.html#rocket-propulsion",
    "title": "19  Euler’s Method",
    "section": "19.3 Rocket Propulsion",
    "text": "19.3 Rocket Propulsion\nThe liftoff of a rocket provides some interesting physics to consider. The mass of the rocket + fuel is decreasing as the fuel burns off. Hence, the acceleration of the rocket is very much not a constant. However, in your code you don’t want to decrease the mass of the rocket-fuel system forever or the mass will become lower than the mass of the rocket alone, and eventually will go negative (yikes!). Watch out for that.\nThe force of the thrust on the rocket is given by: \\[ F = v_e {dM\\over dt}\\] where \\({dM\\over dt}\\) is the rate of mass loss due to the fuel burning and \\(v_e\\) is the speed with which the exhaust exits the rocket. Can you do a unit analysis on this function and convince yourself that it has the right units?\nThe force of air drag on the rocket is quadratic. In other words, it is given by: \\[F_\\text{drag} = {1\\over 2} \\rho A C v^2\\] where \\(\\rho\\) is the density of air, \\(A\\) is the cross-sectional area of the rocket, and \\(C\\) is the drag coefficient. Also notice that the direction of the drag force changes at the peak of the trajectory. For the upward journey, the drag force points downward, and for the downward part of the journey, the drag force points upward. To handle this efficiently when writing your code, I recommend calculating this force like this: \\[ F_D = {1\\over 2} \\rho A C v |v|\\] so that the sign of this calculation changes naturally at the peak of the trajectory.\nSince the rocket may travel a considerable distance into the atmosphere, we must take into account that the density of the atmosphere varies with altitude according to: \\[\\rho(h) = (1.09 - {0.0065 h\\over 300})^{2.5}\\]",
    "crumbs": [
      "Numerical Methods",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Euler's Method</span>"
    ]
  },
  {
    "objectID": "chapters/eulers.html#exercises",
    "href": "chapters/eulers.html#exercises",
    "title": "19  Euler’s Method",
    "section": "19.4 Exercises",
    "text": "19.4 Exercises\n\nIn 2012, Felix Baumgartner successfully jumped from a height of \\(39.0\\) km above the surface of the Earth. Consider the complexities that this real-world examples provides:\n\nFor this problem, we must include the force of air drag to get the calculation right. The force of air drag is given by: \\(F_d = {1\\over 2} \\rho A C v^2\\), with \\(C = 0.58\\), \\(A = 1.04\\) m\\(^2\\)\nBecause Felix jumped from such a high altitude, the density of the atmosphere changed as he fell. The density of the atmosphere changes with altitude according to the following equation: \\(\\rho = 1.2 \\text{ (kg/m}^3\\text{)} e^{-h\\over 1 \\times 10^4}\\)\nThe acceleration due to gravity, g, is not constant over the flight, but changes with altitude according to the following equation: \\(g = {9.8 \\text{ m/s}^2 \\over (1 + {h\\over R_E})^2}\\), where \\(R_E = 6.37 \\times 10^6\\) m\nAssume that Felix’s mass is \\(m = 73\\) kg and that he starts from rest.\n\nUse Euler’s method to answer the following questions:\n\nHow long does it take Felix to reach Earth’s surface. Give your answer to the nearest second. (Note: We are not considering a parachute in this case.. ouch.) Answer: You should find that his flight took \\(\\approx 400\\) s.\nCompare the real fall time you just calculated to the dragless, constant-g (\\(9.8\\)m/s\\(^2\\)) fall time. Answer: You should find that the fall time is \\(\\approx 90\\) s. (big difference eh.)\n\nA rocket has a total mass \\(M_i = 180\\) kg, including \\(130\\) kg of fuel and oxidizer. The rocket is launched from the ground, starting from rest at time \\(t = 0\\) s, and puts out exhaust with a relative speed of \\(v_e = 1500\\) m/s at a constant burn rate of \\({dM \\over dt} = 2.50\\) kg/s. The burn lasts until the fuel runs out. Assume a cylindrical rocket with a fuselage radius \\(r = 20\\) cm, and a drag coefficient of \\(C = 0.5\\).\n\nUsing Euler’s method, plot the position vs. time and velocity vs. time graphs for the rocket from the moment it lifts off until it hits the ground again. Note: We’re not modeling a parachute here.\nMake sure your code is well commented.\nHow long was the flight?\nWhat is the rocket’s impact speed with the ground?\nOnce you think your simulation is correct, play with some of the key parameters to ensure that the results of your simulation agree with your own intuition. Here are some things you could try:\n\nChange the mass of the rocket.\nChange the mass of the fuel.\nChange the exhaust speed of the fuel.\nChange the drag coefficient.\nChange the size of the rocket (cross-sectional area).\n\n\nThe distance from home plate to the home run fence is \\(550\\) feet. It is well known that it is easier to hit home run in Denver (where the altitude is higher and the air density is lower) than it is in a ballpark that is closer to sea level. Use Euler’s method to determine the initial speed needed to hit a home run at sea level where the air density is \\(\\rho = 1.225\\) kg/m\\(^3\\). Then repeat the calculation for a ballpark in Denver where the air density is \\(82\\%\\) of the sea level value. If you were a pitcher, would you feel inclined to pitch in Denver? The drag constant for a baseball is not constant with its speed. Experimental work has revealed the following expression for the group of variables that multiplies velocity in the drag equation (at sea level)\n\n\\[\n{1\\over 2 m} \\rho A C  = {B \\over m} = .0039 + {.0058\\over 1 + e^{v - 35\\over 5}}\n\\]",
    "crumbs": [
      "Numerical Methods",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Euler's Method</span>"
    ]
  }
]