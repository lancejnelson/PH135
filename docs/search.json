[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Scientific Computing",
    "section": "",
    "text": "Python is a computer programming language available on all major platforms (Mac, Windows, Linux). Python is a scripting language which means that the computer interprets and runs your code at the moment you run it. In contrast, with a compiled language like C the code must first be converted into binary before it can run (called “compiling” the code). There are pros and cons to both types of languages. The on-the-fly interpretation of Python makes it quick and easy to write code and provides fast results for simple calculations. When codes become longer and more complex, on-the-fly interpretation becomes less efficient and execution time will be much slower than it would be with a compiled language. The pros and cons flip for a compiled language; writing code in a compiled language can be cumbersome and slow, but the execution time is typically much faster. Out of necessity, most programmers become proficient in both types of languages. Python(or another interpreted language) is used to “toy around” with your problem and build familiarity. As the complexity of the code increases the user is then forced to transition to a compiled language to get the needed speed. This is the famous “two language” problem and there is a new programming language designed to eliminate this problem by combining the pros from both into one language. (The name of the language is Julia)\nPython is free, open source software and is maintained by the non-profit Python software foundation. This is great because it means that you will always have free access to the Python language regardless of what organization or university you are affiliated with. You’ll never have to worry about not being able to use your Python code without paying for it. Another benefit of open source languages is that all of the codes developed by other people are available for anyone to inspect, modify, and use. This allows anyone to review another’s code to ensure that it does what they say it does, or to modify it to do something else. One last benefit that comes with an open source language is the community of Python users available to answer questions and provide instruction to the beginner. Answers to most questions about python are readily available on tutorial or forum websites.\n\n\n\nThe first step is to install the software (if you haven’t already). The most convenient way to install Python and also get many of the commonly-used libraries is to use an installer. I recommend Anaconda. When installing the software be sure to choose Python 3 since this is the current version. By default, Anaconda will install a suit of softwares and libraries that are commonly used. If you want to install other Python libraries, open the Anaconda-Navigator (green circle icon) and select the Environment tab on the left. Select Not Installed from the pull-down to see all of the libraries that are available to be installed. To install a library, check the box next to it and click Apply. Anaconda will take care of the rest.\n\nTo Do:\n\nInstall Anaconda\nCheck to see if the library “numpy” is installed. If not, install it.\n\n\n\n\n\nA Jupyter notebook is an electronic document designed to support interactive data processing, analysis, and visualization in an easily shared format. A Jupyter notebook can contain live code, math equations, explanatory text, and the output of codes (numbers, plots, graphics, etc..). To launch a Jupyter notebook, first open Anaconda-Navigator (green circle icon) and click the Launch button under JupyterLab. Jupyter can also be launched from the command line by typing jupyter-lab. The jupyter notebook will launch in your default web browser, but it is not a website. From here you can select an already existing Jupyter notebook, denoted by the orange icons and the .ipynb extension, or create a new notebook by clicking New from the File menu.\n\nTo Do:\n\nOn iLearn, find the module entitled “Jupyter Notebooks” and download the file “Intro.ipynb”.\nLaunch JupyterLab as explained above.\nOpen “Intro.ipynb” that you downloaded in step 1 and continue reading this book in the jupyter notebook.\n\n\n\n\nThere are two types of “cells” in a Jupyter notebook: code cells and text cells (also called Markdown cell). Code cells contain “live” Python code that can be run inside of the notebook with any output appearing directly below it. Markdown cells are designed to contain explanatory information about what is happening inside of the code cells. They can contain text, math equations, and images. Markdown cells support markdown, html, and Latex (for generating pretty math equations).\nBoth markdown and code cells can be executed by either selecting Run Selected Cells in the Run menu, by clicking the Play icon at the top of the notebook, or by using the Shift-Return shortcut when your cursor is in the desired cell.\n\n\n\nNavigating a Jupyter notebook is fairly straightforward but there are a few handy shortcuts/hotkeys that will make navigation quicker and your workflow more efficient. When working in a Jupyter notebook, you are always operating in one of two modes: edit mode or navigate mode. In edit mode you can make modifications to the text or code in a cell and in navigate mode you can add/delete cells and modify the cell type. If you can see a blinking cursor in one of the cells you are in edit mode. Otherwise you are in navigate mode. To exit edit mode, simply press the esc key and you will enter navigate mode. To exit navigate mode, simply press the enter key and you will enter edit mode for the cell you were focused on. (You can also double click on a cell with your mouse to enter edit mode.) The shift + enter key sequence will “execute” a cell and produce the associated output. For text cells, executing just means to render the text in a nicely formatted fashion. “Executing” a code cell will actually execute the code block contained in the cell. You also enter navigate mode every time you execute a cell using the shift + enter key sequence. A summary of these shortcuts is given below:\n\nUp/down arrows - Navigate to different cells in the notebook.\nY - turns a text cell into a code cell.\nM - turns a code cell into a text cell.\nA - inserts a new cell above the current cell.\nB - inserts a new cell below the current cell.\nX - deletes the current cell.\nenter - enters edit mode.\nshift + enter - execute a cell.\nesc - enter navigate mode.\n\nYou should take some time now to practice these shortcut keys until you become good at navigating a jupyter notebook. Consider attempting the following actions using the shortcuts above:\n\nAdd a cell below this one.\nTurn the cell into a code cell (observe the distinct appearance of code cells).\nType the following code into the cell:\n\nprint(\"I did it!\")\n\nExecute the cell using shift + enter. Observe the output.\nDelete the cell.\nEnter edit mode for this text cell.\nAdd a sentence of your choice at the end of the cell.\n“Execute” the cell and observe the new output.\nRemove the sentence to restore the cell to it’s previous state.\n\n\n\n\n\n\n\nJupyter notebooks in this class will be a nice mix of text cells (explanation) and code cells (examples). You will soon learn that code cells produce no output unless you explicitly tell them to using a print statement (similar to the one you used above). When you encounter a code cell, you should feel free to make modifications and additions to the cell until you fully understand how the code works.\n\n\n\nComments are a way to describe what each section of code does and makes it easier for you and others to understand the code. It may seem clear what each section of code does as you write it, but after a week, month or longer, it is unlikely to be obvious. Paul Wilson of the University of Wisconsin at Madison is quoted as saying, “Your closest collaborator is you six months ago, but you don’t reply to emails.” Comment your code now so that you are not confused later.\nThere are several ways to add comments to your code:\n\nUse # to start a comment. Everything on that line the follows will be ignored.\nFor longer comments that will span several lines, use triple double quotes to begin and end the comment (\"\"\")\n\nThe cell below illustrates these two ways to make comments:\n# Speed of light in a vacuum\nc = 3e8\n\nv = 300 # Speed of sound in air\n\n\"\"\"\nThe variables below are the initial conditions for a cannon\nlaunching a ball at a 30 degree angle with an initial speed of\n50 m/s.  The initial height of the cannon ball is 1000 m\n\"\"\"\nv = 50\ntheta = 30\nh_i = 1000\n\nTo Do:\n\nExecute the code block below and verify that no output is produced.\nAdd print statements that help you see the result of the calculation.\nAdd simple comments next to each line explaining the code.\n\n\na = 2 \nb = 3 \nc = a**b\nimport subprocess\nimport sys\n\ndef install(package):\n    subprocess.check_call([sys.executable, \"-m\", \"pip\", \"install\", package])\ninstall(\"numpy\")"
  },
  {
    "objectID": "chapters/variables.html",
    "href": "chapters/variables.html",
    "title": "2  Variables and Numbers",
    "section": "",
    "text": "When performing mathematical operations, it is often desirable to store the values in variables for later use instead of manually typing them back in each time you need to use them. This will reduce effort because small changes to variables can automatically propagate through your calculations.\nAttaching a value to a variable is called assignment and is performed using the equal sign (=), as demonstrated in the cell below:\na = 5.0\nb = 3\nc = a + b\n\n\nThere are some rules for allowed variable names in Python. They are as follows:\n\nVariable names must begin with a letter or an underscore (_)\nVariables names must only contain letters, numbers, and underscores.\nVariable names cannot contain spaces.\nVariables names cannot be a word reserved by Python for something else. These words are:\n\n\n\n\n\nPython\nreserved\nwords\n\n\n\n\n\nand\nas\nassert\nbreak\nclass\n\n\ncontinue\ndef\ndel\nelif\nelse\n\n\nexcept\nFalse\nfinally\nfor\nfrom\n\n\nglobal\nif\nimport\nin\nis\n\n\nlambda\nNone\nnonlocal\nnot\nor\n\n\npass\nraise\nreturn\nTrue\ntry\n\n\nwhy\nwith\nyield\n\n\n\n\n\nThe cell below contains some allowed variable names and some that are not allowed.\n\nTo Do:\n\nDetermine which variable names are allowed and which are not in the cell below.\nWhat does Python do if you try to define a variable using a name that is not allowed?\n\n\nmy1variable = 3\n1stvariables = 2\na big constant = 3\na_big_constant = 1e8\nIt is also a good practice to make variable names meaningful. For example, in the cell below we calculate \\(E = mc^2\\) using two choices for variable assignments. In one case, it is easy to determine what the calculation is and in the other it isn’t.\n# Good Variable Names\nmass_kg = 1.6\nlight_speed = 3.0e8\nE = mass_kg * light_speed**2\n\n\n# Poor Variable Names\na = 1.6\nb = 3.0e8\nc = a * b**2"
  },
  {
    "objectID": "chapters/variables.html#numbers-integers-and-floats",
    "href": "chapters/variables.html#numbers-integers-and-floats",
    "title": "2  Variables and Numbers",
    "section": "2.2 Numbers: Integers and Floats",
    "text": "2.2 Numbers: Integers and Floats\nThere are two types of numbers in Python - floats and integers. Floats, short for “floating point numbers,” are values with decimals in them. They may be either whole or non-whole numbers such as 3.0 or 1.2, but there is always a decimal point. Integers are whole numbers with no decimal point such as 2 or 53.\nMathematical operations that only use integers and evaluate to a whole number will generate an integers (except for division). All other situations will generate a float. See the example cell below.\na = 24\nb = 6\nd = 0.3\ne = a + b # Produces an integer.\nf = a + d # Produces a float\ng = a * b # Produces a ???\nh = a / b # Produces a ???\n\nTo Do:\n\nFor each of the mathematical operations above guess what type of number the result will be.\nUse print statements to verify your guesses and formulate a general rule that you can rely on. (Tip, the type() function will tell you what kind of number a variable is.)\n\n\nIntegers and floats can be inter-converted to each other using the int() and float() functions.\n\nint(3.0)\nfloat(4)\n\n4.0\n\n\nThe distinction between floats and ints is often a minor detail. Occasionally, a function will require that an argument be a float or an int but usually you won’t have to worry about which one you use.\nBelow you will find some other common mathematical operations that can be performed on numerical variables.\na = 20\nb = 10\nc = a + b \nd = a/b  \nr = a//b\nr = a % b\ne = a * b\nf = c**4\n\nTo Do:\n\nUse print statements to investigate what each operation does.\n\nGuess what type of number you expect the result to produce (int or float) and then check yourself?\nAdd comments next to each line (Use # to start a comment) explaining that operation.\n\n\n\n2.2.1 Augmented Assignment\nAugmented assignment is a shortened way to make a simple modification to a variable. For example, if we want to increase the value of a variable by 10, one way to do it would be like this.\na = 5\na = a + 10\nThis is certainly not difficult, but it does involve typing the variable twice which becomes cumbersome as your variable name gets longer. Alternatively, we can accomplish the same thing with the += operator.\na = 5\na += 10\nAugmented assignment can be used with addition, subtraction, multiplication, and division as shown in the code cell below.\na = 7\na += 3\na -= 1\na *= 4\na /= 3\n\nTo Do:\n\nPredict what the final result of a will be in the code cell above.\nAdd an appropriately-place print statement to see if you were correct.\nIf you were wrong, pow-wow with your neighbor until you understand.\n\n\n\n\n2.2.2 Compound Assignment\nAt the beginning of a program or calculation, it is often necessary to define a set of variables. Each variable may get it’s own line of code, but if there are a lot of variables, this can begin to clutter your code a little. An alternative is to assign multiple variables on a single line. In the code below, we assign the atomic mass of the first three elements.\nH, He, Li = 1.01, 4.00, 5.39\n\nTo Do:\n\nUse print statements to verify that each variable was assigned it’s own value.\nAdd assignments for the atomic masses of the next three elements on the periodic table.\n\n\n\n\n2.2.3 Large numbers\nSometimes you find yourself working with large numbers in your calculation. Maybe your calculation involves the use of ten billion, which has 10 zeros in it. It can be difficult to look at all of those zeros with no commas to help break it up. In those cases, you can use an underscore (_) in place of the comma, as shown below.\nmyLargeNumber = 10000000000 # This is tough to look at.\nmyLargeNumber = 10_000_000_000  # This is easy to read\n\nmyLargeFloat = 5000000.6 # This is tough to read\nmyLargeFloat = 5_000_000.6 # This is easy to read\n\n\n2.2.4 Very Large Numbers\nIf your number is very large or very small ( \\(20-30\\) zeros), you would probably rather not have to type all of the zeros at all, even if you can break it up with the underscores. For example, the Boltzmann constant, which comes up in thermodynamics, has a value equal to\n\\[ 1.38 \\times 10^{-23}\\]\nWe can avoid typing all those zeros by using scientific notation when defining the variable. (see example below) This is super handy for very large and very small number. (Numbers of both variety show up frequently in physics!)\nkB = 1.38e-23\n\n\n2.2.5 Python functions\nIn addition to basic mathematical functions, python contains several mathematical functions. As in mathematics, a function has a name (e.g. f) and the arguments are places inside of the parenthesis after the name. The argument is any value or piece of information fed into the function. In the case below, f requires a single argument x.\n\\[f(x)\\]\nIn the cell below, you will find several useful math equations.\n\nabs(-5.5)\nfloat(2)\nint(5.6)\nprint(1.26e-6)\nround(-5.51)\nstr(3.2)\n\n1.26e-06\n\n\n'3.2'\n\n\nIn addition to Python’s native collection of mathematical functions, there is also a math module with more mathematical functions. Think of a module as an add-on or tool pack for Python just like a library. The math module comes with every installation of python and can be imported (i.e. activated) using the import math command. After the module has been imported, any function in the module is called using math.function() where function is the name of the function. Here is a list of commonly-used function inside the math module:\n\nimport math\nmath.sqrt(4)\nmath.ceil(4.3)\nmath.cos(1.5)\nmath.sin(1.5)\nmath.tan(3.14)\nmath.asin(1)\nmath.acos(1/2)\nmath.atan(2)\nmath.degrees(6.28)\nmath.e\nmath.exp(5)\nmath.factorial(4)\nmath.log(200)\nmath.log10(1000)\nmath.radians(360)\nmath.pi\nmath.pow(2,8)\n\n256.0\n\n\n\nTo Do:\n\nUse print statements to figure out what each function in the code cell above does. Pay special attention to trigonometric function. Do these functions expect the argument to be in radians or degrees?\nAdd comments to remind yourself for later.\n\n\nThere are other ways to import functions from modules. If you only want to use a single function inside the module, you can selectively import it using from, as shown below.\n\nfrom math import radians\nradians(4)\n\n0.06981317007977318"
  },
  {
    "objectID": "chapters/variables.html#flash-cards",
    "href": "chapters/variables.html#flash-cards",
    "title": "2  Variables and Numbers",
    "section": "2.3 Flash Cards",
    "text": "2.3 Flash Cards\n\nWhat are the rules for naming variables in Python?\nWhen will a mathematical calculation produce a float?\nWhen will a mathematical calculation produce an int?\nWhat is the best way to increase/decrease the value of a variable by a multiplicative factor (multiply it by a number)?\nWhat is the best way to increase/decrease the value of a variable by an additive constant (add a number to it)?\nWhen assigning large numbers to variables, what character can replace the “,” to separate the numbers into groups of three?\nHow do you use scientific notation to assign a very large number to a variable?\nExplain how to print a sentence with a variable inserted in the middle?\nWhat format code should be used to display a variable as a float with 8 total spaces and 2 numbers after the decimal?\nWhat format code should be used to display a variable in scientific notation with 6 total spaces and 2 numbers after the decimal?\nWhen using a trig function (\\(\\sin \\theta\\), \\(\\cos \\theta\\), \\(\\tan \\theta\\)), the number that is passed in must have what units?\nWhat does the math.radians function do?\nWhere can you find King Benjamin’s address to his people?"
  },
  {
    "objectID": "chapters/variables.html#exercises",
    "href": "chapters/variables.html#exercises",
    "title": "2  Variables and Numbers",
    "section": "2.4 Exercises",
    "text": "2.4 Exercises\n\nCalculate the distance from the point \\((-48,56)\\) to the point \\((23,81)\\) 1- using the math.hypot() function and then 2- using the following distance equation: \\[ d = \\sqrt{\\Delta x^2 + \\Delta y^2}\\] Print out the result and check your answer with your neighbor’s answer.\nSolve the quadratic equation using the quadratic function below for \\(a = 1\\), \\(b = 2\\), and \\(c = 1\\). \\[ x = {- b \\pm \\sqrt{b^2 - 4 a c} \\over 2a}  \\] Print out the result and check your answer with a classmate.\n(Solar Mass) The mass of the sun can be calculated using the following formula:\\[ M_\\text{sun} = {4 \\pi^2 (1 \\text{ AU})^3\\over G (1 \\text{ yr})^2}\\]\nThe unit AU is called an astronomical unit of length and is defined to be the average distance between the sun and earth. \\[ 1 \\text{ AU} = 1.58\\times 10^{-5} \\text{ light years}\\] where \\(1 \\text{ lightyear} = 9.5 \\times 10^{12}\\) km. The constant \\(G\\) is called the gravitational constant and has the value: \\[ G = 6.674 \\times 10^{-11} \\text{ m}^3 \\text{ kg}^{-1}\\text{ s}^{-1}\\] Calculate the mass of the sun and display your result using a print statement. You should find a value of \\(M_\\text{Sun} = 2.01 \\times 10^{30}\\) kg\n(Projectile Motion) The range of a projectile is given by the equation:\\[ d = {2 v^2 \\cos \\theta \\sin \\theta \\over g}\\] or the equivalent expression:\\[ d = {v^2  \\sin 2 \\theta \\over g}\\] where \\(g = 9.8\\) m/s\\(^2\\), \\(\\theta\\) is the launch angle, and \\(v\\) is the launch speed.\n\nUsing a launch angle of 60\\(^\\circ\\) and a launch speed of \\(40\\) m/s, verify that both expressions above give the same result for the range.\nNow pick one of the equations above and use trial and error to determine the angle that gives maximum range.\n\n\nv = 40\ng = 9.8\n\n(Rydberg’s constant) Rydberg’s constant (\\(R_\\infty\\)) is a physical constant in Rydberg’s formula which was used to predict the spectrum of light emitted by a heavy atom. Rydberg’s constant is given by: \\[R_\\infty = {m_e e^4 \\over 8 \\epsilon_0^2 h^3 c}\\]\nwhere\n\n\\(m_e = 9.109 \\times 10^{-31}\\) kg is the mass of an electron.\n\\(e = 1.602 \\times 10^{-19}\\) C is the charge of an electron/proton.\n\\(\\epsilon_0 = 8.854 \\times 10^{-12}\\) C V\\(^{-1}\\) m\\(^{-1}\\) is the electrical constant.\n\\(h = 6.626 \\times 10^{-34}\\) J s is Plank’s constant.\n\\(c = 3 \\times 10^8\\) m/s is the speed of light.\n\nThese constants show up all over in physics. In the cell below write some code that assigns the constants to variables and then use the variables to calculate Rydberg’s constant. Use a print statement to display the result. The result should be: \\(R_\\infty = 10961656.2162\\) (in m\\(^{-1}\\))\nIn Einstein’s special theory of relativity, the momentum of an object with mass \\(m\\) (in kg) and velocity \\(v\\) (in m/s) is given by:\\[ p = m v \\gamma\\] where \\[\\gamma = {1\\over \\sqrt{1 - {v^2\\over c^2}}}\\] with \\(c = 3 \\times 10^8\\) m/s\n\nCalculate the momentum of an object with mass \\(m = 0.14\\) kg and speed \\(v = 50\\) m/s. Then compare to the classical expression for momentum: \\(p = mv\\).\nNow calculate the momentum of an object with mass \\(m = 0.14\\) kg and whose speed is \\({1 \\over 4}\\) the speed of light. Repeat the comparison to the classical value.\n\nRepeat for the following speeds: \\({1\\over 2}\\) the speed of light, \\({3\\over 4}\\) the speed of light, and \\({7\\over 8}\\) the speed of light. Repeat the comparison to the classical value."
  },
  {
    "objectID": "chapters/strings.html",
    "href": "chapters/strings.html",
    "title": "3  Strings",
    "section": "",
    "text": "Another commonly-used type of data is a string of characters known simply as strings. Strings can contain a variety of characters including letters, numbers, and symbols."
  },
  {
    "objectID": "chapters/strings.html#creating-strings",
    "href": "chapters/strings.html#creating-strings",
    "title": "3  Strings",
    "section": "3.1 Creating Strings",
    "text": "3.1 Creating Strings\nStrings are created by placing the sequence of characters in single (or double) quotes.\ntext = \"some text\"\nStrings can also be created by converting a float or an integer into a string using the str() function.\ntext = str(4.5)\nOne common error made when working with strings is to attempt to perform math with them. Python will not perform math with strings because it sees them as a series of characters and nothing more. In the cell below, we attempt to perform math with some strings.\na = \"4\"\nb = \"2\"\nc = 5\n\nd = a + b\ne = a * b\nf = b * c\n\nTo Do:\n\nUse print statements in the cell above to determine what happens when you add two strings together. (Ancillary question: Can you subtract strings?)\nUse print statements in the cell above to determine what happens when you multiply two strings.\nUse print statements in the cell above to determine what happens when you multiply a string and an integer.\nWhat do you think will happen if you multiplied a string and a float? Guess and then see if you’re right.\nAdd comments for you to refer back to later.\n\n\nIf you want to know the length of a string, you can use the len() function\n\ntext = \"some text\"\nlen(text)\n\n9\n\n\nThe length of the string above is 9 because a space is a valid character."
  },
  {
    "objectID": "chapters/strings.html#displaying-text-and-numbers-together",
    "href": "chapters/strings.html#displaying-text-and-numbers-together",
    "title": "3  Strings",
    "section": "3.2 Displaying text and numbers together",
    "text": "3.2 Displaying text and numbers together\nYou have been using print() statements quite a lot lately (hopefully) but you probably haven’t printed text and numbers together. To display both text and numbers in the same message, there are several options. The first is to just put multiple variables into the print() function, separating them with commas.\n\ng = 9.8\nunit = \"m/s^2\"\nprint(g,unit)\n\n9.8 m/s^2\n\n\nAnother option is to convert the number to a string and then “add” it to the other string. This creates a single string as an argument to the print() function.\n\ng = 9.8\nunit = \"m/s^2\"\nprint(str(g) + unit)\n\n9.8m/s^2\n\n\nNotice the lack of space between the number and the unit. “Adding” the two strings smashed them together exactly as they were, no spaces added. You can insert multiple numbers into a string using something called “f”-strings. (short for formatted strings). To construct an f-string, simply place an “f” in front of the string. Anytime you want to insert a number in your string, enclose it in curly braces.\n\nv = 5.0\nc = 3e8\nprint(f\"The speed of light is {c} and the speed of my car is {v}\")\n\nThe speed of light is 300000000.0 and the speed of my car is 5.0\n\n\nThat’s a clever way to insert a numerical value into a string, but the value of the speed of light is still displaying too many digits. To specify how the number should be formatted place a : after the variable name followed by a formatting tag.\n\nv1 = 5.0\nv2 = 8.3\nc = 2.998e8\nn = 2\n\nprint(f\"There are {n:d} cars traveling side by side.  One car is traveling at {v1:4.2f} m/s and the other is traveling at {v2:4.2f} m/s.  Those speeds are much smaller than the speed of light, which is {c:.2e} m/s\") \n\nThere are 2 cars traveling side by side.  One car is traveling at 5.00 m/s and the other is traveling at 8.30 m/s.  Those speeds are much smaller than the speed of light, which is 3.00e+08 m/s\n\n\nThe structure of the stuff inside of the curly braces is {variable:formatcode}; variable holds the value to be displayed and formatcode indicates how the variable should be formatted when it is printed. The f in :4.2f indicates that the variable should be displayed as a float and the 4.2 indicates that four spaces should be allocated to display the number and no more than 2 numbers after the decimal should be displayed. A selection of some commonly-used format codes is given below.\n\nA summary of common format codes.\n\n\n\n\n\n\nformat code\nexplanation\n\n\n\n\n{variable}\nUse the default format for the data type.\n\n\n{variable:4d}\nDisplay as an integer, allocating 4 spaces for it.\n\n\n{variable:.4f}\nDisplay as a float, with four numbers after the decimal being displayed.\n\n\n{variable:8.4f}\nDisplay as a float, allocating 8 total spaces and 4 numbers after the decimal place.\n\n\n{variable:8.4e}\nDisplay using scientific notation, allocating 8 total spaces and 4 numbers after the decimal place.\n\n\n{variable:6s}\nDisplay as a string, allocating 6 total spaces for it. If the string is longer than 6 spaces, it will display the entire string with no extra white space. If the string is shorter than 6 spaces, it will pad the string with whitespace until it is 6 spaces long.\n\n\n\n\nTo Do:\n\nModify the print statement above so that the float variables are given 8 total spaces with only 1 number after the decimal being displayed.\nModify the print statement above so that the speed of light is displayed with 3 numbers after the decimal place."
  },
  {
    "objectID": "chapters/strings.html#indexing-and-slicing",
    "href": "chapters/strings.html#indexing-and-slicing",
    "title": "3  Strings",
    "section": "3.3 Indexing and Slicing",
    "text": "3.3 Indexing and Slicing\nAccessing a piece (or slice) of a string is a common task in scientific computing. Often you will import data into Python from a text file and need to extract a portion of the file for later use in calculations. Indexing allows the user to extract a single element, or character, from a string. The key detail about indexing in Python is that indices start from zero. That means that the first character is index zero, the second character is index 1, and so on. For example, maybe a string contains the following amino acid sequence ‘MSLFKIRMPE’. For this example, the indices are as follows:\n\n\n\nCharacters\nM\nS\nL\nF\nK\nI\nR\nM\nP\nE\n\n\n\n\nIndex\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\nTo access a single character from a string, place the desired index in square brackets after the name of the string.\n\nseq = \"MSLFKIRMPI\"\nseq[0]\n\n'M'\n\n\nTo access the last character in a string you could do\n\nseq = \"MSLFKIRMPI\"\nseq[len(seq) - 1]\n\n'I'\n\n\nBut this seems overly cumbersome. An easier approach is to index backwards. The string can be reverse indexed from the last character to the first using negative indices, starting with -1 as the last charcter.\n\nseq = \"MSLFKIRMPE\"\nseq[-1]\n\n'E'\n\n\n\nTo Do:\n\nAccess the 5th character in the peptide sequence above.\nAccess the character that is 3rd from the end in the peptide sequence above.\n\n\nIndexing only provides a single character, but it is common to want a series of characters from a string. Slicing allows us to grab a section of a string. Slicing is performed by specifying start and stop indices separated by a colon in the square brackets. One important detail worth mentioning: the character at the starting index is included in the slice while the character located at the final index is not included in the slice.\n\nseq = \"MSLFKIRMPE\"\nseq[0:5]\n\n'MSLFK'\n\n\nLooking at the string, you notice that the character at location 5 (I) has been excluded from the slice. You can leave off the first number when slicing and the slice will start at the beginning of the string.\n\nseq = \"MSLFKIRMPE\"\nseq[:5]\n\n'MSLFK'\n\n\nYou can also use negative indices when slicing. This is especially helpful when you want to grab the last few characters in a string.\nfile = \"data.txt\"\next = file[-3:]\nFinally, we can adjust the step size in the slice. That is, we can ask for every other character in the string by setting a step size of 2. The structure of the slice is [start,stop,step].\n\nseq = \"MSLFKIRMPE\"\nseq[0:8:2]\n\n'MLKR'\n\n\nYou can omit the start and stop indices and Python will assume that you are slicing the entire string.\n\nseq = \"MSLFKIRMPE\"\nseq[::2]\n\n'MLKRP'"
  },
  {
    "objectID": "chapters/strings.html#string-methods",
    "href": "chapters/strings.html#string-methods",
    "title": "3  Strings",
    "section": "3.4 String Methods",
    "text": "3.4 String Methods\nA method is a function that works only with a specific type of object. String methods only work on strings, and they don’t work on other types of objects, like floats or ints. If it helps you, you can just think of a method as a function.\nOne example of a string method is the capitalize() function which returns a string with the first letter capitalized. To use a method (referred to as calling the method), the method name is appended to the variable you want it to operate on. For example, below is an Albert Einstein quote that needs capitalized.\n\nquote = \"i want to know God's thoughts. The rest are details.\"\nquote.capitalize()\nprint(quote)\n\ni want to know God's thoughts. The rest are details.\n\n\nNotice that the original variable (quote) remains unchanged. This particular method does not change the value of the original string but rather returns a capitalized version of it. If we want to save the capitalized version, we can assign it to a new variable, or overwrite the original.\n\nquote = \"i want to know God's thoughts. The rest are details\"\nquote = quote.capitalize()\nprint(quote)\n\nI want to know god's thoughts. the rest are details\n\n\nIn the cell below you will find a list of commonly-used string methods.\n\na = \"spdfgssfpggg\"\na.capitalize()\na.center(10)\na.count(\"s\")\na.find(\"d\")\na.isalnum()\na.isalpha()\na.isdigit()\na.lstrip(\"s\")\na.rstrip(\"g\")\na.split(\"s\")\na.startswith(\"s\")\na.endswith(\"p\")\n\nFalse\n\n\n\nTo Do:\n\nUse well-placed print statements to determine what each string method does.\nAdd comments next to each method for future reference."
  },
  {
    "objectID": "chapters/booleans.html",
    "href": "chapters/booleans.html",
    "title": "4  Boolean Variables and Conditionals",
    "section": "",
    "text": "We have learned about three types of variables in Python: ints, floats, and strings. Another variable type is a boolean, which can be one of two values: True or False. You can assign a boolean variable in the same way that you assign numbers or string, using =\nmyBool = True\nTrue must be capitalized so don’t try true or it won’t be a boolean\nmyBool = true\n\n\nOften you will want to check to see if some condition is true. For example, maybe you want to know if the radius of a certain satellite’s orbit is bigger or smaller than Mercury’s orbit. To perform this check, there are several boolean operators that will return True or False. Take note of the boolean operators shown in the cell below along with the comments added to explain what they do.\n\nr1 = 3.5e8\nr2 = 2.7e6\n\nr1 > r2 # Is r1 greater than r2\nr1 < r2 # Is r1 less than r2\nr1 >= r2 # Is r1 greater than or equal to r2\nr1 <= r2 # Is r1 less than or equal to r2\nr1 != r2 # Is r1 not equal to r2\nr1 == r2 # Is r1 equal to r2\n\nFalse\n\n\nA word of caution about comparing Python floats using == is in order here. Python floats are stored as a 53-digit, base-2 binary number(that’s a mouthful). If you’re interested in what that means, we can talk more. If you’re not that interested, just know that when you define a float in Python, the number that is stored in the computer is not exactly the number that you think it is. This can cause problems when you are comparing two numbers that you think should be equal but actually aren’t equal in the computer.1 The code below illustrates this problem.\n\na = 0.1\nb = 3 * a\nc = 0.3\nprint(b==c)  # Are they the same number?  You would think they would\n             # be right?\nprint(\" {:.5f} \".format(b))     # They sure look the same.\nprint(\" {:.5f} \".format(c))     # They sure look the same.\nprint(\" {:.45f} \".format(b))  #b--- out to 45 decimal places\nprint(\" {:.45f} \".format(c))  #c--- out to 45 decimal places\n\nFalse\n 0.30000 \n 0.30000 \n 0.300000000000000044408920985006261616945266724 \n 0.299999999999999988897769753748434595763683319 \n\n\nThe first two print statements display the value of b and c to five decimal places. The second two print statements force Python to display the value of b and c out to 45 decimal places. Notice that the true value of b is not exactly equal to 0.3. This is why the statement print(b==c) returns False. The take home message here is that comparing two floats to see if they are equal is always a bad idea. A better way to check to see if two floats are equal (or close enough that we can say they are equal) is to check if the absolute value of their difference is very small, like this:\n\na = 0.1\nb = 3 * a\nc = 0.3\nprint(abs(b - c) < 1e-10)\n\nTrue\n\n\n\n\n\nComparisons like those shown above can be chained together to make compound comparisons using the and, or, and not operators.\n\n\n\nOperator\nDescription\n\n\n\n\nand\nTests for both being True\n\n\nor\nTests for either being True\n\n\nnot\nTests for False\n\n\n\nThe and operator requires both inputs to be True in order to return True while the or operator requires only one input to be True in order to evaluate at True. The not operator is different in that it only takes a single input value and returns True if and only if the input is False. It is a test for False.\nTruth tables are a good way to visualize the output from compound comparisons.\n\n\n\np\nq\np and q\np or q\n\n\n\n\nTrue\nTrue\nTrue\nTrue\n\n\nTrue\nFalse\nFalse\nTrue\n\n\nFalse\nTrue\nFalse\nTrue\n\n\nFalse\nFalse\nFalse\nFalse\n\n\n\nAs a simple example, suppose you know the density (\\(\\rho\\)) and speed of light (c) for two materials and you’d like to know if both values are bigger for material 1 or material 2.\n\nTo Do:\n\nPredict the output for each compound comparison given below. Add your guess as a comment.\nNow add appropriately-placed print statements to check your guesses.\nModify your guess as needed and discuss any questions with a neighbor.\n\n\n\nc1 = 2.5e8\nc2 = 2.48e8\nρ1 = 450\nρ2 = 580\n\nc1 > c2 and ρ1 > ρ2\nc1 < c2 and ρ1 < ρ2\nc1 > c2 and ρ1 < ρ2\nc1 < c2 and ρ1 > ρ2\n\nc1 > c2 and not ρ1 > ρ2\nc1 < c2 and not ρ1 < ρ2\n\nc1 > c2 or ρ1 > ρ2\nc1 < c2 or ρ1 < ρ2\n\nTrue\n\n\n\n\n\nYou can check for inclusion using the Python in operator. This provides an easy way to see if a character (or word) is present in a long string. Let’s say you have a long string that contains the names of Jupyter’s moons (there are 79 of them!!) and you want to see if a certain moon is included in the list. The in statement let’s us quickly test to see if it is in the list. (see example below)\n\njupytermoons = \"Metis,Adrastea,Amalthea,Thebe,Io,Europa,Ganymede,Callisto,Themisto,Leda,Himalia,Lysithea,Elara,Dia,Carpo,Euporie,Thelxinoe,Euanthe,Helike,Orthosie,Iocaste,Praxidike,Harpalyke,Mneme,Hermippe,Thyone,Ananke,Herse,Aitne,Kale,Taygete,Chaldene,Erinome,Aoede,Kallichore,Kalyke,Carme,Callirrhoe,Eurydome,Pasithee,Kore,Cyllene,Eukelade,Pasiphae,Hegemone,Arche,Isonoe,Sinope,Sponde,Autonoe,Megaclite\"\n\n\"Cyllene\" in jupytermoons\n\nTrue"
  },
  {
    "objectID": "chapters/booleans.html#conditions",
    "href": "chapters/booleans.html#conditions",
    "title": "4  Boolean Variables and Conditionals",
    "section": "4.2 Conditions",
    "text": "4.2 Conditions\nConditions allow the user to specify if and when certain lines or blocks of code are executed. Specifically, when a condition is true, the block of indented code directly below it will run.\n\n4.2.1 if statement\nThe if statement is used to control when a block of code runs. It’s usage is shown below ending in a colon and the block of code below indented with four spaces. Using the Tab key will also produce four spaces.\n\njupytermoons = \"Metis,Adrastea,Amalthea,Thebe,Io,Europa,Ganymede,Callisto,Themisto,Leda,Himalia,Lysithea,Elara,Dia,Carpo,Euporie,Thelxinoe,Euanthe,Helike,Orthosie,Iocaste,Praxidike,Harpalyke,Mneme,Hermippe,Thyone,Ananke,Herse,Aitne,Kale,Taygete,Chaldene,Erinome,Aoede,Kallichore,Kalyke,Carme,Callirrhoe,Eurydome,Pasithee,Kore,Cyllene,Eukelade,Pasiphae,Hegemone,Arche,Isonoe,Sinope,Sponde,Autonoe,Megaclite\"\n\nif \"Cyllene\" in jupytermoons:\n    found = True\n    print(\"Found Cyllene in the list\")\n    \nif \"Matis\" in jupytermoons:\n    found = True\n    print(\"Found Matis in the list\")\n\nFound Cyllene in the list\n\n\nIf the boolean statement after if is true, the indented code below it will run. If the statement is false, Python just skips the indented lines below.\n\n\n4.2.2 else Statment\nSometimes there will be an alternate block of code that you want to run if the if statement evaluates to False. The else statement is used to specify this block of code, as shown below.\n\njupytermoons = \"Metis,Adrastea,Amalthea,Thebe,Io,Europa,Ganymede,Callisto,Themisto,Leda,Himalia,Lysithea,Elara,Dia,Carpo,Euporie,Thelxinoe,Euanthe,Helike,Orthosie,Iocaste,Praxidike,Harpalyke,Mneme,Hermippe,Thyone,Ananke,Herse,Aitne,Kale,Taygete,Chaldene,Erinome,Aoede,Kallichore,Kalyke,Carme,Callirrhoe,Eurydome,Pasithee,Kore,Cyllene,Eukelade,Pasiphae,Hegemone,Arche,Isonoe,Sinope,Sponde,Autonoe,Megaclite\"\n\nif \"Cyllene\" in jupytermoons:\n    found = True\n    print(\"Found Cyllene in the string\")\nelse:\n    found = False\n    print(\"Did not find Cyllene in the string\")\n\n    \nif \"Matis\" in jupytermoons:\n    found = True\n    print(\"Found Matis in the string\")\nelse:\n    found = False\n    print(\"Did not find Matis in the string\")\n\nFound Cyllene in the string\nDid not find Matis in the string\n\n\nNotice that the else statement must be followed by a colon and the block of code to be executed is indented, just as in the if block.\nThere is an additional statement called the elif statement, short for “else if”, which is used to add extra conditions below the initial if statement. The block of code below the elif statement only runs if the if statement is false and the elif statement is true. An example is given below.\n\njupytermoons = \"Metis,Adrastea,Amalthea,Thebe,Io,Europa,Ganymede,Callisto,Themisto,Leda,Himalia,Lysithea,Elara,Dia,Carpo,Euporie,Thelxinoe,Euanthe,Helike,Orthosie,Iocaste,Praxidike,Harpalyke,Mneme,Hermippe,Thyone,Ananke,Herse,Aitne,Kale,Taygete,Chaldene,Erinome,Aoede,Kallichore,Kalyke,Carme,Callirrhoe,Eurydome,Pasithee,Kore,Cyllene,Eukelade,Pasiphae,Hegemone,Arche,Isonoe,Sinope,Sponde,Autonoe,Megaclite\"\n\nif \"Matis\" in jupytermoons:\n    foundMatis = True\n    print(\"Found Matis in the string\")\nelif \"Cyllene\" in jupytermoons:\n    foundCyllene = True\n    print(\"Found Cyllene in the string.\")\nelse:\n    foundCyl = False\n    foundMatis = False\n    print(\"Did not find Cyllene or Matis in the string\")\n\nFound Cyllene in the string.\n\n\nIt is worth noting that else statements are not required. If you leave the else statement off and the if statement is false, no code block will execute."
  },
  {
    "objectID": "chapters/listsAndTuples.html",
    "href": "chapters/listsAndTuples.html",
    "title": "5  Lists and Tuples",
    "section": "",
    "text": "Up to this point, we have only worked with single numerical values or strings (multiple characters). Often we will want to work with collections of values (perhaps the orbital period of all of the planets in our solar system.) and it will be quite inconvenient to store each value into its own variable. Instead, the values can be stored in a list or tuple. Lists and tuples are both collections of elements , like numbers or strings. The key difference between them is that tuples are immutable, which means they cannot be modified after their initial creation. On the other hand, lists are mutable, or able to be modified."
  },
  {
    "objectID": "chapters/listsAndTuples.html#creating-lists",
    "href": "chapters/listsAndTuples.html#creating-lists",
    "title": "5  Lists and Tuples",
    "section": "5.1 Creating Lists",
    "text": "5.1 Creating Lists\nThe easiest way to create a list is by putting the list elements inside of square brackets. Below, we create a list containing the masses of all of the planets in our solar system.\nmass = [1.8986e27,5.6846e26,10.243e25,8.6810e25,5.9736e24,4.8685e24,6.4185e23,3.3022e23]\nNote that square brackets ([]) must be used when creating the list. If you accidentally use parenthesis (())1 or curly brackets ({})2 you’ll end up creating something other than a list.1 Use parenthesis to create a tuple, which is just like a list but cannot be modified.2 Use curly brackets to create a dictionary, which is like a list but can be indexed on any data type, not just integers.\nLists can contain any type of data and the type of data doesn’t have to be the same for all of the elements. Below, we create a list of the electron configurations for the first 10 elements on the periodic table.\nelectrons = [\"1s1\",\"1s2\", \"1s2-2s1\",\"1s2-2s2\",\"1s2-2s2-2p1\",\"1s2-2s2-2p2\",\"1s2-2s2-2p3\",\"1s2-2s2-2p4\",\"1s2-2s2-2p5\",\"1s2-2s2-2p6\"]\nLists can contain mixed data types. Below we construct a list of the electrical conductivities of three metals.\nconductivity = [\"Gold\",4.10e7,\"Copper\",5.96e7,\"Aluminum\",3.5e7]\nIf the elements of a list are also lists, we call it a nested list.\nconductivity = [[1,2,3],[4,5,6],[7,8,9]]"
  },
  {
    "objectID": "chapters/listsAndTuples.html#indexing-and-slicing-lists",
    "href": "chapters/listsAndTuples.html#indexing-and-slicing-lists",
    "title": "5  Lists and Tuples",
    "section": "5.2 Indexing and Slicing Lists",
    "text": "5.2 Indexing and Slicing Lists\nIndexing is used to access individual elements of a list, and it is similar to indexing strings. The index is the position of the desired element in the list and the index numbering starts at zero. Accessing an element of a list is done by placing the numerical index of the element we want in square brackets behind the list name. For example, if we want the electron configuration of the first element in our list from above, we use electrons[0] and the electron configuration for the second element would be electrons[1] and so on. Just as with string, negative indices can be used to access list elements counting from the back of the list forward.\nelectrons = [\"1s1\",\"1s2\", \"1s2-2s1\",\"1s2-2s2\",\"1s2-2s2-2p1\",\"1s2-2s2-2p2\",\"1s2-2s2-2p3\",\"1s2-2s2-2p4\",\"1s2-2s2-2p5\",\"1s2-2s2-2p6\"]\n\nelectrons[1]\nelectrons[-2]\nelectrons[5]\nelectrons[-1]\n\nTo Do:\n\nPredict the output for each of the indexes performed in the cell above.\nUse print statements to check your answers.\nDiscuss any misunderstandings with a peer.\n\n\nSince lists are mutable, we can modify the value of an element in a list using the = operator.\n\nconductivity = [\"Gold\",4.10e7,\"Copper\",5.96e7,\"Aluminum\",3.5e7]\n\nconductivity[1] = 4.15e7\nconductivity\n\n['Gold', 41500000.0, 'Copper', 59600000.0, 'Aluminum', 35000000.0]\n\n\n\nTo Do:\n\nUse a print statement to verify that the conductivity list was indeed modified as expected.\nModify the third element to be “Platinum” and the fourth to be the conductivity of Platinum (9.43e6).\n\n\nMultiple list elements can be retrieved at once (called slicing) by including the start and stop indices separated by a colon: [start:stop:step]. A convention that occurs throughout python is that the first index is included in the slice but the second is not. (i.e. [included: excluded: step]) Default values for the start location, stop location, and step sizes will be used if these values are omitted. Below we give some examples of slicing.\nelectrons = [\"1s1\",\"1s2\", \"1s2-2s1\",\"1s2-2s2\",\"1s2-2s2-2p1\",\"1s2-2s2-2p2\",\"1s2-2s2-2p3\",\"1s2-2s2-2p4\",\"1s2-2s2-2p5\",\"1s2-2s2-2p6\"]\n\nelectrons[1:]\nelectrons[1:3]\nelectrons[:3]\nelectrons[1:8:2]\nelectrons[5:2:-1]\n\nTo Do:\n\nPredict the output for the five slices in the cell above.\nUse print statements to check your answers.\nDiscuss any misunderstandings with a peer.\nNow use list slicing to extract every third element of the list in the cell above starting at the beginning.\n\n\n\n5.2.1 Tests for Inclusion\nJust as with strings, the in operator can be used with lists to determine if a list element is present. Suppose you have a list of all the known radioactive elements on the periodic table and you’d like to know if Iridium is in the list. The in statement let’s us quickly test to see if it is in the list. (see example below)\n\nradioactiveElements = [\"Technetium\",\"Promethium\",\"Polonium\",\"Astatine\",\"Radon\",\"Francium\",\"Radium\", \"Actinium\", \"Thorium\", \"Protactinium\",\"Uranium\",\"Neptunium\",\"Plutonium\",\"Americium\",\"Curium\",\"Berkelium\",\"Californium\",\"Einsteinium\",\"Fermium\",\"Mendelevium\",\"Nobelium\",\"Lawrencium\",\"Rutherfordium\",\"Dubnium\",\"Seaborgium\",\"Bohrium\",\"Hassium\",\"Meitnerium\",\"Darmstadtium\",\"Roentenium\",\"Copernicium\",\"Nihonium\",\"Flerovium\",\"Moscovium\",\"Livermorium\",\"Tennessine\", \"Oganesson\"]\n\n\"Iridium\" in radioactiveElements\n\nFalse\n\n\nThe in operator will work with numerical data as well.\n\nnumbers = [5,6,3,1,2]\n\n4 in numbers\n\nFalse\n\n\n\n\n5.2.2 List Methods\nLists have a collection of methods (or functions) for accomplishing routine tasks. Some of the more common list methods are given below. All of the methods given will modify the original list (except copy()). As a reminder, methods only work on the object type that they were designed for (lists in this case) and they are called by appending the method name to the variable you want it to operate on. (i.e. myList.clear())\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\nappend(element)\nAdds a single element to the end of the list.\n\n\nclear()\nRemoves all elements from a list.\n\n\ncopy()\nCreates an independent copy of the list.\n\n\ncount(element)\nCounts the number of occurrences of element in the list.\n\n\nextend(elements)\nAdds multiple elements to the end of the list.\n\n\nindex(element)\nReturns the index of the first occurrence of element.\n\n\ninsert(index,element)\nInserts the given element at the specified index.\n\n\npop(index)\nRemoves and returns the element given at index. If no index is provided, it defaults to the last element.\n\n\nremove(element)\nRemoves the first occurrence of element in the list.\n\n\nreverse()\nReverses the order of the entire list.\n\n\nsort()\nSorts the list in place.3\n\n\n\n3 It modifies the original list. In contrast, the function sorted() will leave the original list unchanged.\nTo Do:\nIn the cell below you will find a list containing the speed of sound for several materials and at different temperatures. (in meters/second) Use the list methods in the table above to perform the following:\n\nThe speed of sound in Aluminum is \\(6420\\) m/s. Add two elements to the end of this list: the string “Aluminum” and its speed of sound. Do it two ways, first with append and then with extend.\nRemove the first two elements from this list.\nInsert the removed elements so they appear just after the entry for Helium.\nFind the index location for “Ethyl Alcohol”.\nUse the remove method to remove the entry for “Granite” and its associated speed.\nUse the extend method to append an entry for the speed of sound for “Steel” which is 5790 m/s.\n\n\na = [\"Air 0C\",331,\"Air 30C\",343, \"Helium 0C\",970,\"Ethyl Alcohol\",1170,\"Water 20C\",1480, \"Granite\",6000]\n\n\n5.2.3 Built-in functions for Lists\nPython has several built-in functions that will work with lists. Functions are called by placing the arguments to the function in parenthesis and prepending the name of the function to the parenthesis. Here are a few common functions that are used with lists: (the zip and enumerate functions will be explained in greater detail next chapter.)\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\nlen(list)\nReturns the number of elements in the list.\n\n\nmax(list)\nFinds the largest element in the list.\n\n\nmin(list)\nFinds the smallest element in the list.\n\n\nsum(list)\nReturns the sum of the elements in the list.4\n\n\nlistOne + listTwo\nJoins listOne with listTwo to form one list.\n\n\n2 * list\nRepeat list and concatenate to itself, making the list twice as long.\n\n\nzip(listOne,listTwo)\nZips two lists together. (Creates [(a1,b1),(a2,b2),...] from [a1,a2,a3...] and [b1,b2,b3...]\n\n\nenumerate(list)\nZips a list to the index value for that list (Creates [(0,a1),(1,a2),(2,a3)...] from [a1,a2,a3...]\n\n\n\n4 Only works if the list contains only ints and floats.\nTo Do:\nThe cell below contains two lists with strings in them and a third list that contains numbers. Use these lists to evaluate all of the functions from the table above, printing the result so that you can see what action was performed. Specifically, seek to answer the following questions:\n\nWhat happens when you find the max or min of a list of strings? (list of numbers?)\nWhat happens when you add two lists together? Does it matter if one list contains strings and the other numbers?\nWhat happens when you multiply a list by an integer? Does it matter if the list contains numbers vs strings?\nWhat happens when you zip two lists together? Does it matter if the list contains numbers or strings?\n\n\na = [\"l\",\"j\",\"n\"]\nb = [\"r\",\"s\",\"t\"]\nc = [4,7,8]\n\n\n5.2.4 The range function\nOften it will be necessary to generate a (possibly very long) list of integers. Instead of constructing the list by typing these numbers one by one, Python has a built-in function called range() that will do it for you. The range() function requires at least one argument to tell it how high the range should be.\n\na = range(10)  # Generate a list of integers up to 10\na\n\nrange(0, 10)\n\n\nThis output probably wasn’t what you expected. Instead of generating the full list of numbers, Python generates a range object that stands in place of it because it requires less memory. (Consider what might happen to your computer’s memory if you did range(1000000000000).) To force Python to generate the list, you can convert the range object into a list using the list() function.\n\na = range(10)  # Generate a list of integers up to 10\nlist(a)\n\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\nThe range function can be called with up to three arguments: range(start,end,stepsize). Consistent with indexing, the range includes the start value and excludes the end value. Below we generate a list of integers starting at 5, ending at 100 with a step size of 5.\n\nmyList = range(5,100,5)\nlist(myList)\n\n[5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95]\n\n\n\nTo Do:\nUse the range function to generate a list of even numbers from 8 to 88. (the list should include 88!)"
  },
  {
    "objectID": "chapters/listsAndTuples.html#tuples",
    "href": "chapters/listsAndTuples.html#tuples",
    "title": "5  Lists and Tuples",
    "section": "5.3 Tuples",
    "text": "5.3 Tuples\nTuples are another object type similar to lists except that they are immutable… that is to say, they cannot be modified once created. They look similar to lists except that they are created using parenthesis instead of brackets. Because you can’t change the elements of a tuple, they are often used so that you don’t inadvertently modify (and lose) critical data. You can think of it as locking a file on your computer to avoid inadvertently modifying it and losing the original content.\nBelow is a tuple containing the Balmer series, which are the wavelengths of visible light emitted by Hydrogen gas. These values are well known and you most likely wouldn’t want to make any modifications to this list which makes them a prime candidate for a tuple. Storing them in a tuple will help prevent you from inadvertently modifying the list. Indexing and slicing work exactly the same as with lists and strings, so we can still use the values inside of a tuple to perform simple calculations. There are only two methods associated with tuples: count(element) and index(element). Their usage is identical to the list methods.\n\nbalmer = (383.5384,388.9049,397.0072,410.174,434.047,486.133,656.272,656.2852)\nbalmer.index(410.174)\nlen(balmer)\n\n8\n\n\nYou can transform a list into a tuple using the tuple function.\nbalmer = [383.5384,388.9049,397.0072,410.174,434.047,486.133,656.272,656.2852]\n\nbalmerTup = tuple(balmer)"
  },
  {
    "objectID": "chapters/listsAndTuples.html#flash-cards",
    "href": "chapters/listsAndTuples.html#flash-cards",
    "title": "5  Lists and Tuples",
    "section": "5.4 Flash Cards",
    "text": "5.4 Flash Cards\n\nWhat is the difference between a list and a tuple?\nWhat is it called when the elements of a list are also lists?\nWhat is the index value of the first element in a list?\nHow do you access elements of a list counting from the back of the list forward? (Give an example.)\nWhat does it mean to “slice” a list?\nHow do you extract every third element of a list, starting at the second element and stopping at (but including) the 11th element?\nHow can you check to see if an element is present in a list? (Give an example)\nWhat does the range function do? (Give an example of how to use it.)\nWhat happens when you multiply a list and an integer?\nWhat happens when you add two lists together?\nExplain the usage of the extend list method.\nExplain the usage of the insert list method.\nExplain the usage of the remove list method.\nExplain the usage of the pop list method."
  },
  {
    "objectID": "chapters/listsAndTuples.html#exercises",
    "href": "chapters/listsAndTuples.html#exercises",
    "title": "5  Lists and Tuples",
    "section": "5.5 Exercises",
    "text": "5.5 Exercises\n\nThe code in the cell below will generate a list of 200 random integers in the range \\(0 \\rightarrow 15\\).\n\nVerify that there indeed are 200 numbers in the list (Use a function, don’t count them in your head.)\nHow many 7’s appear in the list? (Use a function, don’t count them by hand)\nWhat is the largest and smallest numbers that appear in the list?\nFind the index of the first occurrence of the number 1.\nSort the list and use a print statement to verify that you were successful.\n\n\nfrom random import randint\n\ndata = [randint(0,15) for x in range(200)]\n\nThe cell below contains a string containing some elementary particles in physics, with the names of the particles separated by commas.\n\nUse the split method to generate a list of particles.\nUse the len function to determine how many particles are in the list.\nsort the list and use a print statement to verify that the sort worked.\n\n\nparticles = \"up quark,down quark,charm quark,top quark,strange quark,bottom quark,electron,muon,tau,electron-neutrino,muon-neutrino,tau-neutrino,gluon,photon,z boson,w boson,higgs boson\"\n\n(Fibonacci Series) The Fibonacci series is a very famous sequence of numbers that appears repeatedly in nature. In the cell below you will find a list that contains the first seven Fibonacci numbers.\n\nStudy the sequence of numbers until you identify the pattern.\nOnce you know the pattern, use extend to add the next 10 Fibonacci numbers to the list.\nThe Fibonacci sequence has some very interesting properties (listed below). Add some code in the cell below to verify each of them.\n\nThe ratio of the last two numbers in the sequence gets closer and closer to the ‘Golden Ratio’ (1.618…) as the sequence gets longer. Calculate this ratio for short sequences and then increase the length of the sequence and watch the ratio approach 1.618…\nThe sum of any ten consecutive Fibonacci numbers is divisible by 11. Check this for at least three different length-ten slices.\nThe sum of the first \\(n\\) Fibonacci numbers is equal to the \\((n + 2)\\)-th Fibonacci number minus 1. Check this for at least three different values of \\(n\\).\n\n\n\nfibonacci = [1,1,2,3,5,8,13]"
  },
  {
    "objectID": "chapters/loops.html",
    "href": "chapters/loops.html",
    "title": "6  Loops",
    "section": "",
    "text": "Loops allow programs to rerun the same block of code multiple times. This might seem like a funny thing to want to do but it turns out that there are many important tasks that are repetitive in nature (perhaps with small changes for each successive repetition). A loop provides a succinct and efficient way to perform tasks of this nature."
  },
  {
    "objectID": "chapters/loops.html#for-loops",
    "href": "chapters/loops.html#for-loops",
    "title": "6  Loops",
    "section": "6.1 for loops",
    "text": "6.1 for loops\nThe for loop is probably the most common loop you will encounter and is a good choice when you know beforehand exactly what things you want to loop over. Here is an example of of for loop that is used to add up the elements of a list.\nthesum = 0\nfor i in [3,2,1,9.9]: \n    thesum += i\nThis would be equivalent to the following code:\nthesum = 0\n\nthesum = thesum + 3\nthesum = thesum + 2\nthesum = thesum + 1\nthesum = thesum + 9.9\nwhich isn’t that much longer than using a loop. However, as the list gets longer and/or the mathematical operations being performed get more complex the second method would get unreasonably long.\nThe correct language is to say that we are iterating over the list [3,2,1,9.9]. This means that the loop variable (i in this case but you can choose it to be whatever you want) gets assigned the values of the list elements, one by one, until it reaches the end of the list. You can use for loops to iterate over any multi-element object like lists or tuples. Python uses indentation to indicate where the loop ends. In this case there was only one statement inside to loop, but if you wanted more than one each line should be indented.\n\nTo Do:\n\nAdd a print statement inside of the loop above to display the value of the variable thesum.\nPredict what the output will be and then run the code and verify that you were correct.\nNow change the loop variable to be named physics and verify that the loop still works as expected.\n\n\nYou can iterate over range objects and strings using for loops.\n\nfor i in ['Physics', 'is','so','fun']: # Iterate over a list of strings\n    print(i)\n\nPhysics\nis\nso\nfun\n\n\n\nfor i in range(5,50,3):  #Generates a list from 5 -> 50 with a step size of 3\n    print(i)\n\n5\n8\n11\n14\n17\n20\n23\n26\n29\n32\n35\n38\n41\n44\n47\n\n\nThese examples are so simple that you might wonder when a loop might actually be useful to you. Let’s see if we can build a loop to calculate the following sum\n\\[ \\sum_{n=1}^{1000} {1\\over n^2} \\tag{6.1}\\]\n\ntheSum = 0\nfor n in range(1,1000):\n    theSum = theSum + 1/n**2\nprint(theSum)\n\n1.6439335666815615\n\n\nHere, n is being assigned the values 1,2,3,4....1000, one by one, until it gets all the way to 1000. Each time through the loop, n is different and the expression 1/n**2 evaluates to a new value. The variable theSum is updated each time through to be the running total of all calculations performed thus far. Here’s another example of a loop used to calculate the value of \\(20!\\):\n\ntheProduct = 1\nfor n in range(1,21):\n    theProduct = theProduct * n #Multiply theProduct by n\nprint(theProduct)\n\n2432902008176640000\n\n\nRemember that the range function creates a list starting at \\(1\\), going up to \\(21\\) but not including it. The math library has a function called factorial that does the same thing. Let’s use it to check our answer:\n\nfrom math import factorial\nfactorial(20)\n\n2432902008176640000\n\n\n\n6.1.1 Boolean Logic Inside Loops\nOften when using loops, we only want a block of code to execute when some condition is satisfied. We can use boolean logic inside of the loop to accomplish this. For example, let’s write a loop to compute the following sum:\n\\[ \\sum_{{n\\over 5} \\in \\text{ Int and } {n\\over 3} \\in \\text{ Int}} {1\\over n^2} \\]\nwhich is similar to the one we did above, but this time we only want to include terms where \\(n\\) is a perfect multiple of both 5 and 3. To check to see if n is a perfect multiple of a number we can calculate the modulo (remainder after division) using the % operator and check that it is equal to zero.\n\ntheSum = 0\nfor n in range(1,1000):\n    if n % 5 == 0 and n % 3 == 0:\n        theSum = theSum + 1/n**2\nprint(theSum)\n\n0.007243985583159138\n\n\n\nTo Do:\nPerform the following modifications to the loop above.\n\nIncrease the upper bound of the sum to go up to and include \\(5000\\).\nOnly include the terms where n is a multiple of 5 and 3 or is a multiple of 7.\nReplace the statement that updates theSum to its shorthand version.\n\n\n\n\n6.1.2 Zipping and Enumerating\nThere are times when it is necessary to iterate over two lists simultaneously. For example, let us say that we have a list of atomic numbers (AN) and a list of approximate atomic masses (mass) of the most abundant isotopes for the first six elements on the periodic table.\nAN = [1,2,3,4,5,6]\nmass = [1,4,7,9,11,12]\nIf we want to calculate the number of neutrons in each isotope, we need to subtract each atomic number from the atomic mass. To accomplish this, it would be nice to iterate over both lists simultaneously\n\n6.1.2.1 Zipping\nThe simplest way to iterate over two lists simultaneously is to combine both lists into a single, iterable object and iterate over it once. The zip function does just that by merging two lists or tuples into a nested list\n\nAN = [1,2,3,4,5,6]\nmass = [1,4,7,9,11,12]\n\nzipped = zip(AN,mass)\n\nfor pair in zipped:\n    print(pair[1] - pair[0])\n\n0\n2\n4\n5\n6\n6\n\n\nThe zip objects are “single use” so you can’t reuse zipped in a later loop. If the two lists being zipped are not the same length, zip stops zipping when it reaches the end of the shorter list.\n\nTo Do:\n\nPrint the variable zipped and inspect closely. Was the output what you expected?\n\nNow do print(tuple(zipped)) and inspect closely. Draw a conclusion.\nAdd a few more entries to the list named AN, but don’t add the corresponding entries to the other list. Now the lists being zipped aren’t the same length. Inspect the output of the print statement to determine what zip does in this scenario.\n\n\n\n\n6.1.2.2 Enumeration\nA close relative to zip is enumerate which zips a list to the index value for that list (read that last statement again). It also returns a “single use” object that can be iterated over.\n\nAN = [1,2,3,4,5,6]\nmass = [1,4,7,9,11,12]\n\nenum = enumerate(mass)\n\nfor idx,val in enum:\n    print(val - AN[idx])\n\n0\n2\n4\n5\n6\n6\n\n\n\nTo Do:\n\nRepeat the previous To-Dos for the cell above.\n\n\n\n\n\n6.1.3 List Comprehension\nIt is fairly common to use a for loop to populate a list with a sequence of numbers.\n\nmyList = []\n\nfor i in range(10):\n    myList.append(i**2)\n\nprint(myList)\n\n[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n\n\nThis entire process can be compressed down into a single line by expressing the for loop in square brackets. This is known as list comprehension. The code below will generate the list as above.\n\nmyList = [i**2 for i in range(10)]\nprint(myList)\n\n[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n\n\nList comprehension can take a little time to get used to but it is well worth it. It saves both time and space and makes code less cluttered. You can even add boolean expressions to your conditionals for further control of the final result.\n\nmyList = [i**2 for i in range(10) if i %2 == 0]  # Include only the evens.\nprint(myList)\n\n[0, 4, 16, 36, 64]\n\n\n\nTo Do:\nThink of your favorite mathematical function and modify the code above to generate a few samples from it."
  },
  {
    "objectID": "chapters/loops.html#while-loops",
    "href": "chapters/loops.html#while-loops",
    "title": "6  Loops",
    "section": "6.2 while Loops",
    "text": "6.2 while Loops\nLogic can be combined with loops using something called a while loop. A while loop is a good choice when you don’t know beforehand exactly how many iterations of the loop will be executed but rather want the loop to continue to execute until some condition is met. As an example, notice that in Equation 6.1, the terms in the sum get progressively smaller as \\(n\\) gets bigger. It doesn’t make sense to continue adding to the sum once the terms get very small. Let’s compute this sum by looping until the fraction \\({1 \\over n^2}\\) become smaller than \\(1 \\times 10^{-2}\\).\nterm = 1  # Load the first term in the sum\ns = term  # Initialize the sum\nn = 1     # Set a counter\nwhile term > 1e-2:  # Loop while term is bigger than 1e-2\n    n = n +  1        #Add 1 to n so that it will count: 2,3,4,5\n    term = 1./n**2    # Calculate the next term to add\n    s = s +  term     # Add 1/n^2 to the running total\nThis loop will continue to execute until term<1e-2. Note that unlike the for loop, here you have to do your own counting if you need to know how many iterations have been performed. Be careful about what value n starts at and when it is incremented (n = n + 1). Also notice that term must be assigned prior to the start of the loop. If it wasn’t the loop’s first logical test would fail and the loop wouldn’t execute at all.\n\nTo Do:\n\nDecrease the threshold on the termination condition and observe any changes in the final result and how many more iterations are performed.\n\nAfter toying around with it for a while pick a termination condition that you feel will produce a result that is accurate.\n\n\nwhile loops should be used with caution because you can easily write a faulty termination condition and inadvertently write a loop that runs forever. This happens because your termination condition was never met. An example of this is given below.\nWarning: Do not execute the code block below!!\nx = 0\n\nwhile x != 10:\n    x = x + 3\nprint(\"Done\")\nThe loop above is intended to end after a few iterations when the value of x is equal to 10. However, closer inspection reveals that the value of x will never be equal to 10. After the first iteration x is equal to 3, then 6,9,12,15 and so on… but never 10. This loop will run forever because the termination condition is never met (x != 10 never produces a False)!! If you choose to use a while loop, triple check your termination condition to make sure you haven’t made a mental error. Avoiding the use of != or == in your termination condition will help too. Use <= or >= instead.\n\nTo Do:\n\nModify the termination condition in the loop above so that it terminates when x gets larger than 15.\nRun the code and verify that you did it correct."
  },
  {
    "objectID": "chapters/loops.html#continue-break-and-pass-commands",
    "href": "chapters/loops.html#continue-break-and-pass-commands",
    "title": "6  Loops",
    "section": "6.3 continue, break, and pass Commands",
    "text": "6.3 continue, break, and pass Commands\nThe continue, break, and pass commands are used to control the flow of code execution in loops. Here is a description of their usage:\n\n\n\n\n\n\n\nOperator\nDescription\n\n\n\n\nbreak\nExits a for/while loop.\n\n\ncontinue\nSkips the remaining loop block and begins the next iteration.\n\n\npass\nNo action; code contiues on\n\n\n\nThe break statement is useful when you want to completely stop a loop early. Here is our sum loop rewritten with a break statement added to stop the loop after 1000 iterations.\n\nterm = 1  # Load the first term in the sum\ns = term  # Initialize the sum\nn = 1     # Set a counter\nwhile term > 1e-10:  # Loop while term is bigger than 1e-10\n    n +=  1        #Add 1 to n so that it will count: 2,3,4,5\n    term = 1./n**2    # Calculate the next term to add\n    s += term     # Add 1/n^2 to the running total\n    if n > 1000:\n        print('This is taking too long. I''m outta here...')\n        break\n\nThis is taking too long. Im outta here...\n\n\nThe continue statement is similar to break except that instead of stopping the loop, it only stops the current iteration of the loop. All code below the continue statement will be skipped and the next iteration will begin. For example, if you wanted to do the sum from equation ?? but only include those terms for which n is a multiple of 3, it could be done like this:\nterm = 1  # Load the first term in the sum\ns = term  # Initialize the sum\nn = 1     # Set a counter\nwhile term > 1e-10:  # Loop while term is bigger than 1e-10\n    n +=  1        #Add 1 to n so that it will count: 2,3,4,5\n    if n % 3 != 0:\n        continue\n    term = 1./n**2    # Calculate the next term to add\n    s += term     # Add 1/n^2 to the running total\nNow, when the value of n is not a multiple of 3, the sum will not be updated and the associated terms are effectively skipped.\nFinally, the pass statement does nothing. Seriously!! It is merely a place holder for code that has not bee written yet. Usually, you’ll use the pass statement to run and test code without errors due to missing code."
  },
  {
    "objectID": "chapters/loops.html#flash-cards",
    "href": "chapters/loops.html#flash-cards",
    "title": "6  Loops",
    "section": "6.4 Flash Cards",
    "text": "6.4 Flash Cards\n\nExplain the basic structure and key elements of a for loop.\nExplain the basic structure and key elements of a while loop.\nWhat does the break statement do?\nWhat does the continue statement do?\nWhat does the pass statement do?\nWhat does the zip function do? Give an example.\nWhat does the enumerate function do? Give an example.\nWhat is list comprehension? Give an example."
  },
  {
    "objectID": "chapters/loops.html#exercises",
    "href": "chapters/loops.html#exercises",
    "title": "6  Loops",
    "section": "6.5 Exercises",
    "text": "6.5 Exercises\n\nSummations appear often in science and mathematics. One such summation is called the Riemann Zeta function and is given by \\[ \\zeta(n) = \\sum_{k=1}^\\infty {1\\over k^n} = {1\\over 1^n} + {1\\over 2^n} + {1\\over 3^n} + \\dots\\]\n\nUse a for loop to evaluate \\(\\zeta(2)\\) and \\(\\zeta(4)\\) and verify that \\(\\zeta(2) = {\\pi^2 \\over 6}\\) and \\(\\zeta(4) = {\\pi^4 \\over 90}\\). This summation is called an infinite sum and we surely don’t want our loop to continue forever!! Instead, an infinite sum like this one can be approximated with a for loop with a large number of iterations. To determine if you have included enough terms, increase the number of terms steadily and watch for the final result to stop changing appreciably.\nNow repeat part 1 using list comprehension and the sum function?\nRepeat the exercise one final time using a while loop. Write the while loop so that it stops iterating when the value of \\({1\\over k^n}\\) gets smaller than \\(1 \\times 10^{-6}\\).\n\nA transcendental equation is one that cannot be solved analytically (with pencil and paper). Try solving the following equation for x to see what I mean: \\[ {\\sin x \\over x} = 1\\] One numerical method for solving an equation like this involves first rearranging it to look like this: \\[ x = \\sin x\\] and then using a loop to repeatedly evaluating the right hand side, using the result of the previous evaluation as the input, until subsequent evaluations differ very little (\\(1 \\times 10^{-3}\\) would be fine). 1 The first few iterations of this process might look something like this: \\[(x_\\text{old})_1 = 2 \\text{ (starting guess)}\\] \\[(x_\\text{new})_1 = \\sin((x_\\text{old})_1)\\] \\[(x_\\text{old})_2 = (x_\\text{new})_1\\] \\[(x_\\text{new})_2 = \\sin((x_\\text{old})_2)\\] \\[(x_\\text{old})_3 = (x_\\text{new})_2\\] \\[(x_\\text{new})_3 = \\sin((x_\\text{old})_3)\\]\n\nUse a while loop to solve this equation and report the correct value for x.\n\nPlug the answer back into the equation to verify that it indeed does satisfy the equation.\nReport how many iterations it took to solve the problem.\nDecrease the value in the termination condition and observe how the number of iterations and the accuracy of the answer change.\n\nHint: You’ll have to define two variables: one to hold the old guess and one to hold the updated guess. Initialize these variables to any old values but make sure that they aren’t equal or your stopping criteria will trigger on the first iteration and the loop won’t run at all.\n\n1 This is called successive relaxation.xold = 2 # starting guess\n\nAn object that is dropped/thrown from a high altitude and allowed to fall through the air will experience a drag force that is opposite its motion. Because of that drag force, the velocity of the particle will not increase forever, but instead approach a constant velocity (called terminal velocity). The function that describes the velocity of the particle as a function of time is given by \\[ v(t) = -{mg \\over c} + \\left( {m g \\over c} + v_0\\right) e^{-c t \\over m}\\] and the terminal velocity is given by \\[v_t = \\sqrt{m g \\over c}\\] where \\(m\\) is the mass of the projectile, \\(c\\) is the drag constant, \\(g= 9.8\\) m/s\\(^2\\) is the acceleration due to gravity, \\(v_0\\) is the initial velocity of the particle, and \\(t\\) is time.\n\nUse a while loop to calculate the velocity of the particle at \\(0.1\\) second time intervals, starting at \\(t = 0\\).\nThe loop should terminate when the velocity of the particle achieves \\(90\\%\\) of terminal velocity.\nUse a print statement to display the amount of time that has elapsed before reaching \\(90\\%\\) of terminal velocity.\nHypothesize about what might happen if you increased or decreased the mass of the object, while leaving all other physical parameters fixed. Then modify your code and see if your guess was right.\nHypothesize about what might happen if you increased or decreased the drag constant (c) for the object, while leaving all other physical parameters fixed. Then modify your code and see if your guess was right.\n\n\nfrom math import exp,sqrt\nm = 20\ng = 9.8\nc = 0.75\nv0=0"
  },
  {
    "objectID": "chapters/functions.html",
    "href": "chapters/functions.html",
    "title": "7  Functions",
    "section": "",
    "text": "We have already been using functions here and there but in this chapter we will introduce them formally and get into the details. A function encapsulates a block of code designed to perform a specific task or set of tasks. To perform the task correctly, most functions require that you provide some information (called arguments) when you call them. To call a function you type the name of the function followed by the needed arguments enclosed in parenthesis (()).\nThe number and type of arguments allowed is different for every function. As a first example, let’s consider the print function, which is the simplest (and most familiar) function that we have used so far.\nPython functions generally fall into three groups: functions that come standard with Python (called native functions), functions that you can import into Python, and functions that you write yourself."
  },
  {
    "objectID": "chapters/functions.html#native-functions",
    "href": "chapters/functions.html#native-functions",
    "title": "7  Functions",
    "section": "7.1 Native Functions",
    "text": "7.1 Native Functions\nThere are a few functions that are always ready to go whenever you run Python. They are included with the programming language. We call these functions native functions. You have already been using some of them, like these\nmyList = [5,6,2,1]\na = len(myList)  # 'len' function is native.\n\nb = float(5) # 'float' function is native.\n\nc = str(67.3)  # 'str' function is native.\nThe len, float and str functions are all native and they all take a single argument. Other native function have been mentioned in previous chapters and others will be mentioned in the future."
  },
  {
    "objectID": "chapters/functions.html#imported-functions",
    "href": "chapters/functions.html#imported-functions",
    "title": "7  Functions",
    "section": "7.2 Imported Functions",
    "text": "7.2 Imported Functions\nMany times, you will need to go beyond what Python can do by itself2. However, that doesn’t mean you have to create everything you need to do from scratch. Most likely, the function that you need has already been coded. Somebody else created the function and made it available to anyone who wants it. Groups of functions that perform similar tasks are typically bundled together into libraries ready to be imported so that the functions that they contain can be used.2 For example, Python does not include \\(\\sin()\\) or \\(\\cos()\\) as Native functions.\nIn order to use use a function correctly, you’ll need to know what information(arguments) the function expects you to give it and what information the function intends to return to you as a result. This information can be found in the library’s documentation. Most libraries have great documentation with lists of the included functions, what the functions do, the expected arguments, and examples on how to use the most common ones. You can usually find the library documentation by searching the internet for the library’s name plus “Python documentation”.\nProviding a complete list of all available libraries and function is not really the purpose of this book. Instead, we’ll illustrate how to import functions and use them. As you use Python more and more you should get in the habit of searching out the appropriate library to accomplish the task at hand. When faced with a task to accomplish, your first thought should be, “ I’ll bet somebody has already done that. I’m going to try to find that library.”\nFunctions are imported using the import statement. You’ve already seen how to perform very simple mathematical calculations (\\(5/6\\),\\(84\\), etc..), but for more complex mathematical calculations like \\(\\sin( {\\pi \\over 2} )\\) or \\(e^{2.5}\\) , you’ll need to import these functions from a library.\nimport math\n\na = math.sqrt(5.2)\nb = math.sin(math.pi)\nc = math.e**2.5\nThe math. before each function is equivalent to telling Python “Use the sqrt() function that you will find in the math book I told you to grab.” If you just type\nsqrt(5.2)\nPython won’t know where to find the sqrt function and an error message will result. Sometimes the name of the module can be long and typing module. every time you want to use one of it’s functions can be cumbersome. One way around this is to rename the module to a shorter name using the as statement.\nimport math as mt\n\na = mt.sqrt(5.2)\nb = mt.sin(mt.pi)\nc = mt.e**2.5\nInstead of importing an entire module, you can import only a selection of functions from that module using the from statement. This can make your code even more succinct by eliminating the module. prefix altogether. The trade-off is that it won’t be as clear which function belongs to which module.\nfrom math  import sqrt, sin, pi, e\n\na = sqrt(5.2)\nb = sin(pi)\nc = e**2.5\nAll of the functions belonging to a module can be imported at once using *.\nfrom math import *\n\na = sqrt(5.2)\nb = sin(pi)\nc = e**2.5"
  },
  {
    "objectID": "chapters/functions.html#user-defined-functions",
    "href": "chapters/functions.html#user-defined-functions",
    "title": "7  Functions",
    "section": "7.3 User-defined Functions",
    "text": "7.3 User-defined Functions\nAfter having programmed for a while, you will notice that certain tasks get repeated frequently. For example, maybe in your research project you need to calculate the force exerted on an atom due to many other nearby atoms. You could copy and paste your force-calculation code every time it was needed, but that would likely result in lots of extra code and become very cumbersome to work with. You can avoid this by creating your own function to calculate the force between any two atoms. Then, every time you need another force calculation, you simple call the function again. You only write the force-calculation part of the code once and then you execute it as many times as you need to.\nTo create your own function, you first need to name the function. The name should be descriptive of what it does and makes sense to you and anyone else who might use it. The first line of a function definition starts with the def statement (short for definition) followed by the name of the function with whatever information, called arguments, that needs to be fed into the function enclosed in parenthesis. The last character in this line must be a colon. Everything inside the function is indented four spaces and placed directly below the first line.\ndef functionName(arg1,arg2,arg3):\n    # Body of Function\n    # Body of Function\n    # Body of Function\nAs an example, let’s construct a function that calculates the distance between two atoms. The function will need to know the location of each atom, which means that there should be two arguments: the xyz coordinates of both atoms passed as a pair of lists or tuples.\n\nimport math\n\ndef distance(coords1,coords2):\n\n    dx = coords1[0] - coords2[0]\n    dy = coords1[1] - coords2[1]\n    dz = coords1[2] - coords2[2]\n    d = math.sqrt(dx**2 + dy**2 + dz**2)\n    print(f\"The distance is {d:5.4f}.\")\n\ndistance([1,2,3],[4,5,6])\n\ndistance([4.2,9.6,4.8],[2.9,2.6,3.4])\n\nThe distance is 5.1962.\nThe distance is 7.2560.\n\n\nThis function works just fine with integers or floats for the coordinates.\n\n7.3.1 The return statement\nThe distance function prints out the value for the distance, but what if we want to use this distance in a subsequent calculation? Maybe we want to calculate the average distance between several pairs of atoms. We can instruct the function to return the final distance using the return statement. If the arguments to the function are the inputs, the return statement specifies what the output is. Let’s modify the function above to include a return statement.\n\nimport math\ndef distance(coords1,coords2):\n    dx = coords1[0] - coords2[0]\n    dy = coords1[1] - coords2[1]\n    dz = coords1[2] - coords2[2]\n    d = math.sqrt(dx**2 + dy**2 + dz**2)\n    return d\n\ndistOne = distance([1,2,3],[4,5,6])\n\ndistTwo = distance([4.2,9.6,4.8],[2.9,2.6,3.4])\n\naverageDistance = (distOne + distTwo)/2\n\nprint(f\"The average distance is {averageDistance:5.4f}.\")\n\nThe average distance is 6.2261.\n\n\n\n\n7.3.2 Local vs Global Variable Scope\nVariables created inside of a function have local scope. This means that they are not accessible outside of the function. In our distance function the variables dx,dy,dz, and d were all local variables that are used inside the function but have no value outside of it. This is convenient because we don’t have to worry about overwriting a variable or using it twice. If someone sends you a function and you want to use it in your code, you don’t have to worry about what variable he/she chose to use inside his function; they won’t affect your code at all.\ndef distance(coords1,coords2):\n    dx = coords1[0] - coords2[0]\n    dy = coords1[1] - coords2[1]\n    dz = coords1[2] - coords2[2]\n    d = math.sqrt(dx**2 + dy**2 + dz**2)\n    return d\n\ndistOne = distance([1,2,3],[4,5,6])\n\nprint(dx)  # There is no value associated with this variable outside of the function.\nThe down side to all of this is that you don’t have access to function variables unless you pass them out of the function using the return statement.\nAny variables defined outside of a function is called a global variable, which means that Python remembers these assignments from anywhere in your code including inside of functions. Using global variables with the intention to use them inside of functions is usually considered bad form and confusing and is discouraged. One notable exception to this rule are physical constants like \\(g = 9.8\\) m/s\\(^2\\) (acceleration due to gravity on Earth) or \\(k_B = 1.38 \\times 10^{-23}\\) (Boltzmann’s constant which is used heavily in thermodynamics) because these values will never change and may be used repeatedly. Generally speaking every variable that is used in a function ought to be either i) passed in as an argument or ii) defined inside of the function. Below is an example of an appropriate use of a global variable.\ndef myFunction(a,b):\n    c=a+g # <--- Notice the reference to 'g' here \n    d = 3.0 * c\n    f = 5.0 * d**4\n    return f\n\n#The variable below are global variables. \nr = 10\nt = 15\ng = 9.8         #<--- g defined to be a global variable\nresult = myFunction(r,t)\n\n\n7.3.3 Positional vs. Keyword Arguments\nThe function arguments we have been using so far are called positional arguments because they are required to be in a specific position inside the parenthesis. To see what I mean consider the example below.\n\ndef example(a,b):\n    return a**b\n\n\nresultOne = example(5,2)\nresultTwo = example(2,5)\n\nprint(resultOne, resultTwo)\n\n25 32\n\n\nIn the first call to example the local variable a gets assigned to be 5 and the local variable b gets assigned 2. In the second call the order of the arguments is switched and the subsequent assignments to a and b switch with it. This produces a different result from the function. Positional arguments are very common but the user must know what information goes where when calling the function.33 This is another reason why you want to choose meaningful variable names for your arguments.\nThe other type of argument is the keyword argument. These arguments are attached to a keyword inside of the parenthesis. The advantage of a keyword argument is that the user does not need to be concerned about the location of the argument as long as it has the proper label.\n\ndef example(a=1,b=2):\n    return a**b\n\n\nresultOne = example(a=5,b=2)\nresultTwo = example(b=2,a=5)\n\nprint(resultOne, resultTwo)\n\n25 25\n\n\nAnother advantage to using keyword arguments is that a default value can be coded into the function. This means that we can call the function with some arguments missing and default values will be used for them. In the example above, the default value of b is 2 and if the function is called without specifying a value for that argument, the function will proceed as usual using the default value for b.\n\ndef example(a=1,b=2):\n    return a**b\n\n\nresult = example(a=5)\n\nprint(result)\n\n25\n\n\n\n\n7.3.4 Lambda Functions\nWhen the function you want to construct is very simple (one line), there is a shortcut code for making it called a lambda function. The benefit is that they occupy less lines of code than the standard def functions. A lambda function is defined as shown below with the variable immediately after the lambda statement as the independent variable in the function.\n\nf = lambda x: x**2\n\nprint(f(5))\n\n25\n\n\nAs a simple application of lambda functions let’s consider a function from the scipy.integrate library called quad which will perform a numerical integration of a function. The quad function takes three arguments: the function to be integrated, and the upper and lower bound on the integral. We can use a lambda function for the first argument rather than using several lines of code to build one in the traditional fashion.\n\nfrom scipy.integrate import quad\nfrom math import sin, pi\n\nquad(lambda x: sin(pi * x)**2,0,0.4 )\n\n(0.15322553581056808, 1.7011451781741914e-15)"
  },
  {
    "objectID": "chapters/functions.html#flash-cards",
    "href": "chapters/functions.html#flash-cards",
    "title": "7  Functions",
    "section": "7.4 Flash Cards",
    "text": "7.4 Flash Cards\n\nDescribe the basic structure and key elements of a user-defined function.\nWhat are function arguments?\nList all of the ways that a function can be imported from a module.\nWhat does the return statement do?\nWhat is the difference between a local and global variables?\nWhat is a keyword argument? Give an example.\nWhat is a lambda function? How do you make one?"
  },
  {
    "objectID": "chapters/functions.html#exercises",
    "href": "chapters/functions.html#exercises",
    "title": "7  Functions",
    "section": "7.5 Exercises",
    "text": "7.5 Exercises\n\nA wooden block is placed on a horizontal surface and pushed across the floor with an initial velocity of \\(v_0\\). The expression for the position of the block after \\(t\\) seconds have elapsed is \\[x(t) = v_0 t - {1\\over 2} \\mu g t^2\\] where \\(\\mu\\) is the coefficient of friction and \\(g = 9.8\\) m/s\\(^2\\). You can easily calculate the time it takes for the block to come to rest to be \\[ T = {v_0 \\over \\mu g}\\]. Write a function that takes the coefficient of friction and initial velocity as arguments and returns the total distance traveled while coming to rest.\n\nCall the function for \\(v_0 = 7.2\\) m/s and the following values of \\(\\mu = 0.62,0.3,0.45,0.2\\)\nUse list comprehension to put these travel distances into a list."
  },
  {
    "objectID": "chapters/numpy.html",
    "href": "chapters/numpy.html",
    "title": "8  The numpy module",
    "section": "",
    "text": "Numpy (pronounced “num”-“pie”) is a popular Python library that is heavily used in the scientific/mathematical community. So much so that numpy is typically included as part of the standard bundle of libraries that comes with your Python installation. The functions inside numpy will allow you to solve problems with less effort and will produce faster-executing code."
  },
  {
    "objectID": "chapters/numpy.html#numpy-arrays",
    "href": "chapters/numpy.html#numpy-arrays",
    "title": "8  The numpy module",
    "section": "8.1 Numpy Arrays",
    "text": "8.1 Numpy Arrays\nYou are already familiar with Python lists but may not have noticed that they are not suitable for mathematical calculations. For example, attempting to multiply a list by a scalar or evaluate a mathematical function like \\(\\sin()\\) on a list will not produce a mathematical result or may produce an error. For example, consider the following code.\n\nmyList = [4,5,7]\n\nnewList = 2 * myList\nprint(newList)\n\n[4, 5, 7, 4, 5, 7]\n\n\nYou probably expected newList to be [8,10,14] but multiplying a list by a number doesn’t do that. Instead it repeats the list and concatenates it to itself. To multiply each element of a list by a number you must use a for loop.\n\nmyList = [4,5,7]\n\nnewList = []\nfor i in myList:\n    newList.append(i* 2)\n\nprint(newList)\n\n[8, 10, 14]\n\n\nbut this seems overly cumbersome for such a simple task. Numpy ndarrays (short for n-dimensional arrays) or just arrays make this task much simpler. Arrays are similar to lists or nested lists except that mathematical operations and numpy functions (but not math functions) automatically propagate to each element instead of requiring a for loop to iterate over it. Because of their power and convenience, arrays are the default object type for any operation performed with NumPy."
  },
  {
    "objectID": "chapters/numpy.html#array-creation",
    "href": "chapters/numpy.html#array-creation",
    "title": "8  The numpy module",
    "section": "8.2 Array Creation",
    "text": "8.2 Array Creation\n\n8.2.1 Type Conversion from List\nYou can create an array from a list using numpy’s array function. The list that is to be converted is the argument to the array function. Mathematical operations can then be performed on the array and that operation will propagate through to all of the elements.\n\nfrom numpy import array\n\nmyArray = array([4,5,7])\n\nnewArray = 2 * myArray \n\nprint(newArray)\n\n[ 8 10 14]\n\n\nNested lists, or lists that contain lists as their elements, can be converted to multi-dimensional arrays using the array function.\n\nfrom numpy import array\nmyArray = array([[1,2,3],[4,5,6]])\n\nprint(myArray)\n\n[[1 2 3]\n [4 5 6]]\n\n\n\n\n8.2.2 The arange and linspace Functions\nNumpy has some sequence-generating functions that generate arrays by specifying start, stop, and step size values similar to the way range generates a list. The two most common ones are arange and linspace. The arange function behaves very similar to the native Python range function with a few notable exceptions:\n\narange produces an array whereas range produces a list.\nThe step size for arange does not need to be an integer.\nrange produces an iterator and arange generates a sequence of values immediately.\n\nThe arguments to arange are similar to range\narange(start,stop,step)\nThe linspace function is related to the arange function except that instead of specifying the step size of the sequence, the sequence is generated based on the number of equally-spaced points in the given span of numbers. Additionally, arange excludes the stop value while linspace includes it. The difference between these two functions is subtle and the use of one over the other often comes down to user preference or convenience.\nlinspace(start,stop,number of points)\nBelow is an example that shows the usage of linspace and arange.\n\nfrom numpy import linspace,arange\n\nmyArray = linspace(0,10,20)\nmyArray2 = arange(0,10,0.5)\nprint(myArray)\nprint(myArray2)\n\n[ 0.          0.52631579  1.05263158  1.57894737  2.10526316  2.63157895\n  3.15789474  3.68421053  4.21052632  4.73684211  5.26315789  5.78947368\n  6.31578947  6.84210526  7.36842105  7.89473684  8.42105263  8.94736842\n  9.47368421 10.        ]\n[0.  0.5 1.  1.5 2.  2.5 3.  3.5 4.  4.5 5.  5.5 6.  6.5 7.  7.5 8.  8.5\n 9.  9.5]\n\n\nWhen using linspace you may still want to know what the sequence spacing is. You can request that linspace provide this information by adding the optional argument retstep = True to the argument list. With this addition, linspace not only returns the sequence to you, but also the stepsize.\n\nfrom numpy import linspace,arange\n\nmyArray,mydx = linspace(0,10,20,retstep= True)\nprint(mydx)\nprint(myArray)\n\n0.5263157894736842\n[ 0.          0.52631579  1.05263158  1.57894737  2.10526316  2.63157895\n  3.15789474  3.68421053  4.21052632  4.73684211  5.26315789  5.78947368\n  6.31578947  6.84210526  7.36842105  7.89473684  8.42105263  8.94736842\n  9.47368421 10.        ]\n\n\nTwo other useful functions for generating arrays are zeros and ones which generate arrays populated with exclusively ones or zeros. The functions require shape arguments as a tuple or list to specify the shape of the array.\nzeros((rows,columns))\nIf the array to be created is only one dimensional, the argument can be a single number instead of a tuple.\nzeros(n)\n\nfrom numpy import zeros,ones\n\nmyArray = zeros([3,4])\nmyArray2 = ones(5)\nprint(myArray)\nprint(myArray2)\n\n[[0. 0. 0. 0.]\n [0. 0. 0. 0.]\n [0. 0. 0. 0.]]\n[1. 1. 1. 1. 1.]\n\n\nArrays of any constant (not just one or zero) can then be easily generated by performing the needed math on the original array.\n\nfrom numpy import zeros,ones\n\nmyArray = zeros([3,4]) + 5\nmyArray2 = ones(5) * 12\nprint(myArray)\nprint(myArray2)\n\n[[5. 5. 5. 5.]\n [5. 5. 5. 5.]\n [5. 5. 5. 5.]]\n[12. 12. 12. 12. 12.]\n\n\n\n\n8.2.3 Arrays from Functions\nA third approach is to generate an array from a function using the fromfunction function which generates an array of values using the array indices as the inputs. Ths function requires two arguments: the name of the function being used and the shape of the array being generated.\nfromfunction(function, shape)\nLet’s make a 3 x 3 array where each element is the product of the row and column indices:\n\nfrom numpy import fromfunction\n\ndef prod(x,y):\n    return x * y\n\nmyArray = fromfunction(prod,(3,3))\nprint(myArray)\n\n[[0. 0. 0.]\n [0. 1. 2.]\n [0. 2. 4.]]\n\n\nThe table below gives a summary of useful functions for creating numpy arrays. The required arguments are also described.\n\nCommon functions for generating arrays\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\nlinspace(start,stop,n)\nReturns an array of n evenly-spaced points begining at start and ending at stop.\n\n\narange(start,stop,dx)\nReturns an array beginning at start,ending at stop with a step size of dx.\n\n\nempty(dims)\nReturns an empty array with dimensions dim.\n\n\nzeros(dims)\nReturns an array of zeros with dimensions dim.\n\n\nones(dims)\nReturns an array of ones with dimensions dim.\n\n\nzeros_like(arr)\nReturns an array of zeros with dimensions that match the dimensions of arr.\n\n\nfromfunction(function,dims)\nReturns an array of numbers generated by evaluating function on the indices of an array with dimensions dims.\n\n\ncopy(arr)\nCreates a copy of array arr.\n\n\ngenfromtext(file)\nReads file and loads the text into an array (file must only contain numbers)."
  },
  {
    "objectID": "chapters/numpy.html#accessing-and-slicing-arrays",
    "href": "chapters/numpy.html#accessing-and-slicing-arrays",
    "title": "8  The numpy module",
    "section": "8.3 Accessing and Slicing Arrays",
    "text": "8.3 Accessing and Slicing Arrays\nAccessing and slicing arrays can be done in exactly the same way as is done with lists. However, there is some additional functionality for accessing and slicing arrays that do not apply to lists.\n\n8.3.1 One-dimensional Arrays\nElements from a one-dimensional array can be extracted using square brackets ([]) just like we have done with lists.\n\nfrom numpy import array\n\nmyArray = array([3,4,7,8])\nprint(myArray[2])\n\n7\n\n\n\n\n8.3.2 Multi-dimensional Arrays\nMulti-dimensional array can be indexed in a similar fashion to nested lists, but because we often encounter multi-dimensional arrays there is a shortcut that makes the syntax simpler and more convenient. Let’s consider a two-dimensional array as an example. To access the entire second row of the array, provide the row index in square brackets just as with one-dimensional arrays.\n\nfrom numpy import array\nmyArray = array([[1,2,3],[4,5,6], [7,8,9]])\n\nprint(myArray[1])\n\n[4 5 6]\n\n\nTo access the second element in the second row, we can add another set of square brackets with the appropriate index inside, just as we did with nested lists. However, for convenience the second set of square brackets can be omitted and the row and column indices can be placed next to each other and separated by a comma.\narray_name[row,column]\n\nfrom numpy import array\nmyArray = array([[1,2,3],[4,5,6], [7,8,9]])\n\nprint(myArray[1][1])  # This works, but is a bit hard on the eyes\nprint(myArray[1,1])  # This works also and is easier to look at.\n\n5\n5\n\n\n\n\n8.3.3 Accessing Multiple Elements\nMultiple elements of an array can be accessed using a list for the index instead of a single number.\n\nfrom numpy import array\n\nmyArray = array([1,2,3,4,5,6,7,8,9,10])\n\nprint(myArray[2])  # Extract element 2\nprint(myArray[ [3,6,9] ])  # Extract elements 3, 6, and 9.\n\n3\n[ 4  7 10]\n\n\nThis can even be done with multi-dimensional arrays. If the index is a single list, the corresponding rows will be extract. If the corresponding list of columns is added to the index list, individual elements will be extracted.\narray_name[[rows]]  # Access set of rows\narray_name[[rows], [columns]]  # Access set of elements\n\nfrom numpy import array\nmyArray = array([[1,2,3],[4,5,6], [7,8,9]])\n\nprint(myArray[[0,1]]) # Extract rows 0 and 1.\n\nprint(myArray[[1,2,0],[0,2,2]])   # Extract elements (1,0), (2,2), and (0,2)  \n\n[[1 2 3]\n [4 5 6]]\n[4 9 3]"
  },
  {
    "objectID": "chapters/numpy.html#slicing-arrays",
    "href": "chapters/numpy.html#slicing-arrays",
    "title": "8  The numpy module",
    "section": "8.4 Slicing Arrays",
    "text": "8.4 Slicing Arrays\n\n8.4.1 Multi-dimensional Arrays\nWe’ve already shown you how to slice a list using the : operator. The same can be done with arrays. However, for 2D (and higher) arrays the slicing is more powerful (intuitive). It can be helpful to visualize an array as a matrix, even if it is not being treated that way Mathematically. For example, let’s say that you define the following array:\nfrom numpy import array\nmyArray = array([[1,2,3],[4,5,6], [7,8,9]])\nwhich can be visualized as the following matrix:\n\\[\n\\begin{pmatrix}\n1&2&3\\\\\n4&5&6\\\\\n7&8&9\\\\\n\\end{pmatrix}\n\\]\nTo slice out the following \\(2\\) x \\(2\\) sub matrix:\n\\[\n\\begin{pmatrix}\n5&6\\\\\n8&9\\\\\n\\end{pmatrix}\n\\]\nwe could do\n\nfrom numpy import array\nmyArray = array([[1,2,3],[4,5,6], [7,8,9]])\n\nprint(myArray[1:3,1:3])\n\n[[5 6]\n [8 9]]\n\n\nTo include all of the elements in a given dimension, use the : alone with no numbers surrounding it.\n\nfrom numpy import array\nmyArray = array([[1,2,3],[4,5,6], [7,8,9]])\n\nprint(myArray[:,1:3])  # Extract all rows with columns 1 and 2\n\n[[2 3]\n [5 6]\n [8 9]]\n\n\n\n\n8.4.2 Boolean Slicing\nBoolean operations can be evaluated on arrays to produce corresponding arrays of booleans. The boolean array can then be used to index the original array and extract elements that meet some criteria.\n\nfrom numpy import array\n\na = array([1,2,3,4,5,6])\n\nboolArray = a > 2\n\nprint(boolArray)\n\nprint(a[boolArray])\n\n[False False  True  True  True  True]\n[3 4 5 6]\n\n\nThis also works on multi-dimensional arrays although the result is always one-dimensional regardless of the shape of the original array.\n\nfrom numpy import array\nmyArray = array([[1,2,3],[4,5,6], [7,8,9]])\n\nprint(myArray[myArray>2]) # Extract elements that are greater than 2.\n\n[3 4 5 6 7 8 9]"
  },
  {
    "objectID": "chapters/numpy.html#vectorization-and-broadcasting",
    "href": "chapters/numpy.html#vectorization-and-broadcasting",
    "title": "8  The numpy module",
    "section": "8.5 Vectorization and Broadcasting",
    "text": "8.5 Vectorization and Broadcasting\nA major advantage of numpy arrays over lists is that operations vectorize across the arrays. This means that mathematical operations propagate through the array instead of requiring a for loop. This speeds up the calculation and makes code easier to write and read. Simple mathematical operations like adding, subtracting, etc can be performed on arrays as you would expect and the operation propagates through to all elements.\n\nfrom numpy import array\n\na = array([1,2,3])\nb = array([4,5,6])\n\nc = a + b\nd = a**2\ne = 2 * b\nf = 2/b\ng = a * b\n\nprint(c,d,e,f,g)\n\n[5 7 9] [1 4 9] [ 8 10 12] [0.5        0.4        0.33333333] [ 4 10 18]\n\n\nAll of the common mathematical operations that you learned for numbers now apply to arrays. Cool!\n\n8.5.1 Numpy Functions\nThe numpy library has a massive collection of vectorized mathematical functions and these functions should be used instead of similar functions from other libraries that are not vectorized (like math).\n\nfrom numpy import array\nfrom numpy import sqrt as nsqrt\nfrom math import sqrt as mathsqrt\n\nsquares = array([1,4,9,16,25])\n\nprint(nsqrt(squares))\n#print(mathsqrt(squares))  #This will fail because it wasn't a numpy function.\n\n[1. 2. 3. 4. 5.]\n\n\n\n\n8.5.2 Arrays of same Dimensions\nIf a mathematical operation is performed between two arrays of the same dimensions, the mathematical operation is performed between corresponding elements in the two arrays. For example, if two \\(2\\) x \\(2\\) arrays are added together, element (0,0) of the first array gets added to the corresponding element in the second and so forth for all elements:\n\\[\n\\begin{pmatrix}\n1&2\\\\\n3&4\\\\\n\\end{pmatrix}+\n\\begin{pmatrix}\n5&6\\\\\n7&8\\\\\n\\end{pmatrix}=\n\\begin{pmatrix}\n6&8\\\\\n10&12\\\\\n\\end{pmatrix}\n\\]\n\nfrom numpy import array\n\na = array([[1,2],[3,4]])\nb = array([[5,6],[7,8]])\n\nc = a + b  # Add the elements of the arrays together.\nd = a * b  # Multiply the elements of the arrays together.\n\nprint(c)\nprint(d)\n\n[[ 6  8]\n [10 12]]\n[[ 5 12]\n [21 32]]\n\n\n\n\n8.5.3 Arrays of Different Dimensions\nWhen a mathematical operation between two arrays of different dimensions is attempted, Python has to figure out how to make them have the same shape before performing the operation. Broadcasting refers to the set of rules used for operations like this. To handled arrays with different dimensions, NumPy pads or clones the array with fewer dimensions to make it have the same dimensions as the larger array. For example, what would happen if you attempted this operation:\n\\[\n\\begin{pmatrix}\n1&2\\\\\n3&4\\\\\n\\end{pmatrix}+\n\\begin{pmatrix}\n2&2\\\\\n\\end{pmatrix}\n\\]\nOne array is \\(2\\) x \\(2\\) and the other is \\(1\\) x \\(2\\). Before the addition can take place, NumPy clones the smaller array and repeats it until it has the same size as the bigger array.\n\\[\n\\begin{pmatrix}\n1&2\\\\\n3&4\\\\\n\\end{pmatrix}+\n\\begin{pmatrix}\n2&2\\\\\n2&2\\\\\n\\end{pmatrix}\n\\]\n\nfrom numpy import array\n\na = array([[1,2],[3,4]])\nb = array([2,2])\nc = a + b\n\nprint(c)\n\n[[3 4]\n [5 6]]\n\n\nThere are some cases where NumPy simply cannot figure out how to broadcast one of the arrays appropriately and an error results. When broadcasting, NumPy must verify that all dimensions are compatible with each other. Two dimensions are compatible when i) they are equal or ii) one of the dimensions is 1. For example, if we tried to perform the following mathematical operation, broadcasting would fail because the first dimension of the first array is 2 and the first dimension of the second array is 3.\n\\[\n\\begin{pmatrix}\n1&2&3\\\\\n3&4&5\\\\\n\\end{pmatrix}+\n\\begin{pmatrix}\n1&1&1\\\\\n2&2&2\\\\\n3&3&3\\\\\n\\end{pmatrix}\n\\]\nfrom numpy import array\n\na = array([[1,2,3],[4,5,6]])\nb = array([[1,1,1],[2,2,2],[3,3,3]])\nc = a + b\nbut if we attempted\n\\[\n\\begin{pmatrix}\n1&2&3\\\\\n\\end{pmatrix}+\n\\begin{pmatrix}\n1&1&1\\\\\n2&2&2\\\\\n3&3&3\\\\\n\\end{pmatrix}\n\\]\nthe operation would succeed because the first dimension of the first array is 1 and the second dimension of both arrays are 3.\n\n\n8.5.4 Vectorizing user-defined functions\nStandard Python functions are often designed to perform a single calculation rather than iterate over a list to perform many calculations. For example, here is a function to calculate the average acceleration of an object given its final velocity and time of travel.\n\ndef accel(velocity, time):\n    return velocity / time\n\n\nprint(accel(52.6,5.6))\n\n9.392857142857144\n\n\nNow what if I have a list of many times that I’d like to feed into this function and get an acceleration value for each one.\ndef accel(velocity, time):\n    return velocity / time\n\n\ntimes = [4.6,7.9,3.2,8.5,9.2,4.7]\nprint(accel(52.6,times))  # Produces an error because you can't divide by a list\nAn error results here because Python does not know how to divide by a list. We can NumPy-ify this function using a function called vectorize. The resulting function will behave just like the other functions from the NumPy library, vectorizing across the list of times.\n\nfrom numpy import vectorize\ndef accel(velocity, time):\n    return velocity / time\n\n\ntimes = [4.6,7.9,3.2,8.5,9.2,4.7]\nvaccel = vectorize(accel)  # Vectorize the function!\nprint(vaccel(52.6,times))  # Succeeds because NumPy knows how to vectorize.\n\n[11.43478261  6.65822785 16.4375      6.18823529  5.7173913  11.19148936]\n\n\nOf course, we also could have just converted our times list into an array and used the original function.\n\nfrom numpy import array\ndef accel(velocity, time):\n    return velocity / time\n\n\ntimes = array([4.6,7.9,3.2,8.5,9.2,4.7])\nprint(accel(52.6,times))  # Succeeds because times is an array not a list.\n\n[11.43478261  6.65822785 16.4375      6.18823529  5.7173913  11.19148936]"
  },
  {
    "objectID": "chapters/numpy.html#manipulating-and-modifying-arrays",
    "href": "chapters/numpy.html#manipulating-and-modifying-arrays",
    "title": "8  The numpy module",
    "section": "8.6 Manipulating and Modifying Arrays",
    "text": "8.6 Manipulating and Modifying Arrays\nA wealth of functions exist to perform routine manipulation tasks on arrays once they are created. Often these tasks will involve changing the number of rows or columns or merging two arrays into one. The size and shape of an array are the number of elements and dimensions, respectively. These can be determined using the shape and size methods.\n\nfrom numpy import array\n\na = array([[1,2,3],[4,5,6]])\nprint(a.size)\nprint(a.shape)\n\n6\n(2, 3)\n\n\n\n8.6.1 Reshaping Arrays\nThe dimensions of an array can be modified using the reshape function. This methods maintains the number of elements and the order of elements but repacks them into a different number of rows and columns. Because the number of elements is maintained, the size of the new array has to be the same as the original. Let’s see an example.\n\nfrom numpy import array, reshape\n\na = array([[1,2,3],[4,5,6]])\n\nb = reshape(a,[3,2])\n\nprint(a)\nprint(b)\n\n[[1 2 3]\n [4 5 6]]\n[[1 2]\n [3 4]\n [5 6]]\n\n\nThe original array (a) was a \\(2\\) x \\(3\\) and had \\(6\\) elements and the reshaped array also has \\(6\\) elements but is a \\(3\\) x \\(2\\). You can start with a one-dimensional array and reshape it to a higher dimensional array.\n\nfrom numpy import linspace, reshape\n\na = linspace(0,10,12)\n\nb = reshape(a,[3,4])\n\nprint(a)\nprint(b)\n\n[ 0.          0.90909091  1.81818182  2.72727273  3.63636364  4.54545455\n  5.45454545  6.36363636  7.27272727  8.18181818  9.09090909 10.        ]\n[[ 0.          0.90909091  1.81818182  2.72727273]\n [ 3.63636364  4.54545455  5.45454545  6.36363636]\n [ 7.27272727  8.18181818  9.09090909 10.        ]]\n\n\n\n\n8.6.2 Flattening Arrays\nFlattening an array takes a higher-dimensional array and squishes it into a one-dimensional array. You can “flatten” an array with the flatten method, but note that flatten doesn’t actually modify the original array.\n\nfrom numpy import array\n\na = array([[1,2,3],[4,5,6]])\na.flatten()\n\nprint(a)  # 'a' remains unchanged\n\na = a.flatten() # If you want to change the definition of a, redifine it.\nprint(a)\n\n[[1 2 3]\n [4 5 6]]\n[1 2 3 4 5 6]\n\n\n\n\n8.6.3 Transposing Arrays\nTransposing an array rotates it across the diagonal and can be accomplished with the transpose function. There is also a shortcut method for this of array.T to accomplish the same thing but just as with flatten it does not modify the original array. (neither does transpose)\n\nfrom numpy import array,transpose\n\na = array([[1,2,3],[4,5,6]])\ntranspose(a)\n\nprint(a)  # 'a' remains unchanged\n\na = a.T # If you want to change the definition of a, redefine it.\nprint(a)\n\n[[1 2 3]\n [4 5 6]]\n[[1 4]\n [2 5]\n [3 6]]\n\n\n\n\n8.6.4 Merging Arrays\nSeveral function exist for combining multiple arrays into a single array. We’ll give examples for a couple and mention the others in reference tables. The most commonly used functions for this task are vstack (vertical stacking) and hstack (horizontal stacking). vstack will stack the original arrays vertically to create the new array and hstack will stack them horizontally. Here are some examples.\n\nfrom numpy import linspace, hstack, vstack\n\na = linspace(0,10,10)\nb = linspace(0,5,10)\n\nc = vstack((a,b))\nprint(c)  # 'a' remains unchanged\n\nd = hstack((a,b))\nprint(a.T)\nprint(d)\n\n[[ 0.          1.11111111  2.22222222  3.33333333  4.44444444  5.55555556\n   6.66666667  7.77777778  8.88888889 10.        ]\n [ 0.          0.55555556  1.11111111  1.66666667  2.22222222  2.77777778\n   3.33333333  3.88888889  4.44444444  5.        ]]\n[ 0.          1.11111111  2.22222222  3.33333333  4.44444444  5.55555556\n  6.66666667  7.77777778  8.88888889 10.        ]\n[ 0.          1.11111111  2.22222222  3.33333333  4.44444444  5.55555556\n  6.66666667  7.77777778  8.88888889 10.          0.          0.55555556\n  1.11111111  1.66666667  2.22222222  2.77777778  3.33333333  3.88888889\n  4.44444444  5.        ]"
  },
  {
    "objectID": "chapters/numpy.html#commonly-used-array-methods-and-functions",
    "href": "chapters/numpy.html#commonly-used-array-methods-and-functions",
    "title": "8  The numpy module",
    "section": "8.7 Commonly-used Array Methods and Functions",
    "text": "8.7 Commonly-used Array Methods and Functions\nNumPy contains an extensive listing of array methods and functions and it would be impractical to list them all here. However, below you will find some tables of some of the commonly used ones that can serve as a reference.\n\nArray Attribute Methods and Functions\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\nshape(array) or array.shape\nReturns the dimensions of the array.\n\n\nndim(array) or array.ndim\nReturns the number of dimensions (i.e. a 2D array is \\(2\\)).\n\n\nsize(array) or array.size\nReturns the number of elements in an array.\n\n\n\n\nArray Modification Methods and Functions\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\narray.flatten()\nReturns a flattened view of array.\n\n\nreshape(array,dims) or array.reshape(dims)\nReturns a view of array reshaped into an array with dimensions given by dims.\n\n\narray.resize(dims)\nModifies array to be a resized array with dimensions dims.\n\n\ntranspose(array) or array.T\nReturns a view of the transpose of array.\n\n\nsort(array)\nReturns a view of a sorted version of array.\n\n\narray.sort()\nModifies array to be sorted.\n\n\nargsort(array)\nReturns index values that will sort array.\n\n\narray.fill(x)\nModifies array so that all elements are equal to x.\n\n\nvstack(a,b)\nVertically stack arrays a and b to form the new array.\n\n\nhstack(a,b)\nHorizontally stack arrays a and b to form the new array.\n\n\nvsplit(array,n)\nSplits array vertically into n equal parts.\n\n\nhsplit(array,n)\nSplits array horizontally into n equal parts.\n\n\nappend(array,x)\nReturns a view of array with x added to the end of the array.\n\n\ninsert(array,n,x)\nReturns a view of array with x inserted at location n.\n\n\ndelete(array,n)\nReturns a view of array with element at location n removed.\n\n\nunique(array)\nReturns a view of the unique elements of array.\n\n\n\n\nArray Measurement Methods and Functions\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\nmin(array) or array.min()\nReturns the minimum value in an array.\n\n\nmax(array) or array.max()\nReturns the maximum value in an array.\n\n\nargmin(array) or array.argmin()\nReturns the location of the minimum value in an array.\n\n\nargmax(array) or array.argmax()\nReturns the location of the maximum value in an array.\n\n\nfmin(array1,array2)\nReturns the minimum between two arrays of the same size. (Arrays are compared element wise.)\n\n\nfmax(array1,array2)\nReturns the maximum between two arrays of the same size. (Arrays are compared element wise.)\n\n\nmean(array) or array.mean()\nReturns the mean of array.\n\n\nmedian(array) or array.median()\nReturns the median of array.\n\n\nstd(array) or array.std()\nReturns the standard deviation of array.\n\n\ncumprod(array) or array.cumprod()\nReturns the cumulative product of array.\n\n\ncumsum(array) or array.cumsum()\nReturns the cumulative sum of array.\n\n\nsum(array) or array.sum()\nReturns the sum of all elements in array.\n\n\nprod(array) or array.prod()\nReturns the product of all elements in array.\n\n\nfloor(array)\nReturns the floor (i.e., rounds down) of all elements in array.\n\n\nceil(array)\nReturns the ceiling (i.e., rounds up) of all elements in array."
  },
  {
    "objectID": "chapters/io.html",
    "href": "chapters/io.html",
    "title": "9  File I/O (Input/Output)",
    "section": "",
    "text": "Up to now, we have been working with computer-generated or manually typed data sets. Often in a scientific setting your data will be stored in a file and you will need to read the contents of the file into Python so you can perform an analysis. Most data files are text files, but there is a large variety of these that differ mostly in the way the information is formatted. The file extension (i.e., the 3 or 4 letters after the period at the end of a file name) specifies the formatting of the file. For example, a .csv file (short for comma-separated values) has commas to separate the information."
  },
  {
    "objectID": "chapters/io.html#reading-files",
    "href": "chapters/io.html#reading-files",
    "title": "9  File I/O (Input/Output)",
    "section": "9.1 Reading Files",
    "text": "9.1 Reading Files\n\n9.1.1 Reading Line by Line\nThe first way to read a file is using a for loop to iterate over the file line by line. Admittedly, this is not the most elegant or efficient way to read a file but we present it first because it always works. First, the file is opened using the open command. The file should be attached to a variable for later use. Next, the data is read one line at a time using the readlines() method. We should use a for loop for this. Finally, it is a good idea to close the file when you’re finished. Let’s see an example for reading in the following file, which will be named squares.csv\n1, 1\n2, 4\n3, 9\n4, 16\n5, 25\n6, 36\n7, 49\n\nfile = open(\"squares.csv\")\nfor line in file.readlines():\n    print(line)\n\nfile.close()\n\n1,1\n\n2,4\n\n3,9\n\n4,16\n\n5,25\n\n6,36\n\n7,49\n\n8,64\n\n9,81\n\n10,100\n\n\nYou can see how each line gets read separately and printed off. But this isn’t super useful yet because we’d probably like to have the numbers stored in lists for our forthcoming analysis. We can fix this by creating some empty lists and appending the appropriate values as they are read in.\n\nnumbers = []\nsquares = []\n\nfile = open(\"squares.csv\")\nfor line in file.readlines():\n    numbers.append( int(line.split(',')[0]) )\n    squares.append( int(line.split(',')[1]) )\n\nfile.close()\n\nprint(numbers)\nprint(squares)\n\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n\n\nNow the data from the file is saved in Python lists and our analysis can proceed.\nOne final note: if all you want to do is read your file in as a list of strings (one string for each line), that can be done without a for loop using the readlines function (rather than readline).\n\nfile = open(\"squares.csv\")\ndata = file.readlines()\nfile.close()\n\nprint(data)\n\n['1,1\\n', '2,4\\n', '3,9\\n', '4,16\\n', '5,25\\n', '6,36\\n', '7,49\\n', '8,64\\n', '9,81\\n', '10,100']\n\n\n\n\n9.1.2 Using NumPy’s genfromtxt function\nIf the data file is highly structured (every line looks the same, separated character is consistent across the file, etc) then NumPy’s genfromtxt function can read the data very efficiently into an array. The genfromtxt function requires only one argument (the file name) with another optional argument (delimiter) that is typically included to specify the character used to separate the data. Below is an example for using this function to read in the .csv data we have been working with.\n\nfrom numpy import genfromtxt\n\ndata = genfromtxt('squares.csv',delimiter = \",\")\n\nprint(data)\n\n[[  1.   1.]\n [  2.   4.]\n [  3.   9.]\n [  4.  16.]\n [  5.  25.]\n [  6.  36.]\n [  7.  49.]\n [  8.  64.]\n [  9.  81.]\n [ 10. 100.]]\n\n\nNotice that the data was read into a NumPy array (2D in this case because there were two columns of data), which means that we can easily slice off the individual columns if needed.\n\nfrom numpy import genfromtxt\n\ndata = genfromtxt('squares.csv',delimiter = \",\")\n\nnumbers = data[:,0]\nsquares = data[:,1]\nprint(numbers)\nprint(squares)\n\n[ 1.  2.  3.  4.  5.  6.  7.  8.  9. 10.]\n[  1.   4.   9.  16.  25.  36.  49.  64.  81. 100.]\n\n\nOther optional arguments that can be used with the genfromtxt function are given in the table below:\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\ndelimiter\nThe string used to separate value. By default, whitespace acts as the delimiter.\n\n\nskip_header\nThe number of lines to skip at the beginning of a file.\n\n\nskip_footer\nThe number of lines to skip at the end of a file.\n\n\nusecols\nSpecify which columns to read with 0 being the first. For example, usecols = (0,2,5) will read the 1st, 3rd, and 6th columns.\n\n\ncomments\nThe character used to indicate the start of a comment. Lines beginning with this character will be discarded."
  },
  {
    "objectID": "chapters/io.html#writing-files",
    "href": "chapters/io.html#writing-files",
    "title": "9  File I/O (Input/Output)",
    "section": "9.2 Writing Files",
    "text": "9.2 Writing Files\nWriting Python data to file is as simple as is reading a file. Just like when you are reading a file, determining which method to use will be determined by the type of data that you are writing. If your data is strictly numerical information stored in an array, Numpy has a function that will quickly save the data to a file. If your data is rife with inconsistencies, non-numerical data, etc, you’ll have to use Python’s native write function.\n\n9.2.1 Writing Line by Line\nSometimes the data file that you want to write includes some text or other non-numerical data. For example, what if you wanted to write the following data to file:\n\n\n\nPlanet\nAcceleration due to gravity (m/s\\(^2\\)\n\n\n\n\nEarth\n9.8\n\n\nMoon\n1.6\n\n\nMars\n3.7\n\n\nVenus\n8.83\n\n\nSaturn\n11.2\n\n\nUranus\n10.5\n\n\nNeptune\n13.3\n\n\nPluto\n0.61\n\n\nJupiter\n24.5\n\n\nSun\n275\n\n\n\nplanets = [\"Earth\",\"Moon\",\"Mars\",\"Venus\",\"Saturn\",\"Uranus\",\"Neptune\",\"Pluto\",\"Jupiter\",\"Sun\"]\ng=[9.8,1.6,3.7,8.83,11.2,10.5,13.3,0.61,24.5,275]\n\nf= open(\"planets.txt\",\"w\")\n\nf.write(\"Planet   g (m/s^2)\\n\")\nf.write(\"------------------\\n\")\n\nfor idx,planet in enumerate(planets):\n    f.write(f\"{planet:10s}  {g[idx]:5.2f} \\n\" )\n\nf.close()\n\n\n9.2.2 Using NumPy’s savetxt function\nIf the data is strictly numerical and contains no text, the savetxt function is a fast and efficient way to write the data to file. For example, maybe you have a two dimensional array containing various columns of planetary data.\n\n\n\n\n\n\n\n\nRadius ( \\(\\times 10^{6}\\) meters )\nMass ( \\(\\times 10^{23}\\) kg )\nAcceleration due to gravity (m/s\\(^2\\))\n\n\n\n\n6.37\n59.8\n9.8\n\n\n1.74\n0.736\n1.6\n\n\n3.38\n6.42\n3.7\n\n\n6.07\n48.8\n8.83\n\n\n58.2\n5680\n11.2\n\n\n23.5\n868\n10.5\n\n\n22.7\n1030\n13.3\n\n\n1.15\n0.131\n0.61\n\n\n69.8\n19000\n24.5\n\n\n696\n19890000\n275\n\n\n\nfrom numpy import savetxt\n\ndata =[[6.37,59.8,9.8],[1.74,0.736,1.6],[3.38,6.42,3.7],[6.07,48.8,8.83],[58.2,5680,11.2],[23.5,868,10.5],[22.7,1030,13.3],[1.15,.131,0.61],[69.8,19000,24.5],[696,19890000,275]]\n\nsavetxt(\"planetsData.txt\",data,fmt = \"%5.2e\")\nThe fmt keyword argument can be be added to specify how to format the data. If the data is stored in separate one-dimensional arrays, you can pack them into a single list(tuple) when using the savetxt function and it will write each data set to it’s own line in the file.\nradius = [6.37,1.74,3.38,6.07,58.2,23.5,22.7,1.15,69.8,696]\nmass = [59.8,0.736,6.42,48.8,5680,868,1030,0.131,19000,19890000]\ng = [9.8,1.6,3.7,8.83,11.2,10.5,13.3,0.61,24.5,275]\n\nsavetxt(\"planetsDataTwo.txt\",(radius,mass,g),fmt = \"%5.2e\")\nOther optional arguments that can be used with the savetxt function are given in the table below:\n\n\n\n\n\n\n\nArgument\nDescription\n\n\n\n\ndelimiter\nString or character to separate columns.\n\n\nnewline\nString or character to separate lines.\n\n\nheader\nString to be written at the beginning of the file.\n\n\nfooter\nString to be written at the end of the file.\n\n\ncomments\nString that will be prepended to the header and footer string to mark them as comments."
  },
  {
    "objectID": "chapters/basicPlotting.html",
    "href": "chapters/basicPlotting.html",
    "title": "10  Basic Plotting",
    "section": "",
    "text": "Creating plots is an important task in science and engineering. The old adage “A picture is worth a thousand words!” is wrong…. it’s worth way more than that if you do it right. When making plots on a computer it is important to remember that computers don’t plot functions, rather they plot individual points. Only when you connect those points does the image look like the function you are so used to seeing. In this chapter we will use a library called matplotlib for plotting. More specifically, we will import the pyplot function inside of matplotlib. It is customary to use plt as an alias for pyplot.\nThe %matplotlib inline statement is a Jupyter notebook command. It tells Jupyter to display any plots generated directly in the notebook instead of in a separate window. If you use matplotlib in another environment, you should remove this line and instead place plt.show() af the plot commands."
  },
  {
    "objectID": "chapters/basicPlotting.html#plotting-functions-of-a-single-variable",
    "href": "chapters/basicPlotting.html#plotting-functions-of-a-single-variable",
    "title": "10  Basic Plotting",
    "section": "10.1 Plotting Functions of a Single Variable",
    "text": "10.1 Plotting Functions of a Single Variable\nIn order to make a plot, matplotlib needs lists of the x and y coordinates for the points that are going to be plotted. A good choice for generating the x-coordinates is either linspace or arange from NumPy. The following equation is called the Lennard-Jones equation and it gives the energy of two atoms interacting as a function of separation distance\n\\[ E = 4\\sigma\\left[ \\left({\\epsilon\\over r} \\right)^{12} - \\left({\\epsilon\\over r} \\right)^{6}\\right]\\]\nLet’s plot this function from \\(0.9\\) to \\(4.0\\).\n\nfrom matplotlib import pyplot as plt\n%matplotlib inline\nfrom numpy import linspace,sqrt\n\nsigma = 1\nepsilon = 1\nr = linspace(0.9,4,50)\nenergy = 4 * sigma* ((epsilon/r)**12 - (epsilon/r)**6)\n\nplt.figure()\nplt.plot(r,energy)\n\n\n\n\nBy default, matplotlib connects the points to form a line (albeit a bit jagged because we didn’t plot that many points).\n\n10.1.1 Linestyles, Markers, and Colors\nThree optional arguments can help you control the look of the plot: marker, linestyle, and color. All of these arguments take strings. The linestyle argument determines if the line is solid or dashed and what type of dashing to use. The marker argument specifies the shape of the plot marker to be used. Below are tables listing possible options for these arguments.\n\nCommon Marker Styles\n\n\nArgument\nDescription\n\n\n\n\no\ncircle\n\n\n*\nstar\n\n\np\npentagon\n\n\n^\ntriangle\n\n\ns\nsquare\n\n\n\n\nCommon Line Styles\n\n\nArgument\nDescription\n\n\n\n\n-\nsolid\n\n\n--\ndashed\n\n\n-.\ndash-dot\n\n\n:\ndotted\n\n\n\n\nCommon Colors\n\n\nArgument\nDescription\n\n\n\n\nb\nblue\n\n\nr\nred\n\n\nk\nblack\n\n\ng\ngreen\n\n\nm\nmagenta\n\n\nc\ncyan\n\n\ny\nyellow\n\n\n\nSeveral other keyword arguments exist for helping you customize the look of your plots. They are summarized in the table below.\n\nA Few Common plot keyword arguments\n\n\nArgument\nDescription\n\n\n\n\nlinestyle or ls\nline style\n\n\nmarker\nmarker shape\n\n\nlinewidth or lw\nline width\n\n\ncolor or c\nline color\n\n\nmarkersize or ms\nmarker size\n\n\n\nHere is the plot from above with some of these keyword arguments added.\n\nfrom matplotlib import pyplot as plt\n%matplotlib inline\nfrom numpy import linspace,sqrt\n\nr = linspace(0.9,4,50)\nenergy = 4 * ((1/r)**12 - (1/r)**6)\n\nplt.figure()\nplt.plot(r,energy,linestyle = '-', marker = 'o', color = 'r')\n\n\n\n\n\n\n10.1.2 Labeling Plots\nAll good plots have axes labels and a title and you can add them to a matplotlib plot using the xlabel(), ylabel(), and title() functions which are placed on their own line after the plot command.\n\nfrom matplotlib import pyplot as plt\n%matplotlib inline\nfrom numpy import linspace,sqrt\n\nr = linspace(0.9,4,50)\nenergy = 4 * ((1/r)**12 - (1/r)**6)\n\nplt.figure()\nplt.plot(r,energy,marker = 'o')\nplt.xlabel(\"Separation Distance\")\nplt.ylabel(\"Energy\")\nplt.title(\"Lennard-Jones Potential\")\n\nText(0.5, 1.0, 'Lennard-Jones Potential')\n\n\n\n\n\n\n\n10.1.3 Greek Letters\nIn physics, Greek letters get used all the time and you may find yourself wanting to use one in a plot title or axes label. This can be accomplished by placing an r in front of the title string and then placing the name of the greek variable inside of $ with a backslash in front of it. This is better illustrated with an example.\n\nfrom matplotlib import pyplot as plt\n%matplotlib inline\nfrom numpy import linspace,sqrt\n\nr = linspace(0.9,4,50)\nenergy = 4 * ((1/r)**12 - (1/r)**6)\n\nplt.figure()\nplt.plot(r,energy,marker = 'o')\nplt.xlabel(\"Separation Distance\")\nplt.ylabel(\"Energy\")\nplt.title(r\"Lennard-Jones Potential ($\\theta$)\")\n\nText(0.5, 1.0, 'Lennard-Jones Potential ($\\\\theta$)')\n\n\n\n\n\nYou can subscript any character using the _ character followed by the subscript. \\(\\theta_1\\) can be written as \\theta_1. If the subscript is more than one character, you’ll need to enclose it in curly braces. \\(\\theta_{12}\\) is written as \\theta_{12}. Superscripts work the same way only using the ^ character instead of the underscore.\n\nLowercase greek letters\n\n\nArgument\nDescription\n\n\n\n\n\\(\\alpha\\)\n\\alpha\n\n\n\\(\\beta\\)\n\\beta\n\n\n\\(\\gamma\\)\n\\gamma\n\n\n\\(\\delta\\)\n\\delta\n\n\n\\(\\epsilon\\)\n\\epsilon\n\n\n\\(\\phi\\)\n\\phi\n\n\n\\(\\theta\\)\n\\theta\n\n\n\\(\\kappa\\)\n\\kappa\n\n\n\\(\\lambda\\)\n\\lambda\n\n\n\\(\\mu\\)\n\\mu\n\n\n\\(\\nu\\)\n\\nu\n\n\n\\(\\pi\\)\n\\pi\n\n\n\\(\\rho\\)\n\\rho\n\n\n\\(\\sigma\\)\n\\sigma\n\n\n\\(\\tau\\)\n\\tau\n\n\n\\(\\xi\\)\n\\xi\n\n\n\\(\\zeta\\)\n\\zeta\n\n\n\n\n\n10.1.4 Controlling the Axes\nBy default, matplotlib will size the plot window to include all of the points. If you want to zoom in our out, you can do so with the xlim and ylim functions. These functions should be placed after the plot command on their own line just like the label commands.\n\nfrom matplotlib import pyplot as plt\n%matplotlib inline\nfrom numpy import linspace,sqrt\n\nr = linspace(0.9,4,50)\nenergy = 4 * ((1/r)**12 - (1/r)**6)\n\nplt.figure()\nplt.plot(r,energy,marker = 'o')\nplt.xlim(0.5,3)\nplt.ylim(-1.25,5)\nplt.xlabel(\"Separation Distance\")\nplt.ylabel(\"Energy\")\nplt.title(\"Lennard-Jones Potential\")\n\nText(0.5, 1.0, 'Lennard-Jones Potential')\n\n\n\n\n\n\n\n10.1.5 Overlaying Plots\nOften you will want to plot more than one set of data on the same set of axes. This can be accomplished two ways. The first way is to call the plot function twice in the same Jupyter notebook cell. Matplotlib will automatically place the plots on the same figure and scale it appropriately. Below you will find a plot of the Lennard-Jones potential for two choices of the parameters \\(\\sigma\\) and \\(\\epsilon\\).\n\nfrom matplotlib import pyplot as plt\n%matplotlib inline\nfrom numpy import linspace,sqrt\n\nr = linspace(0.9,4,50)\n\nsigmaOne = 1\nepsilonOne = 1\nsigmaTwo = 2\nepsilonTwo = 2\nenergyOne = 4 * sigmaOne* ((epsilonOne/r)**12 - (epsilonOne/r)**6)\nenergyTwo = 4 * sigmaTwo * ((epsilonTwo/r)**12 - (epsilonTwo/r)**6)\n\nplt.figure()\nplt.plot(r,energyOne,marker = 'o')\nplt.plot(r,energyTwo,marker = '+')\nplt.xlim(0.5,3.5)\nplt.ylim(-2,5)\nplt.xlabel(\"Separation Distance\")\nplt.ylabel(\"Energy\")\nplt.title(\"Lennard-Jones Potential\")\n\nText(0.5, 1.0, 'Lennard-Jones Potential')\n\n\n\n\n\nThe other way to overlay plots is to include both sets of data into a single plot command.\n\nfrom matplotlib import pyplot as plt\n%matplotlib inline\nfrom numpy import linspace,sqrt\n\nr = linspace(0.9,4,50)\n\nsigmaOne = 1\nepsilonOne = 1\nsigmaTwo = 2\nepsilonTwo = 2\nenergyOne = 4 * sigmaOne* ((epsilonOne/r)**12 - (epsilonOne/r)**6)\nenergyTwo = 4 * sigmaTwo * ((epsilonTwo/r)**12 - (epsilonTwo/r)**6)\n\nplt.figure()\nplt.plot(r,energyOne,r,energyTwo,marker = 'o')\nplt.xlim(0.5,3.5)\nplt.ylim(-2,5)\nplt.xlabel(\"Separation Distance\")\nplt.ylabel(\"Energy\")\nplt.title(\"Lennard-Jones Potential\")\n\nText(0.5, 1.0, 'Lennard-Jones Potential')"
  },
  {
    "objectID": "chapters/basicPlotting.html#other-plot-types",
    "href": "chapters/basicPlotting.html#other-plot-types",
    "title": "10  Basic Plotting",
    "section": "10.2 Other Plot Types",
    "text": "10.2 Other Plot Types\nBeyond the line plot that we learned about in the previous section, matplotlib can generate many other types of plots that are very useful in a scientific setting. We’ll explore some of them here.\n\n10.2.1 Logarithmic Plots\nSometimes the function being plotted increases or decreases by many orders of magnitude and a normal linear plot would not be particularly useful. Logarithmic plots can be made with the use of the semilogx, semilogy, or loglog functions depending on which axes you want to be on a logarithmic scale. Consider the first plot produced below. Notice that it rises from \\(0\\) at \\(x = 0\\) to \\(10^{45}\\) at \\(x = 100\\). Plotting this function with the y-axis scaled logarithmically will smooth out the plot and make it easier to analyze.\n\nfrom matplotlib import pyplot as plt\n%matplotlib inline\nfrom numpy import linspace,exp\n\nx = linspace(0,100,200)\ny = exp(x)\n\nplt.figure()\nplt.plot(x,y)\nplt.figure() \nplt.semilogy(x,y)\n\n\n\n\n\n\n\n\n\n10.2.2 Bar Plots\nA bar plot and a scatter plot are quite similar except that instead of a plot marker indicating the associated value, the height of the bar represents the value. You can make a bar plot using the bar function inside of pyplot.\n\nfrom matplotlib import pyplot as plt\n%matplotlib inline\nfrom numpy import linspace,sqrt\n\n#d = [5.8e10,1.9e11,1.5e11,2.3e11,7.8e11,1.4e12,2.9e12,4.5e12]\nd = [1,2,3,4,5,6,7,8]\nT = [0.241,0.615,1,1.88,11.9,29.5,84,165]\n\nplt.figure()\nplt.bar(d,T,tick_label = [\"Mercury\",\"Venus\",\"Earth\",\"Mars\",\"Jupyter\",\"Saturn\",\"Uranus\",\"Neptune\"])\nplt.xlabel(\"Planet Name\")\nplt.ylabel(\"Length of day (in earth days)\")\nplt.title(\"Length of day for planets in our solar system\")\n\nText(0.5, 1.0, 'Length of day for planets in our solar system')\n\n\n\n\n\nNotice the optional argument tick_labels used to add labels to the bars. If that were left off, the bars would be labeled using the numbers supplied. Other optional arguments that are available for the bar command are given below.\n\nA Few Common bar keyword arguments\n\n\nArgument\nDescription\n\n\n\n\nwidth\nbar width\n\n\ncolor\nbar color\n\n\nxerr\nX error bar\n\n\nyerr\nY error bar\n\n\ncapsize\nsize of caps on error bars\n\n\n\n\n\n10.2.3 Errorbar Plots\nTo make plots with error bars use matplotlilb’s errorbar function. You can choose to add error bars on the x or y axis using the keyword arguments xerr and yerr.\n\nfrom matplotlib import pyplot as plt\n\nfrom numpy import arange\n\nx = arange(0,8,0.5)\ny = x**2\n\nx_err = 0.05 # Same error for all points\ny_error = 2 # Different error for each point\n\nplt.errorbar(x,y,linestyle = '-.', marker = 'o',markersize = 3,yerr=y_error,capsize = 5)\n\n<ErrorbarContainer object of 3 artists>\n\n\n\n\n\nThe linestyle, marker, and markersize arguments work with this plot type also.\n\n\n10.2.4 Scatter Plots\nWe have already generated scatter plots using the plot function but you can also use the scatter command to do the same thing. The only other additional functionality with scatter is the ability to specify the color, shape, and size of each plot marker individually.\n\nfrom matplotlib import pyplot as plt\n%matplotlib inline\nfrom numpy import linspace,log\n\nd = [5.8e10,1.9e11,1.5e11,2.3e11,7.8e11,1.4e12,2.9e12,4.5e12]\n#d = [1,2,3,4,5,6,7,8]\nT = [0.241,0.615,1,1.88,11.9,29.5,84,165]\nmass = [3.2e23,4.9e24,6e24,6.4e23,1.9e27,5.7e26,8.7e25,1e26]\n\nplt.figure()\nplt.scatter(d,T,c = mass,s= 50)\nplt.xlabel(\"Orbital Distance from Sun\")\nplt.ylabel(\"Length of day (in earth days)\")\nplt.title(\"Length of day for planets in our solar system (color indicates mass)\")\nplt.colorbar()\n\n<matplotlib.colorbar.Colorbar at 0x11eefe1c0>\n\n\n\n\n\n\n\n10.2.5 Histograms\nHistograms display bars representing the frequency of values in a given data set. Unlike bar plots, the width of the bar is meaningful since the each bar represents the number of x-values that fall within a range given by the width of the bar. A histogram can be constructed using the hist function. There is only one required argument, which is the data set. Some commonly used keyword arguments are bins which specifies how many equally-spaced groups (called bins) to generate and edgecolor which can be used to specify the color of the bar’s edges.\n\nfrom matplotlib import pyplot as plt\n%matplotlib inline\nfrom numpy import linspace,log\n\ndensities = [0.00009,0.000178,0.00125,0.001251,0.001293,0.001977,0.534,0.810,0.900,0.920,0.998,1.000,1.03,1.03,1.25,1.600,1.7,2.6,2.7,3.5,5.515,7.8,7.8,8.6,8.5,11.3,13,13.6,18.7,19.3,21.4,22.4,22.6]\n\nplt.figure()\nplt.hist(densities,bins = 5,edgecolor = 'r')\nplt.xlabel(\"Material Densities\")\nplt.title(r\"Histogram of Material Densities (g/cm$^3$)\")\n\nText(0.5, 1.0, 'Histogram of Material Densities (g/cm$^3$)')\n\n\n\n\n\nHere we have used bins = 5 which will produce a histogram with \\(5\\) equal-size bins. Alternatively, we can specify the exact locations of all the bin edges by placing them in a list.\n\nfrom matplotlib import pyplot as plt\n%matplotlib inline\nfrom numpy import linspace,log\n\ndensities = [0.00009,0.000178,0.00125,0.001251,0.001293,0.001977,0.534,0.810,0.900,0.920,0.998,1.000,1.03,1.03,1.25,1.600,1.7,2.6,2.7,3.5,5.515,7.8,7.8,8.6,8.5,11.3,13,13.6,18.7,19.3,21.4,22.4,22.6]\n\nplt.figure()\nplt.hist(densities,bins = [0,2.5,5,7.5,10,12.5,15,17.5,20,22.5],edgecolor = 'r')\nplt.xlabel(\"Material Densities\")\nplt.title(r\"Histogram of Material Densities (g/cm$^3$)\")\n\nText(0.5, 1.0, 'Histogram of Material Densities (g/cm$^3$)')"
  },
  {
    "objectID": "chapters/basicPlotting.html#multifigure-plots",
    "href": "chapters/basicPlotting.html#multifigure-plots",
    "title": "10  Basic Plotting",
    "section": "10.3 Multifigure Plots",
    "text": "10.3 Multifigure Plots\nTo generate multiple, independent plots in the same figure a few more lines of code are necessary to specify how you want the plots arranged. There are two general methods for doing that and we will demonstrate both of them. In the first method, you’ll first use the figure() command to generate a figure and the subplot() function to generate the individual plots in the figure. The subplot function take three arguments.\nsubplot(rows,columns,plot_number)\nAs an example, to generate a figure of two plots side by side.\n\nfrom matplotlib import pyplot as plt\n%matplotlib inline\nfrom numpy import linspace,sqrt\n\nr = linspace(0.9,4,50)\n\nsigmaOne = 1\nepsilonOne = 1\nsigmaTwo = 2\nepsilonTwo = 2\nenergyOne = 4 * sigmaOne* ((epsilonOne/r)**12 - (epsilonOne/r)**6)\nenergyTwo = 4 * sigmaTwo * ((epsilonTwo/r)**12 - (epsilonTwo/r)**6)\n\nplt.figure()\nplt.subplot(1,2,1)\nplt.plot(r,energyOne,marker = '+',color = 'k')\nplt.xlim(0.5,3.0)\nplt.ylim(-1.5,5)\nplt.xlabel(\"Separation Distance\")\nplt.ylabel(\"Energy\")\nplt.title(\"Lennard-Jones Potential\")\nplt.subplot(1,2,2)\nplt.plot(r,energyTwo,marker = 'o',color = 'r')\nplt.xlim(0.5,4.0)\nplt.ylim(-2,5)\nplt.xlabel(\"Separation Distance\")\nplt.ylabel(\"Energy\")\nplt.title(\"Lennard-Jones Potential\")\n\nText(0.5, 1.0, 'Lennard-Jones Potential')\n\n\n\n\n\nPay close attention to the subplot function. subplot(1,2,1) will generate a \\(1\\) x \\(2\\) grid of plots and place the next plot generated at the 1st location. Below is an example of a more advanced array of plots. Pay close attention to the subplot functions until you understand.\n\nfrom matplotlib import pyplot as plt\n%matplotlib inline\nfrom numpy import linspace,sqrt\n\nr = linspace(0.9,4,50)\n\nsigmaOne = 1\nepsilonOne = 1\nsigmaTwo = 2\nepsilonTwo = 2\nenergyOne = 4 * sigmaOne* ((epsilonOne/r)**12 - (epsilonOne/r)**6)\nenergyTwo = 4 * sigmaTwo * ((epsilonTwo/r)**12 - (epsilonTwo/r)**6)\n\nplt.figure()\nplt.subplot(2,1,1)\nplt.plot(r,energyOne,marker = '+',color = 'k')\nplt.xlim(0.5,3.0)\nplt.ylim(-1.5,5)\nplt.xlabel(\"Separation Distance\")\nplt.ylabel(\"Energy\")\nplt.title(\"Lennard-Jones Potential\")\nplt.subplot(2,2,3)\nplt.plot(r,energyTwo,marker = 'o',color = 'r')\nplt.xlim(0.5,4.0)\nplt.ylim(-2,5)\nplt.xlabel(\"Separation Distance\")\nplt.ylabel(\"Energy\")\nplt.title(\"Lennard-Jones Potential\")\nplt.subplot(2,2,4)\nplt.plot(r,energyTwo,marker = 'o',color = 'r')\nplt.xlim(0.5,4.0)\nplt.ylim(-2,5)\nplt.xlabel(\"Separation Distance\")\nplt.ylabel(\"Energy\")\nplt.title(\"Lennard-Jones Potential\")\nplt.tight_layout()\n\n\n\n\nThe other method for generating an array of plots is similar to the first but different functions are used and a little more control over the plots is gained. In this approach, functions to explicitly creates and links subplots, called axes are used. Just as before, the figure function is used to generate the overall figure. The create each subplot, the add_subplot(rows,columns, plot_number) function is used. The arguments to this function are the same as for subplot in the previous method. After the plot object has been created, we can call the plot function again, but this time preceded by the axes object that you just created. Here is an example.\n\nfrom matplotlib import pyplot as plt\n%matplotlib inline\nfrom numpy import linspace,sqrt\n\nr = linspace(0.9,4,50)\n\nsigmaOne = 1\nepsilonOne = 1\nsigmaTwo = 2\nepsilonTwo = 2\nenergyOne = 4 * sigmaOne* ((epsilonOne/r)**12 - (epsilonOne/r)**6)\nenergyTwo = 4 * sigmaTwo * ((epsilonTwo/r)**12 - (epsilonTwo/r)**6)\n\nfig = plt.figure()\nax1 = fig.add_subplot(2,1,1)\nax1.plot(r,energyOne,marker = '+',color = 'k')\nax1.set_xlim(0.5,3.0)\nax1.set_ylim(-1.5,5)\nax1.set_xlabel(\"Separation Distance\")\nax1.set_ylabel(\"Energy\")\nax1.set_title(\"Lennard-Jones Potential\")\n\nax2= fig.add_subplot(2,2,3)\nax2.plot(r,energyTwo,marker = 'o',color = 'r')\nax2.set_xlim(0.5,4.0)\nax2.set_ylim(-2,5)\nax2.set_xlabel(\"Separation Distance\")\nax2.set_ylabel(\"Energy\")\nax2.set_title(\"Lennard-Jones Potential\")\n\nax3 = fig.add_subplot(2,2,4)\nax3.plot(r,energyTwo,marker = 'o',color = 'r')\nax3.set_xlim(0.5,4.0)\nax3.set_ylim(-2,5)\nax3.set_xlabel(\"Separation Distance\")\nax3.set_ylabel(\"Energy\")\nax3.set_title(\"Lennard-Jones Potential\")\nplt.tight_layout()\n\n\n\n\nNotice the set_xlim, set_ylim, set_xlabel etc methods that were used to customize each individual plot. There are a host of other methods available for further customization. This website has a comprehensive list of them."
  }
]