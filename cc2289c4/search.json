[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Scientific Computing",
    "section": "",
    "text": "Python is a computer programming language available on all major platforms (Mac, Windows, Linux). Python is a scripting language which means that the computer interprets and runs your code at the moment you run it. In contrast, with a compiled language like C the code must first be converted into binary before it can run (called “compiling” the code). There are pros and cons to both types of languages. The on-the-fly interpretation of Python makes it quick and easy to write code and provides fast results for simple calculations. When codes become longer and more complex, on-the-fly interpretation becomes less efficient and execution time will be much slower than it would be with a compiled language. The pros and cons flip for a comiled language; writing code in a compiled language can be cumbersome and slow, but the execution time is typically much faster. Out of necessity, most programmers become proficient in both types of languages. Python(or another interpreted language) is used to “toy around” with your problem and build familiarity. As the complexity of the code increases the user is then forced to transition to a compiled language to get the needed speed. This is the famous “two language” problem and there is a new programming language designed to eliminate this problem by combining the pros from both into one language. (The name of the language is Julia)\nPython is free, open source software and is maintained by the non-profit Python software foundation. This is great because it means that you will always have free access to the Python language regardless of what organization or univeristy you are affliated with. You’ll never have to worry about not being able to use your Python code without paying for it. Another benefit of open source languages is that all of the codes developed by other people are available for anyone to inspect, modify, and use. This allows anyone to review another’s code to ensure that it does what they say it does, or to modify it to do something else. One last benefit that comes with an open source language is the community of Python users available to answer questions and provide instruction to the beginner. Answers to most questions about python are readily available on tutorial or forum websites.\n\n\n\nThe first step is to install the software (if you haven’t already). The most convenient way to install Python and also get many of the commonly-used libraries is to use an installer. I recommend Anaconda. When installing the software be sure to choose Python 3 since this is the current version. By default, Anaconda will install a suit of sotwares and libraries that are commonly used. If you want to install other Python libraries, open the Anaconda-Navigator (green circle icon) and select the Environment tab on the left. Select Not Installed from the pull-down to see all of the libraries that are available to be installed. To install a library, check the box next to it and click Apply. Anaconda will take care of the rest.\n\nTo Do:\n\nInstall Anaconda\nCheck to see if the library “numpy” is installed. If not, install it.\n\n\n\n\n\nA Jupyter notebook is an electronic document designed to support interactive data processing, analysis, and visualization in an easily shared format. A Jupyter notebook can contain live code, math equations, explanatory text, and the output of codes (numbers, plots, graphics, etc..). To launch a Jupyter notebook, first open Anaconda-Navigator (green circle icon) and click the Launch button under JupyterLab. Jupyter can also be launched from the command line by typing jupyter-lab. The jupyter notebook will launch in your default web browser, but it is not a website. From here you can select an already existing Jupyter notebook, denoted by the orange icons and the .ipynb extension, or create a new notebook by clicking New from the File menu.\n\nTo Do:\n\nOn iLearn, find the module entitled “Jupyter Notebooks” and download the file “Intro.ipynb”.\nLaunch JupyterLab as explained above.\nOpen “Intro.ipynb” that you downloaded in step 1 and continue reading this book in the jupyter notebook.\n\n\n\n\nThere are two types of “cells” in a Jupyter notebook: code cells and text cells (also called Markdown cell). Code cells contain “live” Python code that can be run inside of the notebook with any output appearing directly below it. Markdown cells are designed to contain explanatory information about what is happening inside of the code cells. They can contain text, math equations, and images. Markdown cells suport markdown, html, and Latex (for generating pretty math equations).\nBoth markdown and code cells can be executed by either selecting Run Selected Cells in the Run menu, by clicking the Play icon at the top of the notebook, or by using the Shift-Return shortcut when your curson is in the desired cell.\n\n\n\nNavigating a Jupyter notebook is fairly straightforward but there are a few handy shortcuts/hotkeys that will make navigation quicker and your workflow more efficient. When working in a Jupyter notebook, you are always operating in one of two modes: edit mode or navigate mode. In edit mode you can make modifications to the text or code in a cell and in navigate mode you can add/delete cells and modify the cell type. If you can see a blinking cursor in one of the cells you are in edit mode. Otherwise you are in navigate mode. To exit edit mode, simply press the esc key and you will enter navigate mode. To exit navigate mode, simply press the enter key and you will enter edit mode for the cell you were focused on. (You can also double click on a cell with your mouse to enter edit mode.) The shift + enter key sequence will “execute” a cell and produce the associated output. For text cells, executing just means to render the text in a nicely formatted fashion. “Executing” a code cell will actually execute the code block contained in the cell. You also enter navigate mode every time you execute a cell using the shift + enter key sequence. A summary of these shortcuts is given below:\n\nUp/down arrows - Navigate to different cells in the notebook.\nY - turns a text cell into a code cell.\nM - turns a code cell into a text cell.\nA - inserts a new cell above the current cell.\nB - inserts a new cell below the current cell.\nX - deletes the current cell.\nenter - enters edit mode.\nshift + enter - execute a cell.\nesc - enter navigate mode.\n\nYou should take some time now to practice these shortcut keys until you become good at navigating a jupyter notebook. Consider attempting the following actions using the shortcuts above:\n\nAdd a cell below this one.\nTurn the cell into a code cell (observe the distinct appearance of code cells).\nType the following code into the cell:\n\nprint(\"I did it!\")\n\nExecute the cell using shift + enter. Observe the output.\nDelete the cell.\nEnter edit mode for this text cell.\nAdd a sentence of your choice at the end of the cell.\n“Execute” the cell and observe the new output.\nRemove the sentence to restore the cell to it’s previous state.\n\n\n\n\n\n\n\nJupyter notebooks in this class will be a nice mix of text cells (explanation) and code cells (examples). You will soon learn that code cells produce no output unless you explicitly tell them to using a print statement (similar to the one you used above). When you encounter a code cell, you should feel free to make modifications and additions to the cell until you fully understand how the code works.\n\n\n\nComments are a way to describe what each section of code does and makes it easier for you and others to understand the code. It may seem clear what each section of code does as you write it, but after a week, month or longer, it is unlikely to be obvious. Paul Wilson of the University of Wisconson at Madison is quoted as saying, “Your closest collaborator is you six months ago, but you don’t reply to emails.” Comment your code now so that you are not confused later.\nThere are several ways to add comments to your code:\n\nUse # to start a comment. Everything on that line the follows will be ignored.\nFor longer comments that will span several lines, use triple double quotes to begin and end the comment (\"\"\")\n\nThe cell below illustrates these two ways to make comments:\n# Speed of light in a vacuum\nc = 3e8\n\nv = 300 # Speed of sound in air\n\n\"\"\"\nThe variables below are the initial conditions for a cannon\nlaunching a ball at a 30 degree angle with an initial speed of\n50 m/s.  The initial height of the cannon ball is 1000 m\n\"\"\"\nv = 50\ntheta = 30\nh_i = 1000\n\nTo Do:\n\nExecute the code block below and verify that no output is produced.\nAdd print statements that help you see the result of the calculation.\nAdd simple commments next to each line explaining the code.\n\n\na = 2 \nb = 3 \nc = a**b\nimport subprocess\nimport sys\n\ndef install(package):\n    subprocess.check_call([sys.executable, \"-m\", \"pip\", \"install\", package])\ninstall(\"numpy\")"
  },
  {
    "objectID": "chapters/variables.html",
    "href": "chapters/variables.html",
    "title": "2  Variables and Numbers",
    "section": "",
    "text": "When performing mathematical operations, it is often desirable to store the values in variables for later use instead of manually typing them back in each time you need to use them. This will reduce effort because small changes to variables can automatically propagate through your calculations.\nAttaching a value to a variable is called assignment and is performed using the equal sign (=), as demonstrated in the cell below:\na = 5.0\nb = 3\nc = a + b\n\n\nThere are some rules for allowed variable names in Python. They are as follows:\n\nVariable names must begin with a letter or an underscore (_)\nVariables names must only contain letters, numbers, and underscores.\nVariable names cannot contain spaces.\nVariables names cannot be a word reserved by Python for something else. These words are:\n\n\n\n\n\nPython\nreserved\nwords\n\n\n\n\n\nand\nas\nassert\nbreak\nclass\n\n\ncontinue\ndef\ndel\nelif\nelse\n\n\nexcept\nFalse\nfinally\nfor\nfrom\n\n\nglobal\nif\nimport\nin\nis\n\n\nlambda\nNone\nnonlocal\nnot\nor\n\n\npass\nraise\nreturn\nTrue\ntry\n\n\nwhy\nwith\nyield\n\n\n\n\n\nThe cell below contains some allowed variable names and some that are not allowed.\n\nTo Do:\n\nDetermine which variable names are allowed and which are not in the cell below.\nWhat does Python do if you try to define a variable using a name that is not allowed?\n\n\nmy1variable = 3\n1stvariables = 2\na big constant = 3\na_big_constant = 1e8\nIt is also a good practice to make variable names meaningful. For example, in the cell below we calculate \\(E = mc^2\\) using two choices for variable assignments. In one case, it is easy to determine what the calculation is and in the other it isn’t.\n# Good Variable Names\nmass_kg = 1.6\nlight_speed = 3.0e8\nE = mass_kg * light_speed**2\n\n\n# Poor Variable Names\na = 1.6\nb = 3.0e8\nc = a * b**2\n\n\n\nThere are two types of numbers in Python - floats and integers. Floats, short for “floating point numbers,” are values with decimals in them. They may be either whole or non-whole numbers such as 3.0 or 1.2, but there is always a decimal point. Integers are whole numbers with no decimal point such as 2 or 53.\nMathematical operations that only use integers and evaluate to a whole number will generate an integers (except for division). All other situations will generate a float. See the example cell below.\na = 24\nb = 6\nd = 0.3\ne = a + b # Produces an integer.\nf = a + d # Produces a float\ng = a * b # Produces a ???\nh = a / b # Produces a ???\nIntegers and floats can be interconverted to each other using the int() and float() functions.\n\nint(3.0)\nfloat(4)\n\n4.0\n\n\nThe distinction between floats and ints is often a minor detail. Occasionally, a function will require that an argument be a float or an int but usually you won’t have to worry about which one you use.\nBelow you will find some other common mathematical operations that can be performed on numerical variables.\na = 20\nb = 10\nc = a + b \nd = a/b  \nr = a//b\nr = a % b\ne = a * b\nf = c**4\n\nTo Do:\n\nUse print statements to investigate what each operation does.\n\nCan you force each operation to produce a float and an integer?\nAdd comments next to each line (Use # to start a comment) explaining that operation.\n\n\n\n\n\nAugmented assignment is a shortened way to make a simple modification to a variable. For example, if we want to increase the value of a variable by 10, one way to do it would be like this.\na = 5\na = a + 10\nThis is certainly not difficult, but it does involve typing the variable twice which becomes cumbersome as your variable name gets longer. Alternatively, we can accomplish the same thing with the += operator.\na = 5\na += 10\nAugmented assignment can be used with addition, subtraction, multiplication, and division as shown in the code cell below.\n\nTo Do:\n\nPredict what the final result of a will be in the code cell below.\nAdd an appropriately-place print statement to see if you were correct.\nIf you were wrong, pow-wow with your neighbor until you understand.\n\n\na = 7\na += 3\na -= 1\na *= 4\na /= 3\n\n\n\nAt the beginning of a program or calculation, it is often necessary to define a set of variables. Each variable may get it’s own line of code, but if there are a lot of variables, this can begin to clutter your code a little. An alternative is to assign multiple variables on a single line. In the code below, we assign the atomic mass of the first three elements.\nH, He, Li = 1.01, 4.00, 5.39\n\nTo Do:\n\nUse print statements to verify that each variable was assigned it’s own value.\nAdd assignments for the atomic masses of the next three elements on the periodic table.\n\n\n\n\n\nSometimes you find yourself working with large numbers in your calculation. Maybe your calculation involves the use of ten billion, which has 10 zeros in it. It can be difficult to look at all of those zeros with no commas to help break it up. In those cases, you can use an underscore (_) in place of the comma, as shown below.\nmyLargeNumber = 10000000000 # This is tough to look at.\nmyLargeNumber = 10_000_000_000  # This is easy to read\n\nmyLargeFloat = 5000000.6 # This is tough to read\nmyLargeFloat = 5_000_000.6 # This is easy to read\n\n\n\nIf your number is very large or very small ( \\(20-30\\) zeros), you would probably rather not have to type all of the zeros at all, even if you can break it up with the underscores. For example, the Boltzman constant, which comes up in thermodynamics, has a value equal to\n\\[ 1.38 \\times 10^{-23}\\]\nWe can avoid typing all those zeros by using scientific notation when defining the variable. (see example below) This is super handy for very large and very small number. (Numbers of both variety show up frequently in physics!)\nkB = 1.38e-23\n\n\n\nIn addition to basic mathematical functions, python contains several mathematical functions. As in mathematics, a function has a name (e.g. f) and the arguments are places inside of the parenthesis after the name. The argument is any value or piece of information fed into the function. In the case below, f requires a single argument x.\n\\[f(x)\\]\nIn the cell below, you will find several useful math equations.\n\nabs(-5.5)\nfloat(2)\nint(5.6)\nprint(1.26e-6)\nround(-5.51)\nstr(3.2)\n\n1.26e-06\n\n\n'3.2'\n\n\nIn addition to Python’s native collection of mathematical functions, there is also a math module with more mathematical functions. Think of a module as an add-on or tool pack for Python just like a library. The math module comes with every installation of python and can be imported (i.e. activated) using the import math command. After the module has been imported, any function in the module is called using math.function() where function is the name of the function. Here is a list of commonly-used function inside the math module:\n\nimport math\nmath.sqrt(4)\nmath.ceil(4.3)\nmath.cos(1.5)\nmath.sin(1.5)\nmath.degrees(6.28)\nmath.e\nmath.exp(5)\nmath.factorial(4)\nmath.log(200)\nmath.log10(1000)\nmath.radians(360)\nmath.tan(3.14)\nmath.pi\nmath.pow(2,8)\n\n256.0\n\n\n\nTo Do:\n\nUse print statements to figure out what each function in the code cell above does. Pay special attention to trigonometric function. Do these functions expect the argument to be in radians or degrees?\nAdd comments to remind yourself for later.\n\n\nThere are other ways to import functions from modules. If you only want to use a single function inside the module, you can selectively import it using from, as shown below.\n\nfrom math import radians\nradians(4)\n\n0.06981317007977318"
  },
  {
    "objectID": "chapters/variables.html#displaying-results-the-print-function.",
    "href": "chapters/variables.html#displaying-results-the-print-function.",
    "title": "2  Variables and Numbers",
    "section": "2.2 Displaying Results (The print Function).",
    "text": "2.2 Displaying Results (The print Function).\nYou have already been using the print function a little and you should have noticed that Python will not display the result of a calculation/operation unless you include a print statement. In Python, you can pretty much print() anything and Python will just dump it to screen as it pleases. However, there are times when you may want to have a little more control over your print statements. For example, maybe you’d like to print a sentence but with some numerical values inserted occasionally:\n\nage =22\ngpa = 3.58342\nc = 2.998e8\nprint(\"Hi, I am Joe. I am\", age,\" years old and my gpa is\", gpa, \" and the speed of light is\", c,\".\")\n\nHi, I am Joe. I am 22  years old and my gpa is 3.58342  and the speed of light is 299800000.0 .\n\n\nThis print statement is a little awkward and the numbers appearing probably have more digits than we’d like to see. We can improve upon this print statement using something called f-string (short for formatted strings). To build an f-string, place an “f” immediately prior to the open quote and then everywhere you want a variable to appear, just enclose it in curly braces.\n\nage =22\ngpa = 3.5\nc = 2.998e8\nprint(f\"Hi, I am Joe. I am {age} years old and my gpa is {gpa} and the speed of light is {c}.\")\n\nHi, I am Joe. I am 22 years old and my gpa is 3.5 and the speed of light is 299800000.0.\n\n\nThat’s a clever way to insert a numerical value into a string, but the last number is still displaying too many digits. To control how the numbers are formatted, we can add a format code after the variable name:\n\nage =22\ngpa = 3.5\nc = 2.998e8\nprint(f\"Hi, I am Joe. I am {age:d} years old and my gpa is {gpa:5.2f} and the speed of light is {c:8.2e}.\")\n\nHi, I am Joe. I am 22 years old and my gpa is  3.50 and the speed of light is 3.00e+08.\n\n\nThe structure of the stuff inside of the curly braces is as follows: variable:formatcode The format code indicates how you would like the variable to be formatted when it is printed. The :d indicates that the varible should be displayed as an integer and :f indicates a float. The amount of space that is allocated to display a number can be specified by placing a number in front of the :. The 5.2 in the float formatting indicates that the number should be displayed with at least 5 total spaces while displaying only 2 numbers after the decimal. A selection of some available format statements is given below.\n\n\n\n\n\n\n\nformat code\nexplanation\n\n\n\n\n{variable}\nUse the default format for the data type.\n\n\n{variable:4d}\nDisplay as an integer, allocating 4 spaces for it.\n\n\n{variable:.4f}\nDisplay as a float, with four numbers after the decimal being displayed.\n\n\n{variable:8.4f}\nDisplay as a float, allocating 8 total spaces and 4 numbers after the decimal place.\n\n\n{variable:8.4e}\nDisplay using scientific notation, allocating 8 total spaces and 4 numbers after the decimal place."
  },
  {
    "objectID": "chapters/variables.html#exercises",
    "href": "chapters/variables.html#exercises",
    "title": "2  Variables and Numbers",
    "section": "2.3 Exercises",
    "text": "2.3 Exercises\n\nCalculate the distance from the origin to the point \\((23,81)\\) usign the math.hypot() function and then using the following distance equation:\n\n\\[ d = \\sqrt{\\Delta x^2 + \\Delta y^2}\\]\n\nSolve the quadratic equation using the quadratic function below for \\(a = 1\\), \\(b = 2\\), and \\(c = 1\\).\n\n\\[ x = {- b \\pm \\sqrt{b^2 - 4 a c} \\over 2a}  \\]\n(Optics Application) 3. When light encounters an interface between two different object, the light bends as it proceeds into the second material. The index of refraction (n) determines how much bending happens. Bending is greater for materials with a bigger index of refraction."
  },
  {
    "objectID": "chapters/strings.html",
    "href": "chapters/strings.html",
    "title": "3  Working with Strings",
    "section": "",
    "text": "Another commonly-used type of data is a string of characters known simply as strings. Strings can contain a variety of characters including letters, numbers, and symbols.\n\n\nStrings are created by placing the sequence of characters in single (or double) quotes.\ntext = \"some text\"\nStrings can also be created by converting a float or an integer into a string using the str() function.\ntext = str(4.5)\nOne common error made when working with strings is to attempt to perform math with them. Python will not perform math with strings because it sees them as a series of characters and nothing more. In the cell below, we attempt to perform math with some strings.\na = \"4\"\nb = \"2\"\nc = 2\n\nd = a + b\ne = a * b\nf = b * c\n\nTo Do:\n\nUse print statements in the cell above to determine what happens when you add two strings together.\nUse print statements in the cell above to determine what happens when you multiply two strings.\nUse print statements in the cell above to determine what happens when you multiply a string and an integer.\n\n\nIf you want to know the length of a string, you can use the len() function\n\ntext = \"some text\"\nlen(text)\n\n9\n\n\nThe length of the string above is 9 because a space is a valid character.\n\n\n\nYou have been using print() statements quite a lot lately (hopefully) but you probably haven’t printed text and numbers together. To display both text and numbers in the same message, there are several options. The first is to just put multiple variables into the print() function, separating them with commas.\n\ng = 9.8\nunit = \"m/s^2\"\nprint(g,unit)\n\n9.8 m/s^2\n\n\nAnother option is to convert the number to a string and then “add” it to the other string. This creates a single string as an argument to the print() function.\n\ng = 9.8\nunit = \"m/s^2\"\nprint(str(g) + unit)\n\n9.8m/s^2\n\n\nNotice the lack of space between the number and the unit. “Adding” the two strings smashed them together exactly as they were, no spaces added. You can insert multiple numbers into a string using something called “f”-strings. (short for formatted strings). To construct an f-string, simply place an “f” in front of the string. Anytime you want to insert a number in your string, enclose it in curly braces.\n\nv = 5.0\nc = 3e8\nprint(f\"The speed of light is {c} and the speed of my car is {v}\")\n\nThe speed of light is 300000000.0 and the speed of my car is 5.0\n\n\nYou can specify how the number should be formatted by placing a : after the variable name followed by a formatting tag. Here are a few examples to explore:\n\nv1 = 5.0\nv2 = 8.3\nc = 2.998e8\nn = 2\n\nprint(f\"There are {n:d} cars traveling side by side.  One car is traveling at {v1:4.2f} m/s and the other is traveling at {v2:4.2f} m/s.  Those speeds are much smaller than the speed of light, which is {c:.2e} m/s\") \n\nThere are 2 cars traveling side by side.  One car is traveling at 5.00 m/s and the other is traveling at 8.30 m/s.  Those speeds are much smaller than the speed of light, which is 3.00e+08 m/s\n\n\nAs you can see, the formatting tag tells the print statement how the number should be printed. For float variables, the formatting tag will have two numbers followed by an “f” (for float). The first number indicates how many total spaces should be allocated to print the number and the second number specifies the number of decimal places that should be displayed. For integer variables, use the formatting tag “g”. For bigger numbers, it is often useful to print the number in scientific notation. To do this, use the “.2e” formatting tag. The number after the decimal indicates how many numbers after the decimal should be displayed.\nA summary of common format tags are given in the table below.\n\n\n\n\n\n\n\nformat code\nexplanation\n\n\n\n\n{variable}\nUse the default format for the data type.\n\n\n{variable:4d}\nDisplay as an integer, allocating 4 spaces for it.\n\n\n{variable:.4f}\nDisplay as a float, with four numbers after the decimal being displayed.\n\n\n{variable:8.4f}\nDisplay as a float, allocating 8 total spaces and 4 numbers after the decimal place.\n\n\n{variable:8.4e}\nDisplay using scientific notation, allocating 8 total spaces and 4 numbers after the decimal place.\n\n\n\n\nTo Do:\n\nModify the print statement above so that the float variables are given 8 total spaces with only 1 number after the decimal being displayed.\nModify the print statement above so that the speed of light is displayed with 3 numbers after the decimal place.\n\n\n\n\n\nAccessing a piece (or slice) of a string is a common task in scientific computing. Often you will import data into Python from a text file and need to extract a portion of the file for later use in calculations. Indexing allows the user to extract a single element, or character, from a string. The key detail about indexing in Python is that indices start from zero. That means that the first character is index zero, the second character is index 1, and so on. For example, maybe a string contains the following amino acid sequence ‘MSLFKIRMPE’. For this example, the indices are as follows:\n\n\n\nCharacters\nM\nS\nL\nF\nK\nI\nR\nM\nP\nE\n\n\n\n\nIndex\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\nTo access a single character from a string, place the desired index in square brackets after the name of the string.\n\nseq = \"MSLFKIRMPI\"\nseq[0]\n\n'M'\n\n\nTo access the last character in a string you could do\n\nseq = \"MSLFKIRMPI\"\nseq[len(seq) - 1]\n\n'I'\n\n\nBut this seems overly cumbersome. An easier approach is to index backwards. The string can be reverse indexed from the last character to the first using negative indices, starting with -1 as the last charcter.\n\nseq = \"MSLFKIRMPE\"\nseq[-1]\n\n'E'\n\n\n\nTo Do:\n\nAccess the 5th character in the peptide sequence above.\nAccess the character that is 3rd from the end in the peptide sequence above.\n\n\nIndexing only provides a single character, but it is common to want a series of characters from a string. Slicing allows us to grab a section of a string. Slicing is performed by specifying start and stop indices separated by a colon in the square brackets. One important detail worth mentioning: the character at the starting index is included in the slice while the character located at the final index is not included in the slice.\n\nseq = \"MSLFKIRMPE\"\nseq[0:5]\n\n'MSLFK'\n\n\nLooking at the string, you notice that the character at location 5 (I) has been excluded from the slice. You can leave off the first number when slicing and the slice will start at the beginning of the string.\n\nseq = \"MSLFKIRMPE\"\nseq[:5]\n\n'MSLFK'\n\n\nYou can also use negative indices when slicing. This is especially helpful when you want to grab the last few characters in a string.\nfile = \"data.txt\"\next = file[-3:]\nFinally, we can adjust the step size in the slice. That is, we can ask for every other character in the string by setting a step size of 2. The structure of the slice is [start,stop,step].\n\nseq = \"MSLFKIRMPE\"\nseq[0:8:2]\n\n'MLKR'\n\n\nYou can omit the start and stop indices and Python will assume that you are slicing the entire string.\n\nseq = \"MSLFKIRMPE\"\nseq[::2]\n\n'MLKRP'\n\n\n\n\n\nA method is a function that works only with a specif type of object. String methods only work on strings, and they don’t work on other types of objects, like floats or ints. If it helps you, you can just think of a method as a function.\nOne example of a string method is the capitalize() function which returns a string with the first letter capitalized. To use a method (referred to as calling the method), the method name is appended to the variable you want it to operate on. For example, below is an Albert Einstein quote that needs capitalized.\n\nquote = \"i want to know God's thoughts. The rest are details.\"\nquote.capitalize()\nprint(quote)\n\ni want to know God's thoughts. The rest are details.\n\n\nNotice that the original variable (quote) remains unchanged. This particular method does not change the value of the original string but rather returns a capitalized version of it. If we want to save the capitalized version, we can assign it to a new variable, or overwrite the original.\n\nquote = \"i want to know God's thoughts. The rest are details\"\nquote = quote.capitalize()\nprint(quote)\n\nI want to know god's thoughts. the rest are details\n\n\nIn the cell below you will find a list of commonly-used string methods.\n\na = \"spdfgssfpggg\"\na.capitalize()\na.center(10)\na.count(\"s\")\na.find(\"d\")\na.isalnum()\na.isalpha()\na.isdigit()\na.lstrip(\"s\")\na.rstrip(\"g\")\na.split(\"s\")\na.startswith(\"s\")\na.endswith(\"p\")\n\nFalse\n\n\n\nTo Do:\n\nUse well-placed print statements to determine what each string method does.\nAdd comments next to each method for future reference."
  },
  {
    "objectID": "chapters/strings.html#exercises",
    "href": "chapters/strings.html#exercises",
    "title": "3  Working with Strings",
    "section": "3.2 Exercises",
    "text": "3.2 Exercises\n\nRemoving file ext\n\n\\[ d = \\sqrt{\\Delta x^2 + \\Delta y^2}\\]\n\nSolve the quadratic equation using the quadratic function below for \\(a = 1\\), \\(b = 2\\), and \\(c = 1\\).\n\n\\[ x = {- b \\pm \\sqrt{b^2 - 4 a c} \\over 2a}  \\]"
  },
  {
    "objectID": "chapters/booleans.html",
    "href": "chapters/booleans.html",
    "title": "4  Boolean Variables and Conditionals",
    "section": "",
    "text": "We have learned about three types of variables in Python: ints, floats, and strings. Another variable type is a boolean, which can be one of two values: True or False. You can assign a boolean variable in the same way that you assign numbers or string, using =\nmyBool = True\nTrue must be capitalized so don’t try true or it won’t be a boolean\nmyBool = true\n\n\nOften you will want to check to see if some condition is true. For example, maybe you want to know if the radius of a certain satellite’s orbit is bigger or smaller than Mercury’s orbit. To perform this check, there are several boolean operators that will return True or False. Take note of the boolean operators shown in the cell below along with the comments added to explain what they do.\n\nr1 = 3.5e8\nr2 = 2.7e6\n\nr1 > r2 # Is r1 greater than r2\nr1 < r2 # Is r1 less than r2\nr1 >= r2 # Is r1 greater than or equal to r2\nr1 <= r2 # Is r1 less than or equal to r2\nr1 != r2 # Is r1 not equal to r2\nr1 == r2 # Is r1 equal to r2\n\nFalse\n\n\nA word of caution about comparing Python floats using == is in order here. Python floats are stored as a 53-digit, base-2 binary number(that’s a mouthful). If you’re interested in what that means, we can talk more. If you’re not that interested, just know that when you define a float in Python, the number that is stored in the computer is not exactly the number that you think it is. This can cause problems when you are comparing two numbers that you think should be equal but actually aren’t equal in the computer.1 The code below illustrates this problem.\n\na = 0.1\nb = 3 * a\nc = 0.3\nprint(b==c)  # Are they the same number?  You would think they would\n             # be right?\nprint(\" {:.5f} \".format(b))     # It sure looks like they are the same.\nprint(\" {:.5f} \".format(c))     # It sure looks like they are the same.\nprint(\" {:.45f} \".format(b))  #b--- out to 45 decimal places\nprint(\" {:.45f} \".format(c))  #c--- out to 45 decimal places\n\nFalse\n 0.30000 \n 0.30000 \n 0.300000000000000044408920985006261616945266724 \n 0.299999999999999988897769753748434595763683319 \n\n\nThe first two print statements display the value of b and c to five decimal places. The second two print statements force Python to display the value of b and c out to 45 decimal places. Notice that the true value of b is not exactly equal to 0.3. This is why the statement print(b==c) returns False. The take home message here is that comparing two floats to see if they are equal is always a bad idea. A better way to check to see if two floats are equal (or close enough that we can say they are equal) is to check if the absolute value of their difference is very small, like this:\n\na = 0.1\nb = 3 * a\nc = 0.3\nprint(abs(b - c) < 1e-10)\n\nTrue\n\n\n\n\n\nComparisons like those shown above can be chained together to make compound comparisons using the and, or, and not operators.\n\n\n\nOperator\nDescription\n\n\n\n\nand\nTests for both being True\n\n\nor\nTests for either being True\n\n\nnot\nTests for False\n\n\n\nThe and operator requires both inputs to be True in order to return True while the or operator requires only one input to be True in order to evaluate at True. The not operator is different in that it only takes a single input value and returns True if and only if the input is False. It is a test for False.\nTruth tables are a good way to visualize the output from compound comparisons.\n\n\n\np\nq\np and q\np or q\n\n\n\n\nTrue\nTrue\nTrue\nTrue\n\n\nTrue\nFalse\nFalse\nTrue\n\n\nFalse\nTrue\nFalse\nTrue\n\n\nFalse\nFalse\nFalse\nFalse\n\n\n\nAs a simple example, suppose you know the density (\\(\\rho\\)) and speed of light (c) for two materials and you’d like to know if both values are bigger for material 1 or material 2.\n\nTo Do:\n\nPredict the output for each compound comparison given below. Add your guess as a comment.\nNow add appropriately-placed print statements to check your guesses.\nModify your guess as needed and discuss any questions with a neighbor.\n\n\n\nc1 = 2.5e8\nc2 = 2.48e8\nρ1 = 450\nρ2 = 580\n\nc1 > c2 and ρ1 > ρ2\nc1 < c2 and ρ1 < ρ2\nc1 > c2 and ρ1 < ρ2\nc1 < c2 and ρ1 > ρ2\n\nc1 > c2 and not ρ1 > ρ2\nc1 < c2 and not ρ1 < ρ2\n\nc1 > c2 or ρ1 > ρ2\nc1 < c2 or ρ1 < ρ2\n\nTrue\n\n\n\n\n\nYou can check for inclusion using the Python in operator. This provides an easy way to see if a character (or word) is present in a long string. Let’s say you have a long string that contains the names of Jupyter’s moons (there are 79 of them!!) and you want to see if a certain moon is included in the list. The in statement let’s us quickly test to see if it is in the list. (see example below)\n\njupytermoons = \"Metis,Adrastea,Amalthea,Thebe,Io,Europa,Ganymede,Callisto,Themisto,Leda,Himalia,Lysithea,Elara,Dia,Carpo,Euporie,Thelxinoe,Euanthe,Helike,Orthosie,Iocaste,Praxidike,Harpalyke,Mneme,Hermippe,Thyone,Ananke,Herse,Aitne,Kale,Taygete,Chaldene,Erinome,Aoede,Kallichore,Kalyke,Carme,Callirrhoe,Eurydome,Pasithee,Kore,Cyllene,Eukelade,Pasiphae,Hegemone,Arche,Isonoe,Sinope,Sponde,Autonoe,Megaclite\"\n\n\"Cyllene\" in jupytermoons\n\nTrue"
  },
  {
    "objectID": "chapters/booleans.html#conditions",
    "href": "chapters/booleans.html#conditions",
    "title": "4  Boolean Variables and Conditionals",
    "section": "4.2 Conditions",
    "text": "4.2 Conditions\nConditions allow the user to specify if and when certain lines or blocks of code are executed. Specifically, when a condition is true, the block of indented code directly below it will run.\n\n4.2.1 if statement\nThe if statement is used to control when a block of code runs. It’s usage is shown below ending in a colon and the block of code below indented with four spaces. Using the Tab key will also produce four spaces.\n\njupytermoons = \"Metis,Adrastea,Amalthea,Thebe,Io,Europa,Ganymede,Callisto,Themisto,Leda,Himalia,Lysithea,Elara,Dia,Carpo,Euporie,Thelxinoe,Euanthe,Helike,Orthosie,Iocaste,Praxidike,Harpalyke,Mneme,Hermippe,Thyone,Ananke,Herse,Aitne,Kale,Taygete,Chaldene,Erinome,Aoede,Kallichore,Kalyke,Carme,Callirrhoe,Eurydome,Pasithee,Kore,Cyllene,Eukelade,Pasiphae,Hegemone,Arche,Isonoe,Sinope,Sponde,Autonoe,Megaclite\"\n\nif \"Cyllene\" in jupytermoons:\n    found = True\n    print(\"Found Cyllene in the list\")\n    \nif \"Matis\" in jupytermoons:\n    found = True\n    print(\"Found Matis in the list\")\n\nFound Cyllene in the list\n\n\nIf the boolean statement after if is true, the indented code below it will run. If the statement is false, Python just skips the indented lines below.\n\n\n4.2.2 else Statment\nSometimes there will be an alternate block of code that you want to run if the if statement evaluates to False. The else statement is used to specify this block of code, as shown below.\n\njupytermoons = \"Metis,Adrastea,Amalthea,Thebe,Io,Europa,Ganymede,Callisto,Themisto,Leda,Himalia,Lysithea,Elara,Dia,Carpo,Euporie,Thelxinoe,Euanthe,Helike,Orthosie,Iocaste,Praxidike,Harpalyke,Mneme,Hermippe,Thyone,Ananke,Herse,Aitne,Kale,Taygete,Chaldene,Erinome,Aoede,Kallichore,Kalyke,Carme,Callirrhoe,Eurydome,Pasithee,Kore,Cyllene,Eukelade,Pasiphae,Hegemone,Arche,Isonoe,Sinope,Sponde,Autonoe,Megaclite\"\n\nif \"Cyllene\" in jupytermoons:\n    found = True\n    print(\"Found Cyllene in the string\")\nelse:\n    found = False\n    print(\"Did not find Cyllene in the string\")\n\n    \nif \"Matis\" in jupytermoons:\n    found = True\n    print(\"Found Matis in the string\")\nelse:\n    found = False\n    print(\"Did not find Matis in the string\")\n\nFound Cyllene in the string\nDid not find Matis in the string\n\n\nNotice that the else statement must be followed by a colon and the block of code to be executed is indented, just as in the if block.\nThere is an additional statement called the elif statement, short for “else if”, which is used to add extra conditions below the initial if statement. The block of code below the elif statement only runs if the if statement is false and the elif statement is true. An example is given below.\n\njupytermoons = \"Metis,Adrastea,Amalthea,Thebe,Io,Europa,Ganymede,Callisto,Themisto,Leda,Himalia,Lysithea,Elara,Dia,Carpo,Euporie,Thelxinoe,Euanthe,Helike,Orthosie,Iocaste,Praxidike,Harpalyke,Mneme,Hermippe,Thyone,Ananke,Herse,Aitne,Kale,Taygete,Chaldene,Erinome,Aoede,Kallichore,Kalyke,Carme,Callirrhoe,Eurydome,Pasithee,Kore,Cyllene,Eukelade,Pasiphae,Hegemone,Arche,Isonoe,Sinope,Sponde,Autonoe,Megaclite\"\n\nif \"Matis\" in jupytermoons:\n    foundMatis = True\n    print(\"Found Matis in the string\")\nelif \"Cyllene\" in jupytermoons:\n    foundCyllene = True\n    print(\"Found Cyllene in the string.\")\nelse:\n    foundCyl = False\n    foundMatis = False\n    print(\"Did not find Cyllene or Matis in the string\")\n\nFound Cyllene in the string.\n\n\nIt is worth noting that else statements are not required. If you leave the else statement off and the if statement is false, no code block will execute."
  },
  {
    "objectID": "chapters/listsAndTuples.html",
    "href": "chapters/listsAndTuples.html",
    "title": "5  Lists and Tuples",
    "section": "",
    "text": "Up to this point, we have only worked with single numerical values or strings (multiple characters). Often we will want to work with collections of values (perhaps the orbital period of all of the planets in our solar system.) and it will be quite inconvenient to store each value into its own variable. Instead, the values can be stored in a list or tuple. Lists and tuples are both collections of elements , like numbers or strings. The key difference between them is that tuples are immutable, which means they cannot be modified after their initial creation. On the other hand, lists are mutable, or able to be modified."
  },
  {
    "objectID": "chapters/listsAndTuples.html#creating-lists",
    "href": "chapters/listsAndTuples.html#creating-lists",
    "title": "5  Lists and Tuples",
    "section": "5.1 Creating Lists",
    "text": "5.1 Creating Lists\nThe easiest way to create a list is by putting the list elements inside of square brackets. Below, we create a list containing the masses of all of the planets in our solar system.\nmass = [1.8986e27,5.6846e26,10.243e25,8.6810e25,5.9736e24,4.8685e24,6.4185e23,3.3022e23]\nNote that square brackets ([]) must be used when creating the list. If you accidentally use parenthesis (())1 or curly brackets ({})2 you’ll end up creating something other than a list.1 Use parenthesis to create a tuple, which is just like a list but cannot be modified.2 Use curly brackets to create a dictionary, which is like a list but can be indexed on any data type, not just integers.\nLists can contain any type of data and the type of data doesn’t have to be the same for all of the elements. Below, we create a list of the electron configurations for the first 10 elements on the periodic table.\nelectrons = [\"1s1\",\"1s2\", \"1s2-2s1\",\"1s2-2s2\",\"1s2-2s2-2p1\",\"1s2-2s2-2p2\",\"1s2-2s2-2p3\",\"1s2-2s2-2p4\",\"1s2-2s2-2p5\",\"1s2-2s2-2p6\"]\nLists can contain mixed data types. Below we construct a list of the electrical conductivities of three metals.\nconductivity = [\"Gold\",4.10e7,\"Copper\",5.96e7,\"Aluminum\",3.5e7]\nIf the elements of a list are also lists, we call it a nested list.\nconductivity = [[1,2,3],[4,5,6],[7,8,9]]"
  },
  {
    "objectID": "chapters/listsAndTuples.html#indexing-and-slicing-lists",
    "href": "chapters/listsAndTuples.html#indexing-and-slicing-lists",
    "title": "5  Lists and Tuples",
    "section": "5.2 Indexing and Slicing Lists",
    "text": "5.2 Indexing and Slicing Lists\nIndexing is used to access individual elements of a list, and it is similar to indexing strings. The index is the position of the desired element in the list and the index numbering starts at zero. Accessing an element of a list is done by placing the numerical index of the element we want in square brackets behind the list name. For example, if we want the electron configuration of the first element in our list from above, we use electrons[0] and the electron configuration for the second element would be electrons[1] and so on. Just as with string, negative indices can be used to access list elements counting from the back of the list forward.\nelectrons = [\"1s1\",\"1s2\", \"1s2-2s1\",\"1s2-2s2\",\"1s2-2s2-2p1\",\"1s2-2s2-2p2\",\"1s2-2s2-2p3\",\"1s2-2s2-2p4\",\"1s2-2s2-2p5\",\"1s2-2s2-2p6\"]\n\nelectrons[1]\nelectrons[-2]\nelectrons[5]\n\nTo Do:\n\nPredict the output for each of the indexes performed in the cell above.\nUse print statements to check your answers.\nDiscuss any misunderstandings with a peer.\n\n\nSince lists are mutable, we can modify the value of an element in a list using the = operator.\n\nconductivity = [\"Gold\",4.10e7,\"Copper\",5.96e7,\"Aluminum\",3.5e7]\n\nconductivity[1] = 4.15e7\nconductivity\n\n['Gold', 41500000.0, 'Copper', 59600000.0, 'Aluminum', 35000000.0]\n\n\n\nTo Do:\nUse a print statement to verify that the conductivity list was indeed modified as expected.\n\nMultiple list elements can be retrieved at once (called slicing) by including the start and stop indices separated by a colon: [start:stop:step]. A convention that occurs throughout python is that the first index is included in the slice but the second is not. (i.e. [included: excluded: step]) Default values for the start location, stop location, and step sizes will be used if these values are omitted. Below we give some examples of slicing.\nelectrons = [\"1s1\",\"1s2\", \"1s2-2s1\",\"1s2-2s2\",\"1s2-2s2-2p1\",\"1s2-2s2-2p2\",\"1s2-2s2-2p3\",\"1s2-2s2-2p4\",\"1s2-2s2-2p5\",\"1s2-2s2-2p6\"]\n\nelectrons[1:]\nelectrons[1:3]\nelectrons[:3]\nelectrons[1:8:2]\nelectrons[5:2:-1]\n\nTo Do:\n\nPredict the output for the five slices in the cell above.\nUse print statements to check your answers.\nDiscuss any misunderstandings with a peer.\n\n\n\n5.2.1 Tests for Inclusion\nJust as with strings, the in operator can be used with lists to determine if a list element is present. Suppose you have a list of all the known radioactive elements on the periodic table and you’d like to know if Iridium is in the list. The in statement let’s us quickly test to see if it is in the list. (see example below)\n\nradioactiveElements = [\"Technetium\",\"Promethium\",\"Polonium\",\"Astatine\",\"Radon\",\"Francium\",\"Radium\", \"Actinium\", \"Thorium\", \"Protactinium\",\"Uranium\",\"Neptunium\",\"Plutonium\",\"Americium\",\"Curium\",\"Berkelium\",\"Californium\",\"Einsteinium\",\"Fermium\",\"Mendelevium\",\"Nobelium\",\"Lawrencium\",\"Rutherfordium\",\"Dubnium\",\"Seaborgium\",\"Bohrium\",\"Hassium\",\"Meitnerium\",\"Darmstadtium\",\"Roentenium\",\"Copernicium\",\"Nihonium\",\"Flerovium\",\"Moscovium\",\"Livermorium\",\"Tennessine\", \"Oganesson\"]\n\n\"Iridium\" in radioactiveElements\n\nFalse\n\n\nThe in operator will work with numerical data as well.\n\nnumbers = [5,6,3,1,2]\n\n4 in numbers\n\nFalse\n\n\n\n\n5.2.2 List Methods\nLists have a collection of methods (or functions) for accomplishing routine tasks. Some of the more common list methods are given below. All of the methods given will modify the original list (except copy()). As a reminder, methods only work on the object type that they were designed for (lists in this case) and they are called by appending the method name to the variable you want it to operate on. (i.e. myList.clear())\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\nappend(element)\nAdds a single element to the end of the list.\n\n\nclear()\nRemoves all elements from a list.\n\n\ncopy()\nCreates an independent copy of the list.\n\n\ncount(element)\nCounts the number of occurences of element in the list.\n\n\nextend(elements)\nAdds multiple elements to the end of the list.\n\n\nindex(element)\nReturns the index of the first occurrence of element.\n\n\ninsert(index,element)\nInserts the given element at the specified index.\n\n\npop(index)\nRemoves and returns the element given at index. If no index is provided, it defaults to the last element.\n\n\nremove(element)\nRemoves the first occurrence of element in the list.\n\n\nreverse()\nReverses the order of the entire list.\n\n\nsort()\nSorts the list in place.3\n\n\n\n3 It modifies the original list. In contrast, the function sorted() will leave the original list unchanged.a = [5,6,23,2,2,6]\na.sort()\n\nTo Do:\n\nIn the cell below, you will find a list of …\n\n\n\n\n5.2.3 Built-in functions for Lists\nPython has several built-in functions that will work with lists. Functions are called by placing the arguments to the function in parenthesis and prepending the name of the function to the parenthesis. Here are a few common functions that are used with lists:\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\nlen(list)\nReturns the number of elements in the list.\n\n\nmax(list)\nFinds the largest element in the list.\n\n\nmin(list)\nFinds the smallest element in the list.\n\n\nsum(list)\nReturns the sum of the elements in the list.4\n\n\nlistOne + listTwo\nJoins listOne with listTwo to form one list.\n\n\n2 * list\nRepeat list and concenate to itself, making the list twice as long.\n\n\nzip(listOne,listTwo)\nZips two lists together. (Creates [a1,b1,a2,b2...] from [a1,a2,a3...] and [b1,b2,b3...]\n\n\n\n4 Only works if the list contains only ints and floats\na = [\"l\",\"j\",\"n\"]\nb = [\"r\",\"s\",\"t\"]\na + b\n#a=[5,6,2]\n#min(a)\n#print(\"l\" + \"j\"+\"n\")\n\n['l', 'j', 'n', 'r', 's', 't']\n\n\n\n\n5.2.4 The range function\nOften it will be necessary to generate a (possibly very long) list of integers. Instead of constructing the list by typing these numbers one by one, Python has a built-in function called range() that will do it for you. The range() function requires at least one argument to tell it how high the range should be.\n\na = range(10)  # Generate a list of integers up to 10\na\n\nrange(0, 10)\n\n\nThis output probably wasn’t what you expected. Instead of generating the full list of numbers, Python generates a range object that stands in place of it because it requires less memory. (Consider what might happen to your memory if you did range(1000000000000).) To force Python to generate the list, you can convert the range object using the list() function.\n\na = range(10)  # Generate a list of integers up to 10\nlist(a)\n\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\nThe range function can be called with up to three arguments: range(start,end,stepsize). Consistent with indexing, the range includes the start value and excludes the end value. Below we generate a list of integers starting at 5, ending at 100 with a stepsize of 5.\n\nmyList = range(5,100,5)\nlist(myList)\n\n[5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95]"
  },
  {
    "objectID": "chapters/listsAndTuples.html#tuples",
    "href": "chapters/listsAndTuples.html#tuples",
    "title": "5  Lists and Tuples",
    "section": "5.3 Tuples",
    "text": "5.3 Tuples\nTuples are another object type similar to lists except that they are immutable… that is to say, they cannont be modified once created. They look similar to lists except that they are created using parenthesis instead of brackets. Because you can’t change the elements of a tuple, they are often used so that you don’t inadvertently modify (and lose) critical data. You can think of it as locking a file on your computer to avoid indavertently modifying it and losing the original content.\nBelow is a tuple containing… Since there will be no need to change these values, it makes sense to store them in a tuple. Indexing and slicing work exactly the same as with lists and strings, so we can still use the values inside of a tuple to perfrom simple calculations. There are only two methods associated with tuples: count(element) and index(element). Their usage is identical to the list methods.\n\nenergies = (5,7,2,4,3,2,3)\nenergies.index(7)\nlen(energies)\n\n7"
  },
  {
    "objectID": "chapters/loops.html",
    "href": "chapters/loops.html",
    "title": "6  Loops",
    "section": "",
    "text": "Loops allow programs to rerun the same block of code multiple times. This is important because there are often"
  },
  {
    "objectID": "chapters/loops.html#for-loops",
    "href": "chapters/loops.html#for-loops",
    "title": "6  Loops",
    "section": "6.1 for loops",
    "text": "6.1 for loops\nThe for loop is probably the most common loop you will encounter and is a good choice when you know beforehand exactly what things you want to loop over. Here is an example of of for loop that is used to add up the elements of a list.\nthesum = 0\nfor i in [3,2,1,9.9]: \n    thesum = thesum + i\nThis would be equivalent to the following code:\nthesum = 0\n\nthesum = thesum + 3\nthesum = thesum + 2\nthesum = thesum + 1\nthesum = thesum + 9.9\nwhich isn’t that much longer than using a loop. However, as the list gets longer and/or the mathematical operations being performed get more complex the second method would get unreasonably long. The correct language is to say that we are iterating over the list [3,2,1,9.9]. This means that the loop variable (i in this case but you can choose it to be whatever you want) gets assigned the values of the list elements, one by one, until it reaches the end of the list. You can use for loops to iterate over any multi-element object like lists or tuples. Python uses indentation to indicate where the loop ends. In this case there was only one statement inside to loop, but if you wanted more than one each line should be indented.\nYou can iterate over range objects and strings using for loops.\n\nfor i in ['Physics', 'is','so','fun']: # Iterate over a list of strings\n    print(i)\n\nPhysics\nis\nso\nfun\n\n\n\nfor i in range(5,50,3):  #Generates a list from 5 -> 50 with a step size of 3\n    print(i)\n\n5\n8\n11\n14\n17\n20\n23\n26\n29\n32\n35\n38\n41\n44\n47\n\n\nThese examples are so simple that you might wonder when a loop might actually be useful to you. Let’s see if we can build a loop to calculate the following sum\n\\[ \\sum_{n=1}^{1000} {1\\over n^2} \\tag{6.1}\\]\n\ntheSum = 0\nfor n in range(1,1000):\n    theSum = theSum + 1/n**2\nprint(theSum)\n\n1.6439335666815615\n\n\nHere, n is being assigned the values 1,2,3,4....1000, one by one, until it gets all the way to 1000. Each time through the loop, n is different and the expression 1/n**2 evaluates to a new value. The variable theSum is updated each time through to be the running total of all calculations performed thus far. Here’s another example of a loop used to calculate the value of \\(20!\\):\n\ntheProduct = 1\nfor n in range(1,21):\n    theProduct = theProduct * n #Multiply theProduct by n\nprint(theProduct)\n\n2432902008176640000\n\n\nRemember that the range function creates a list starting at \\(1\\), going up to \\(21\\) but not including it. The math library has a function called factorial that does the same thing. Let’s use it to check our answer:\n\nfrom math import factorial\nfactorial(20)\n\n2432902008176640000\n\n\n\n6.1.1 Boolean Logic Inside Loops\nOften when using loops, we only want a block of code to execute when some condition is satisfied. We can use boolean logic inside of the loop to accomplish this. For example, let’s write a loop to compute the following sum:\n\\[ \\sum_{{n\\over 5} \\in \\text{ Int and } {n\\over 3} \\in \\text{ Int}} {1\\over n^2} \\]\nwhich is similar to the one we did above, but this time we only want to include terms where \\(n\\) is a perfect multiple of both 5 and 3. To check to see if n is a perfect multiple of a number we can calculate the modulo (remainder after division) using the % operator and check that it is equal to zero.\n\ntheSum = 0\nfor n in range(1,1000):\n    if n % 5 == 0 and n % 3 == 0:\n        theSum = theSum + 1/n**2\nprint(theSum)\n\n0.007243985583159138"
  },
  {
    "objectID": "chapters/loops.html#while-loops",
    "href": "chapters/loops.html#while-loops",
    "title": "6  Loops",
    "section": "6.2 while Loops",
    "text": "6.2 while Loops\nLogic can be combined with loops using something called a while loop. A while loop is a good choice when you don’t know beforehand exactly how many iterations of the loop will be executed but rather want the loop to continue to execute until some condition is met. As an example, notice that in in equation (Equation 6.1), the terms in the sum get progressively smaller as \\(n\\) gets bigger. It doesn’t make sense to continue adding to the sum once the terms get very small. Let’s compute this sum by looping until the fraction \\({1 \\over n^2}\\) become smaller than \\(1 \\times 10^{-10}\\).\nterm = 1  # Load the first term in the sum\ns = term  # Initialize the sum\nn = 1     # Set a counter\nwhile term > 1e-10:  # Loop while term is bigger than 1e-10\n    n = n +  1        #Add 1 to n so that it will count: 2,3,4,5\n    term = 1./n**2    # Calculate the next term to add\n    s = s +  term     # Add 1/n^2 to the running total\nThis loop will continue to execute until term<1e-10. Note that unlike the for loop, here you have to do your own counting if you need to know how many iterations have been performed. Be careful about what value n starts at and when it is incremented (n = n + 1). Also notice that term must be assigned prior to the start of the loop. If it wasn’t the loop’s first logical test would fail and the loop wouldn’t execute at all.\nwhile loops should be used with caution because you can easily write a faulty termination condition and inadveratently write a loop that runs forever. This happens because your termination condition was never met. An example of this is given below.\nWarning: Do not execute the code block below!!\nx = 0\n\nwhile x != 10:\n    x = x + 3\nprint(\"Done\")\nThe loop above is intended to end after a few interations when the value of x is equal to 10. However, closer inspection reveals that the value of x will never be equal to 10. After the first iteration x is equal to 3, then 6,9,12,15 and so on… but never 10. This loop will run forever because the termination condition is never met (x != 10 never produces a False)!! If you choose to use a while loop, triple check your termination condition to make sure you haven’t made a mental error. Avoiding the use of != or == in your termination condition will help too. Use <= or >= instead."
  },
  {
    "objectID": "chapters/loops.html#continue-break-and-pass-commands",
    "href": "chapters/loops.html#continue-break-and-pass-commands",
    "title": "6  Loops",
    "section": "6.3 continue, break, and pass Commands",
    "text": "6.3 continue, break, and pass Commands\nThe continue, break, and pass commands are used to control the flow of code execution in loops. Here is a description of their usage:\n\n\n\n\n\n\n\nOperator\nDescription\n\n\n\n\nbreak\nExits a for/while loop.\n\n\ncontinue\nSkips the remaining loop block and begins the next iteration.\n\n\npass\nNo action; code contiues on\n\n\n\nThe break statement is useful when you want to completely stop a loop early. Here is our sum loop rewritten with a break statement added to stop the loop after 1000 iterations.\n\nterm = 1  # Load the first term in the sum\ns = term  # Initialize the sum\nn = 1     # Set a counter\nwhile term > 1e-10:  # Loop while term is bigger than 1e-10\n    n +=  1        #Add 1 to n so that it will count: 2,3,4,5\n    term = 1./n**2    # Calculate the next term to add\n    s += term     # Add 1/n^2 to the running total\n    if n > 1000:\n        print('This is taking too long. I''m outta here...')\n        break\n\nThis is taking too long. Im outta here...\n\n\nThe continue statement is similar to break except that instead of stopping the loop, it only stops the current iteration of the loop. All code below the continue statement will be skipped and the next iteration will begin. For example, if you wanted to do the sum from equation ?? but only include those terms for which n is a multiple of 3, it could be done like this:\nterm = 1  # Load the first term in the sum\ns = term  # Initialize the sum\nn = 1     # Set a counter\nwhile term > 1e-10:  # Loop while term is bigger than 1e-10\n    n +=  1        #Add 1 to n so that it will count: 2,3,4,5\n    if n % 3 != 0:\n        continue\n    term = 1./n**2    # Calculate the next term to add\n    s += term     # Add 1/n^2 to the running total\nNow, when the value of n is not a multiple of 3, the sum will not be updated and the associated terms are effectively skipped.\nFinally, the pass statement does nothing. Seriously!! It is merely a place holder for code that has not bee written yet. Usually, you’ll use the pass statement to run and test code without errors due to missing code."
  },
  {
    "objectID": "chapters/functions.html",
    "href": "chapters/functions.html",
    "title": "7  Functions",
    "section": "",
    "text": "We have already been using functions here and there but in this chapter we will introduce them formally and get into the details. A function encapsulates a block of code designed to perform a specific task or set of tasks. To perform the task correctly, most functions require that you provide some information (called arguments) when you call them. To call a function you type the name of the function followed by the needed arguments enclosed in parenthesis (()).\nThe number and type of arguments allowed is different for every function. As a first example, let’s consider the print function, which is the simplest (and most familiar) function that we have used so far.\nPython functions generally fall into three groups: functions that come standard with Python (called native functions), functions that you can import into Python, and functions that you write yourself."
  },
  {
    "objectID": "chapters/functions.html#native-functions",
    "href": "chapters/functions.html#native-functions",
    "title": "7  Functions",
    "section": "7.1 Native Functions",
    "text": "7.1 Native Functions\nThere are a few functions that are always ready to go whenever you run Python. They are included with the programming language. We call these functions native functions. You have already been using some of them, like these\nmyList = [5,6,2,1]\na = len(myList)  # 'len' function is native.\n\nb = float(5) # 'float' function is native.\n\nc = str(67.3)  # 'str' function is native.\nThe len, float and str functions are all native and they all take a single argument. Othere native function have been mentioned in previous chapters and others will be mentiond in the future."
  },
  {
    "objectID": "chapters/functions.html#imported-functions",
    "href": "chapters/functions.html#imported-functions",
    "title": "7  Functions",
    "section": "7.2 Imported Functions",
    "text": "7.2 Imported Functions\nMany times, you will need to go beyond what Python can do by itself2. However, that doesn’t mean you have to create everything you need to do from scratch. Most likely, the function that you need has already been coded. Somebody else created the function and made it available to anyone who wants it. Groups of functions that perform similar tasks are typically bundled together into libraries ready to be imported so that the functions that they contain can be used.2 For example, Python does not include \\(\\sin()\\) or \\(\\cos()\\) as Native functions.\nIn order to use use a function correctly, you’ll need to know what information(arguments) the function expects you to give it and what information the function intends to return to you as a result. This information can be found in the library’s documentation. Most libraries have great documentation with lists of the included functions, what the functions do, the expected arguments, and examples on how to use the most common ones. You can usually find the library documentation by searching the internet for the library’s name plus “Python documentation”.\nProviding a complete list of all available libraries and function is not really the purpose of this book. Instead, we’ll illustrate how to import functions and use them. As you use Python more and more you should get in the habit of searching out the appropriate library to accomplish the task at hand. When faced with a task to accomplish, your first thought should be, “ I’ll bet somebody has already done that. I’m going to try to find that library.”\nFunctions are imported using the import statement. You’ve already seen how to perform very simple mathematical calculations (\\(5/6\\),\\(84\\), etc..), but for more complex mathematical calculations like \\(\\sin( {\\pi \\over 2} )\\) or \\(e^{2.5}\\) , you’ll need to import these functions from a library.\nimport math\n\na = math.sqrt(5.2)\nb = math.sin(math.pi)\nc = math.e**2.5\nThe math. before each function is equivalent to telling Python “Use the sqrt() function that you will find in the math book I told you to grab.” If you just type\nsqrt(5.2)\nPython won’t know where to find the sqrt function and an error message will result. Sometimes the name of the module can be long and typing module. every time you want to use one of it’s functions can be cumbersome. One way around this is to rename the module to a shorter name using the as statement.\nimport math as mt\n\na = mt.sqrt(5.2)\nb = mt.sin(mt.pi)\nc = mt.e**2.5\nInstead of importing an entire module, you can import only a selection of functions from that module using the from statement. This can make your code even more succinct by eliminating the module. prefix altogether. The trade-off is that it won’t be as clear which function belongs to which module.\nfrom math  import sqrt, sin, pi, e\n\na = sqrt(5.2)\nb = sin(pi)\nc = e**2.5\nAll of the functions belonging to a module can be imported at once using *.\nfrom math import *\n\na = sqrt(5.2)\nb = sin(pi)\nc = e**2.5"
  },
  {
    "objectID": "chapters/functions.html#user-defined-functions",
    "href": "chapters/functions.html#user-defined-functions",
    "title": "7  Functions",
    "section": "7.3 User-defined Functions",
    "text": "7.3 User-defined Functions\nAfter having programmed for a while, you will notice that certain tasks get repeated frequently. For example, maybe in your research project you need to calculate the force exerted on an atom due to many other nearby atoms. You could copy and paste your force-calculation code every time it was needed, but that would likely result in lots of extra code and become very cumbersome to work with. You can avoid this by creating your own function to calculate the force between any two atoms. Then, every time you need another force calculation, you simple call the function again. You only write the force-calculation part of the code once and then you execute it as many times as you need to.\nTo create your own function, you first need to name the function. The name should be descriptive of what it does and makes sense to you and anyone else who might use it. The first line of a function definition starts with the def statement (short for definition) followed by the name of the function with whatever information, called arguments, that needs to be fed into the function enclosed in parenthesis. The last character in this line must be a colon. Everything inside the function is indented four spaces and placed directly below the first line.\ndef functionName(arg1,arg2,arg3):\n    # Body of Function\n    # Body of Function\n    # Body of Function\nAs an example, let’s construct a function that calculates the distance between two atoms. The function will need to know the location of each atom, which means that there should be two arguments: the xyz coordinates of both atoms passed as a pair of lists or tuples.\n\nimport math\n\ndef distance(coords1,coords2):\n\n    dx = coords1[0] - coords2[0]\n    dy = coords1[1] - coords2[1]\n    dz = coords1[2] - coords2[2]\n    d = math.sqrt(dx**2 + dy**2 + dz**2)\n    print(f\"The distance is {d:5.4f}.\")\n\ndistance([1,2,3],[4,5,6])\n\ndistance([4.2,9.6,4.8],[2.9,2.6,3.4])\n\nThe distance is 5.1962.\nThe distance is 7.2560.\n\n\nThis function works just fine with integers or floats for the coordinates.\n\n7.3.1 The return statement\nThe distance function prints out the value for the distance, but what if we want to use this distance in a subsequent calculation? Maybe we want to calculate the average distance between several pairs of atoms. We can instruct the function to return the final distance using the return statement. If the arguments to the function are the inputs, the return statement specifies what the output is. Let’s modify the function above to include a return statement.\n\nimport math\ndef distance(coords1,coords2):\n    dx = coords1[0] - coords2[0]\n    dy = coords1[1] - coords2[1]\n    dz = coords1[2] - coords2[2]\n    d = math.sqrt(dx**2 + dy**2 + dz**2)\n    return d\n\ndistOne = distance([1,2,3],[4,5,6])\n\ndistTwo = distance([4.2,9.6,4.8],[2.9,2.6,3.4])\n\naverageDistance = (distOne + distTwo)/2\n\nprint(f\"The average distance is {averageDistance:5.4f}.\")\n\nThe average distance is 6.2261.\n\n\n\n\n7.3.2 Local vs Global Variable Scope\nVariables created inside of a function have local scope. This means that they are not accessible outside of the function. In our distance function the variables dx,dy,dz, and d were all local variables that are used inside the function but have no value outside of it. This is convenient because we don’t have to worry about overwriting a variable or using it twice. If someone sends you a function and you want to use it in your code, you don’t have to worry about what variable he/she chose to use inside his function; they won’t affect your code at all.\ndef distance(coords1,coords2):\n    dx = coords1[0] - coords2[0]\n    dy = coords1[1] - coords2[1]\n    dz = coords1[2] - coords2[2]\n    d = math.sqrt(dx**2 + dy**2 + dz**2)\n    return d\n\ndistOne = distance([1,2,3],[4,5,6])\n\nprint(dx)  # There is no value associated with this variable outside of the function.\nThe down side to all of this is that you don’t have access to function variables unless you pass them out of the function using the return statement.\nAny variables defined outside of a function is called a global variable, which means that Python remembers these assignments from anywere in your code including inside of functions. Using globabl variables with the intention to use them inside of functions is usually considered bad form and confusing and is discouraged. One notable exception to this rule are physical constants like \\(g = 9.8\\) m/s\\(^2\\) (acceleration due to gravity on Earth) or \\(k_B = 1.38 \\times 10^{-23}\\) (Boltzmann’s constant which is used heavily in thermodynamics) because these values will never change and may be used repeatedly. Generally speaking every variable that is used in a function ought to be either i) passed in as an argument or ii) defined inside of the function. Below is an example of an appropriate use of a global variable.\ndef myFunction(a,b):\n    c=a+g # <--- Notice the reference to 'g' here \n    d = 3.0 * c\n    f = 5.0 * d**4\n    return f\n\n#The variable below are global variables. \nr = 10\nt = 15\ng = 9.8         #<--- g defined to be a global variable\nresult = myFunction(r,t)\n\n\n7.3.3 Positional vs. Keyword Arguments\nThe function arguments we have been using so far are called positional arguments because they are required to be in a specific position inside the parenthesis. To see what I mean consider the example below.\n\ndef example(a,b):\n    return a**b\n\n\nresultOne = example(5,2)\nresultTwo = example(2,5)\n\nprint(resultOne, resultTwo)\n\n25 32\n\n\nIn the first call to example the local variable a gets assigned to be 5 and the local variable b gets assigned 2. In the second call the order of the arguments is switched and the subsequent assignments to a and b switch with it. This produces a different result from the function. Positional arguments are very common but the user must know what information goes where when calling the function.33 This is another reason why you want to choose meaningful variable names for your arguments.\nThe other type of argument is the keyword argument. These arguments are attached to a keyword inside of the parenthesis. The advantage of a keyword argument is that the user does not need to be concerned about the location of the argument as long as it has the proper label.\n\ndef example(a=1,b=2):\n    return a**b\n\n\nresultOne = example(a=5,b=2)\nresultTwo = example(b=2,a=5)\n\nprint(resultOne, resultTwo)\n\n25 25\n\n\nAnother advantage to using keyword arguments is that a default value can be coded into the function. This means that we can call the function with some arguments missing and default values will be used for them. In the example above, the default value of b is 2 and if the function is called without specifiying a value for that argument, the function will proceed as usual using the default value for b.\n\ndef example(a=1,b=2):\n    return a**b\n\n\nresult = example(a=5)\n\nprint(result)\n\n25"
  },
  {
    "objectID": "chapters/numpy.html",
    "href": "chapters/numpy.html",
    "title": "8  The numpy module",
    "section": "",
    "text": "Numpy (pronounced “num”-“pie”) is a popular Python library that is heavily used in the scientific/mathematical community. So much so that numpy is typically included as part of the standard bundle of libraries that comes with your Python installation. The functions inside numpy will allow you to solve problems with less effort and will produce faster-executing code."
  },
  {
    "objectID": "chapters/numpy.html#numpy-arrays",
    "href": "chapters/numpy.html#numpy-arrays",
    "title": "8  The numpy module",
    "section": "8.1 Numpy Arrays",
    "text": "8.1 Numpy Arrays\nYou are already familiar with Python lists but may not have noticed that they are not suitable for mathematical calculations. For example, attempting to multiply a list by a scalar or evaluate a mathematical function like \\(\\sin()\\) on a list will not produce a mathematical result or may produce an error. For example, consider the following code.\n\nmyList = [4,5,7]\n\nnewList = 2 * myList\nprint(newList)\n\n[4, 5, 7, 4, 5, 7]\n\n\nYou probably expected newList to be [8,10,14] but multiplying a list by a number doesn’t do that. Instead it repeats the list and concatenates it to itself. To multiply each element of a list by a number you must use a for loop.\n\nmyList = [4,5,7]\n\nnewList = []\nfor i in myList:\n    newList.append(i* 2)\n\nprint(newList)\n\n[8, 10, 14]\n\n\nbut this seems overly cumbersome for such a simple task. Numpy ndarrays (short for n-dimensional arrays) or just arrays make this task much simpler. Arrays are similar to lists or nested lists except that mathematical operations and numpy functions (but not math functions) automatically propogate to each element instead of requiring a for loop to iterate over it. Because of their power and convenience, arrays are the default object type for any operation performed with NumPy."
  },
  {
    "objectID": "chapters/numpy.html#array-creation",
    "href": "chapters/numpy.html#array-creation",
    "title": "8  The numpy module",
    "section": "8.2 Array Creation",
    "text": "8.2 Array Creation\n\n8.2.1 Type Conversion from List\nYou can create an array from a list using numpy’s array function. The list that is to be converted is the argument to the array function. Mathematical operations can then be performed on the array and that operation will propogate through to all of the elements.\n\nfrom numpy import array\n\nmyArray = array([4,5,7])\n\nnewArray = 2 * myArray \n\nprint(newArray)\n\n[ 8 10 14]\n\n\nNested lists, or lists that contain lists as their elements, can be converted to multi-dimensional arrays using the array function.\n\nfrom numpy import array\nmyArray = array([[1,2,3],[4,5,6]])\n\nprint(myArray)\n\n[[1 2 3]\n [4 5 6]]\n\n\n\n\n8.2.2 The arange and linspace Functions\nNumpy has some sequence-generating functions that generate arrays by specifying start, stop, and stepsize values similar to the way range generates a list. The two most common ones are arange and linspace. The arange function behaves very similar to the native Python range function with a few notable exceptions:\n\narange produces an array whereas range produces a list.\nThe step size for arange does not need to be an integer.\nrange produces an iterator and arange generates a sequence of values immediately.\n\nThe arguments to arange are similar to range\narange(start,stop,step)\nThe linspace function is related to the arange function except that instead of specifying the step size of the sequence, the sequence is generated based on the number of equally-spaced points in the given span of numbers. Additionally, arange excludes the stop value while linspace includes it. The difference between these two functions is subtle and the use of one over the other often comes down to user preference or convenience.\nlinspace(start,stop,number of points)\nBelow is an example that shows the usage of linspace and arange.\n\nfrom numpy import linspace,arange\n\nmyArray = linspace(0,10,20)\nmyArray2 = arange(0,10,0.5)\nprint(myArray)\nprint(myArray2)\n\n[ 0.          0.52631579  1.05263158  1.57894737  2.10526316  2.63157895\n  3.15789474  3.68421053  4.21052632  4.73684211  5.26315789  5.78947368\n  6.31578947  6.84210526  7.36842105  7.89473684  8.42105263  8.94736842\n  9.47368421 10.        ]\n[0.  0.5 1.  1.5 2.  2.5 3.  3.5 4.  4.5 5.  5.5 6.  6.5 7.  7.5 8.  8.5\n 9.  9.5]\n\n\nWhen using linspace you may still want to know what the sequence spacing is. You can request that linspace provide this information by adding the optional argument retstep = True to the argument list. With this addition, linspace not only returns the sequence to you, but also the stepsize.\n\nfrom numpy import linspace,arange\n\nmyArray,mydx = linspace(0,10,20,retstep= True)\nprint(mydx)\nprint(myArray)\n\n0.5263157894736842\n[ 0.          0.52631579  1.05263158  1.57894737  2.10526316  2.63157895\n  3.15789474  3.68421053  4.21052632  4.73684211  5.26315789  5.78947368\n  6.31578947  6.84210526  7.36842105  7.89473684  8.42105263  8.94736842\n  9.47368421 10.        ]\n\n\nTwo other useful functions for generating arrays are zeros and ones which generate arrays populated with exculsively ones or zeros. The functions require shape arguments as a tuple or list to specify the shape of the array.\nzeros((rows,columns))\nIf the array to be created is only one dimensional, the argument can be a single number instead of a tuple.\nzeros(n)\n\nfrom numpy import zeros,ones\n\nmyArray = zeros([3,4])\nmyArray2 = ones(5)\nprint(myArray)\nprint(myArray2)\n\n[[0. 0. 0. 0.]\n [0. 0. 0. 0.]\n [0. 0. 0. 0.]]\n[1. 1. 1. 1. 1.]\n\n\nArrays of any constant (not just one or zero) can then be easily generated by performing the needed math on the original array.\n\nfrom numpy import zeros,ones\n\nmyArray = zeros([3,4]) + 5\nmyArray2 = ones(5) * 12\nprint(myArray)\nprint(myArray2)\n\n[[5. 5. 5. 5.]\n [5. 5. 5. 5.]\n [5. 5. 5. 5.]]\n[12. 12. 12. 12. 12.]\n\n\n\n\n8.2.3 Arrays from Functions\nA third approach is to generate an array from a function using the fromfunction function which generates an array of values using the array indices as the inputs. Ths function requires two arguments: the name of the function being used and the shape of the array being generated.\nfromfunction(function, shape)\nLet’s make a 3 x 3 array where each element is the product of the row and column indices:\n\nfrom numpy import fromfunction\n\ndef prod(x,y):\n    return x * y\n\nmyArray = fromfunction(prod,(3,3))\nprint(myArray)\n\n[[0. 0. 0.]\n [0. 1. 2.]\n [0. 2. 4.]]\n\n\nThe table below gives a summary of useful functions for creating numpy arrays. The required arguments are also described.\n\nCommon functions for generating arrays\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\nlinspace(start,stop,n)\nReturns an array of n evenly-spaced points begining at start and ending at stop.\n\n\narange(start,stop,dx)\nReturns an array begining at start,ending at stop with a step size of dx.\n\n\nempty(dims)\nReturns an empty array with dimensions dim.\n\n\nzeros(dims)\nReturns an array of zeros with dimensions dim.\n\n\nones(dims)\nReturns an array of ones with dimensions dim.\n\n\nzeros_like(arr)\nReturns an array of zeros with dimensions that match the dimensions of arr.\n\n\nfromfunction(function,dims)\nReturns an array of numbers generated by evaluating function on the indices of an array with dimensions dims.\n\n\ncopy(arr)\nCreates a copy of array arr.\n\n\ngenfromtext(file)\nReads file and loads the text into an array (file must only contain numbers)."
  },
  {
    "objectID": "chapters/numpy.html#accessing-and-slicing-arrays",
    "href": "chapters/numpy.html#accessing-and-slicing-arrays",
    "title": "8  The numpy module",
    "section": "8.3 Accessing and Slicing Arrays",
    "text": "8.3 Accessing and Slicing Arrays\nAccessing and slicing arrays can be done in exactly the same way as is done with lists. However, there is some additional functionality for accessing and slicing arrays that do not apply to lists.\n\n8.3.1 One-dimensional Arrays\nElements from a one-dimensional array can be extracted using square brackets ([]) just like we have done with lists.\n\nfrom numpy import array\n\nmyArray = array([3,4,7,8])\nprint(myArray[2])\n\n7\n\n\n\n\n8.3.2 Multi-dimensional Arrays\nMulti-dimensional array can be indexed in a similar fashion to nested lists, but because we often encounter multi-dimensional arrays there is a shortcut that makes the syntax simpler and more convenient. Let’s consider a two-dimensional array as an example. To access the entire second row of the array, provide the row index in square brackets just as with one-dimesional arrays.\n\nfrom numpy import array\nmyArray = array([[1,2,3],[4,5,6], [7,8,9]])\n\nprint(myArray[1])\n\n[4 5 6]\n\n\nTo access the second element in the second row, we can add another set of square brackets with the appropriate index inside, just as we did with nested lists. However, for convenience the second set of square brackets can be omitted and the row and column indices can be placed next to each other and separted by a comma.\narray_name[row,column]\n\nfrom numpy import array\nmyArray = array([[1,2,3],[4,5,6], [7,8,9]])\n\nprint(myArray[1][1])  # This works, but is a bit hard on the eyes\nprint(myArray[1,1])  # This works also and is easier to look at.\n\n5\n5\n\n\n\n\n8.3.3 Accessing Multiple Elements\nMultiple elements of an array can be accessed using a list for the index instead of a single number.\n\nfrom numpy import array\n\nmyArray = array([1,2,3,4,5,6,7,8,9,10])\n\nprint(myArray[2])  # Extract element 2\nprint(myArray[ [3,6,9] ])  # Extract elements 3, 6, and 9.\n\n3\n[ 4  7 10]\n\n\nThis can even be done with multi-dimensional arrays. If the index is a single list, the corresponding rows will be extract. If the corresponding list of columns is added to the index list, individual elements will be extracted.\narray_name[[rows]]  # Access set of rows\narray_name[[rows], [columns]]  # Access set of elements\n\nfrom numpy import array\nmyArray = array([[1,2,3],[4,5,6], [7,8,9]])\n\nprint(myArray[[0,1]]) # Extract rows 0 and 1.\n\nprint(myArray[[1,2,0],[0,2,2]])   # Extract elements (1,0), (2,2), and (0,2)  \n\n[[1 2 3]\n [4 5 6]]\n[4 9 3]"
  },
  {
    "objectID": "chapters/numpy.html#slicing-arrays",
    "href": "chapters/numpy.html#slicing-arrays",
    "title": "8  The numpy module",
    "section": "8.4 Slicing Arrays",
    "text": "8.4 Slicing Arrays\n\n8.4.1 Multi-dimensional Arrays\nWe’ve already shown you how to slice a list using the : operator. The same can be done with arrays. However, for 2D (and higher) arrays the slicing is more powerful (intuitive). It can be helpful to visualize an array as a matrix, even if it is not being treated that way Mathematically. For example, let’s say that you define the following array:\nfrom numpy import array\nmyArray = array([[1,2,3],[4,5,6], [7,8,9]])\nwhich can be visualized as the following matrix:\n\\[\n\\begin{pmatrix}\n1&2&3\\\\\n4&5&6\\\\\n7&8&9\\\\\n\\end{pmatrix}\n\\]\nTo slice out the following \\(2\\) x \\(2\\) sub matrix:\n\\[\n\\begin{pmatrix}\n5&6\\\\\n8&9\\\\\n\\end{pmatrix}\n\\]\nwe could do\n\nfrom numpy import array\nmyArray = array([[1,2,3],[4,5,6], [7,8,9]])\n\nprint(myArray[1:3,1:3])\n\n[[5 6]\n [8 9]]\n\n\nTo include all of the elements in a given dimension, use the : alone with no numbers surrounding it.\n\nfrom numpy import array\nmyArray = array([[1,2,3],[4,5,6], [7,8,9]])\n\nprint(myArray[:,1:3])  # Extract all rows with columns 1 and 2\n\n[[2 3]\n [5 6]\n [8 9]]\n\n\n\n\n8.4.2 Boolean Slicing\nBoolean operations can be evaluated on arrays to produce corrsponding arrays of booleans. The boolean array can then be used to index the original array and extract elements that meet some criteria.\n\nfrom numpy import array\n\na = array([1,2,3,4,5,6])\n\nboolArray = a > 2\n\nprint(boolArray)\n\nprint(a[boolArray])\n\n[False False  True  True  True  True]\n[3 4 5 6]\n\n\nThis also works on multi-dimensional arrays although the result is always one-dimensional regardless of the shape of the original array.\n\nfrom numpy import array\nmyArray = array([[1,2,3],[4,5,6], [7,8,9]])\n\nprint(myArray[myArray>2]) # Extract elements that are greater than 2.\n\n[3 4 5 6 7 8 9]"
  },
  {
    "objectID": "chapters/numpy.html#vectorization-and-broadcasting",
    "href": "chapters/numpy.html#vectorization-and-broadcasting",
    "title": "8  The numpy module",
    "section": "8.5 Vectorization and Broadcasting",
    "text": "8.5 Vectorization and Broadcasting\nA major advantage of numpy arrays over lists is that operations vectorize across the arrays. This means that mathematical operations propogate through the array instead of requiring a for loop. This speeds up the calculation and makes code easier to write and read. Simple mathematical operations like adding, subtracting, etc can be performed on arrays as you would expect and the operation propogates through to all elements.\n\nfrom numpy import array\n\na = array([1,2,3])\nb = array([4,5,6])\n\nc = a + b\nd = a**2\ne = 2 * b\nf = 2/b\ng = a * b\n\nprint(c,d,e,f,g)\n\n[5 7 9] [1 4 9] [ 8 10 12] [0.5        0.4        0.33333333] [ 4 10 18]\n\n\nAll of the common mathematical operations that you learned for numbers now apply to arrays. Cool!\n\n8.5.1 Numpy Functions\nThe numpy library has a massive collection of vectorized mathematical functions and these functions should be used instead of similar functions from other libraries that are not vectorized (like math).\n\nfrom numpy import array\nfrom numpy import sqrt as nsqrt\nfrom math import sqrt as mathsqrt\n\nsquares = array([1,4,9,16,25])\n\nprint(nsqrt(squares))\n#print(mathsqrt(squares))  #This will fail because it wasn't a numpy function.\n\n[1. 2. 3. 4. 5.]\n\n\n\n\n8.5.2 Arrays of same Dimensions\nIf a mathematical operation is performed between two arrays of the same dimensions, the mathematical operation is performed between corresponding elements in the two arrays. For example, if two \\(2\\) x \\(2\\) arrays are added together, element (0,0) of the first array gets added to the corresponding element in the second and so forth for all elements:\n\\[\n\\begin{pmatrix}\n1&2\\\\\n3&4\\\\\n\\end{pmatrix}+\n\\begin{pmatrix}\n5&6\\\\\n7&8\\\\\n\\end{pmatrix}=\n\\begin{pmatrix}\n6&8\\\\\n10&12\\\\\n\\end{pmatrix}\n\\]\n\nfrom numpy import array\n\na = array([[1,2],[3,4]])\nb = array([[5,6],[7,8]])\n\nc = a + b  # Add the elements of the arrays together.\nd = a * b  # Multiply the elements of the arrays together.\n\nprint(c)\nprint(d)\n\n[[ 6  8]\n [10 12]]\n[[ 5 12]\n [21 32]]\n\n\n\n\n8.5.3 Arrays of Different Dimensions\nWhen a mathematical operation between two arrays of different dimensions is attempted, Python has to figure out how to make them have the same shape before performing the operation. Broadcasting refers to the set of rules used for operations like this. To handled arrays with different dimensions, NumPy pads or clones the array with fewer dimensions to make it have the same dimensions as the larger array. For example, what would happen if you attempted this operation:\n\\[\n\\begin{pmatrix}\n1&2\\\\\n3&4\\\\\n\\end{pmatrix}+\n\\begin{pmatrix}\n2&2\\\\\n\\end{pmatrix}\n\\]\nOne array is \\(2\\) x \\(2\\) and the other is \\(1\\) x \\(2\\). Before the addition can take place, NumPy clones the smaller array and repeats it until it has the same size as the bigger array.\n\\[\n\\begin{pmatrix}\n1&2\\\\\n3&4\\\\\n\\end{pmatrix}+\n\\begin{pmatrix}\n2&2\\\\\n2&2\\\\\n\\end{pmatrix}\n\\]\n\nfrom numpy import array\n\na = array([[1,2],[3,4]])\nb = array([2,2])\nc = a + b\n\nprint(c)\n\n[[3 4]\n [5 6]]\n\n\nThere are some cases where NumPy simply cannot figure out how to broadcast one of the arrays appropriately and an error results. When broadcasting, NumPy must verify that all dimensions are compatible with each other. Two dimensions are compatible when i) they are equal or ii) one of the dimensions is 1. For example, if we tried to perform the following mathematical operation, broadcasting would fail because the first dimension of the first array is 2 and the first dimension of the second array is 3.\n\\[\n\\begin{pmatrix}\n1&2&3\\\\\n3&4&5\\\\\n\\end{pmatrix}+\n\\begin{pmatrix}\n1&1&1\\\\\n2&2&2\\\\\n3&3&3\\\\\n\\end{pmatrix}\n\\]\nfrom numpy import array\n\na = array([[1,2,3],[4,5,6]])\nb = array([[1,1,1],[2,2,2],[3,3,3]])\nc = a + b\nbut if we attempted\n\\[\n\\begin{pmatrix}\n1&2&3\\\\\n\\end{pmatrix}+\n\\begin{pmatrix}\n1&1&1\\\\\n2&2&2\\\\\n3&3&3\\\\\n\\end{pmatrix}\n\\]\nthe operation would succeed because the first dimension of the first array is 1 and the second dimension of both arrays are 3.\n\n\n8.5.4 Vectorizing user-defined functions\nStandard Python functions are often designed to perform a single calculation rather than iterate over a list to perform many calculations. For example, here is a function to calculate the average acceleration of an object given its final velocity and time of travel.\n\ndef accel(velocity, time):\n    return velocity / time\n\n\nprint(accel(52.6,5.6))\n\n9.392857142857144\n\n\nNow what if I have a list of many times that I’d like to feed into this function and get an acceleration value for each one.\ndef accel(velocity, time):\n    return velocity / time\n\n\ntimes = [4.6,7.9,3.2,8.5,9.2,4.7]\nprint(accel(52.6,times))  # Produces an error because you can't divide by a list\nAn error results here because Python does not know how to divide by a list. We can NumPy-ify this function using a function called vectorize. The resulting function will behave just like the other functions from the NumPy library, vectorizing across the list of times.\n\nfrom numpy import vectorize\ndef accel(velocity, time):\n    return velocity / time\n\n\ntimes = [4.6,7.9,3.2,8.5,9.2,4.7]\nvaccel = vectorize(accel)  # Vectorize the function!\nprint(vaccel(52.6,times))  # Succeeds because NumPy knows how to vectorize.\n\n[11.43478261  6.65822785 16.4375      6.18823529  5.7173913  11.19148936]\n\n\nOf course, we also could have just converted our times list into an array and used the original function.\n\nfrom numpy import array\ndef accel(velocity, time):\n    return velocity / time\n\n\ntimes = array([4.6,7.9,3.2,8.5,9.2,4.7])\nprint(accel(52.6,times))  # Succeeds because times is an array not a list.\n\n[11.43478261  6.65822785 16.4375      6.18823529  5.7173913  11.19148936]"
  },
  {
    "objectID": "chapters/numpy.html#manipulating-and-modifying-arrays",
    "href": "chapters/numpy.html#manipulating-and-modifying-arrays",
    "title": "8  The numpy module",
    "section": "8.6 Manipulating and Modifying Arrays",
    "text": "8.6 Manipulating and Modifying Arrays\nA wealth of functions exist to perform routine manipulation tasks on arrays once they are created. Often these tasks will involve changing the number of rows or columns or merging two arrays into one. The size and shape of an array are the number of elements and dimensions, respectively. These can be determined using the shape and size methods.\n\nfrom numpy import array\n\na = array([[1,2,3],[4,5,6]])\nprint(a.size)\nprint(a.shape)\n\n6\n(2, 3)\n\n\n\n8.6.1 Reshaping Arrays\nThe dimensions of an array can be modified using the reshape function. This methods maintains the number of elements and the order of elements but repacks them into a different number of rows and columns. Because the number of elements is maintained, the size of the new array has to be the same as the original. Let’s see an example.\n\nfrom numpy import array, reshape\n\na = array([[1,2,3],[4,5,6]])\n\nb = reshape(a,[3,2])\n\nprint(a)\nprint(b)\n\n[[1 2 3]\n [4 5 6]]\n[[1 2]\n [3 4]\n [5 6]]\n\n\nThe original array (a) was a \\(2\\) x \\(3\\) and had \\(6\\) elements and the reshaped array also has \\(6\\) elements but is a \\(3\\) x \\(2\\). You can start with a one-dimensional array and reshape it to a higher dimensional array.\n\nfrom numpy import linspace, reshape\n\na = linspace(0,10,12)\n\nb = reshape(a,[3,4])\n\nprint(a)\nprint(b)\n\n[ 0.          0.90909091  1.81818182  2.72727273  3.63636364  4.54545455\n  5.45454545  6.36363636  7.27272727  8.18181818  9.09090909 10.        ]\n[[ 0.          0.90909091  1.81818182  2.72727273]\n [ 3.63636364  4.54545455  5.45454545  6.36363636]\n [ 7.27272727  8.18181818  9.09090909 10.        ]]\n\n\n\n\n8.6.2 Flattening Arrays\nFlattening an array takes a higher-dimensional array and squishes it into a one-dimensional array. You can “flatten” an array with the flatten method, but note that flatten doesn’t actually modify the original array.\n\nfrom numpy import array\n\na = array([[1,2,3],[4,5,6]])\na.flatten()\n\nprint(a)  # 'a' remains unchanged\n\na = a.flatten() # If you want to change the definition of a, redifine it.\nprint(a)\n\n[[1 2 3]\n [4 5 6]]\n[1 2 3 4 5 6]\n\n\n\n\n8.6.3 Transposing Arrays\nTransposing an array rotates it across the diagonal and can be accomplished with the transpose function. There is also a shortcut method for this of array.T to accomplish the same thing but just as with flatten it does not modify the original array. (neither does transpose)\n\nfrom numpy import array,transpose\n\na = array([[1,2,3],[4,5,6]])\ntranspose(a)\n\nprint(a)  # 'a' remains unchanged\n\na = a.T # If you want to change the definition of a, redefine it.\nprint(a)\n\n[[1 2 3]\n [4 5 6]]\n[[1 4]\n [2 5]\n [3 6]]\n\n\n\n\n8.6.4 Merging Arrays\nSeveral function exist for combining multiple arrays into a single array. We’ll give examples for a couple and mention the others in reference tables. The most commonly used functions for this task are vstack (vertical stacking) and hstack (horizontal stacking). vstack will stack the original arrays vertically to create the new array and hstack will stack them horizontally. Here are some examples.\n\nfrom numpy import linspace, hstack, vstack\n\na = linspace(0,10,10)\nb = linspace(0,5,10)\n\nc = vstack((a,b))\nprint(c)  # 'a' remains unchanged\n\nd = hstack((a,b))\nprint(a.T)\nprint(d)\n\n[[ 0.          1.11111111  2.22222222  3.33333333  4.44444444  5.55555556\n   6.66666667  7.77777778  8.88888889 10.        ]\n [ 0.          0.55555556  1.11111111  1.66666667  2.22222222  2.77777778\n   3.33333333  3.88888889  4.44444444  5.        ]]\n[ 0.          1.11111111  2.22222222  3.33333333  4.44444444  5.55555556\n  6.66666667  7.77777778  8.88888889 10.        ]\n[ 0.          1.11111111  2.22222222  3.33333333  4.44444444  5.55555556\n  6.66666667  7.77777778  8.88888889 10.          0.          0.55555556\n  1.11111111  1.66666667  2.22222222  2.77777778  3.33333333  3.88888889\n  4.44444444  5.        ]"
  },
  {
    "objectID": "chapters/numpy.html#commonly-used-array-methods-and-functions",
    "href": "chapters/numpy.html#commonly-used-array-methods-and-functions",
    "title": "8  The numpy module",
    "section": "8.7 Commonly-used Array Methods and Functions",
    "text": "8.7 Commonly-used Array Methods and Functions\nNumPy contains an extensive listing of array methods and functions and it would be impractical to list them all here. However, below you will find some tables of some of the commonly used ones that can serve as a reference.\n\nArray Attribute Methods and Functions\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\nshape(array) or array.shape\nReturns the dimensions of the array.\n\n\nndim(array) or array.ndim\nReturns the number of dimensions (i.e. a 2D array is \\(2\\)).\n\n\nsize(array) or array.size\nReturns the number of elements in an array.\n\n\n\n\nArray Modification Methods and Functions\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\narray.flatten()\nReturns a flattened view of array.\n\n\nreshape(array,dims) or array.reshape(dims)\nReturns a view of array reshaped into an array with dimensions given by dims.\n\n\narray.resize(dims)\nModifies array to be a resized array with dimensions dims.\n\n\ntranspose(array) or array.T\nReturns a view of the transpose of array.\n\n\nsort(array)\nReturns a view of a sorted version of array.\n\n\narray.sort()\nModifies array to be sorted.\n\n\nargsort(array)\nReturns index values that will sort array.\n\n\narray.fill(x)\nModifies array so that all elements are equal to x.\n\n\nvstack(a,b)\nVertically stack arrays a and b to form the new array.\n\n\nhstack(a,b)\nHorizontally stack arrays a and b to form the new array.\n\n\nvsplit(array,n)\nSplits array veritcally into n equal parts.\n\n\nhsplit(array,n)\nSplits array horizontally into n equal parts.\n\n\nappend(array,x)\nReturns a view of array with x added to the end of the array.\n\n\ninsert(array,n,x)\nReturns a view of array with x inserted at location n.\n\n\ndelete(array,n)\nReturns a view of array with element at location n removed.\n\n\nunique(array)\nReturns a view of the unique elements of array.\n\n\n\n\nArray Measurement Methods and Functions\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\nmin(array) or array.min()\nReturns the minimum value in an array.\n\n\nmax(array) or array.max()\nReturns the maximum value in an array.\n\n\nargmin(array) or array.argmin()\nReturns the location of the minimum value in an array.\n\n\nargmax(array) or array.argmax()\nReturns the location of the maximum value in an array.\n\n\nfmin(array1,array2)\nReturns the minimum between two arrays of the same size. (Arrays are compared elementwise.)\n\n\nfmax(array1,array2)\nReturns the maximum between two arrays of the same size. (Arrays are compared elementwise.)\n\n\nmean(array) or array.mean()\nReturns the mean of array.\n\n\nmedian(array) or array.median()\nReturns the median of array.\n\n\nstd(array) or array.std()\nReturns the standard deviation of array.\n\n\ncumprod(array) or array.cumprod()\nReturns the cumulative product of array.\n\n\ncumsum(array) or array.cumsum()\nReturns the cumulative sum of array.\n\n\nsum(array) or array.sum()\nReturns the sum of all elements in array.\n\n\nprod(array) or array.prod()\nReturns the product of all elements in array.\n\n\nfloor(array)\nReturns the floor (i.e., rounds down) of all elements in array.\n\n\nceil(array)\nReturns the ceiling (i.e., rounds up) of all elements in array."
  },
  {
    "objectID": "chapters/io.html",
    "href": "chapters/io.html",
    "title": "9  File I/O (Input/Output)",
    "section": "",
    "text": "Up to now, we have been working with computer-generated or manually typed data sets. Often in a scientific setting your data will be stored in a file and you will need to read the contents of the file into Python so you can perform an analysis. Most data files are text files, but there is a large variety of these that differ mostly in the way the information is formatted. The file extension (i.e., the 3 or 4 letters after the period at the end of a file name) specifies the formatting of the file. For example, a .csv file (short for comma-seperated values) has commas to separate the information."
  },
  {
    "objectID": "chapters/io.html#reading-lines",
    "href": "chapters/io.html#reading-lines",
    "title": "9  File I/O (Input/Output)",
    "section": "9.1 Reading Lines",
    "text": "9.1 Reading Lines\nThe first way to read a file is using a for loop to iterate over the file line by line. Admittedly, this is not the most elegant or efficient way to read a file but we present it first because it always works. First, the file is opened using the open command. The file should be attached to a variable for later use. Next, the data is read one line at a time using the readlines() method. We should use a for loop for this. Finally, it is a good idea to close the file when you’re finished.\n\nfile = open(\"squares.csv\")\nfor line in file.readlines():\n    print(line)\n\nfile.close()\n\n1,1\n\n2,4\n\n3,9\n\n4,16\n\n5,25\n\n6,36\n\n7,49\n\n8,64\n\n9,81\n\n10,100\n\n\nYou can see how each line gets read separately and printed off. But this isn’t super useful yet because we’d probably like to have the numbers stored in lists for our forthcoming analysis. We can fix this by creating some empty lists and appending the appropriate values as they are read in.\n\nnumbers = []\nsquares = []\n\nfile = open(\"squares.csv\")\nfor line in file.readlines():\n    numbers.append( int(line.split(',')[0]) )\n    squares.append( int(line.split(',')[1]) )\n\nfile.close()\n\nprint(numbers)\nprint(squares)\n\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n\n\nNow the data from the file is saved in Python lists and our analysis can proceed.\nOne final note: if all you want to do is read your file in as a list of strings (one string for each line), that can be done without a for loop using the function readlines (rather than readline).\n\nfile = open(\"squares.csv\")\ndata = file.readlines()\nfile.close()\n\nprint(data)\n\n['1,1\\n', '2,4\\n', '3,9\\n', '4,16\\n', '5,25\\n', '6,36\\n', '7,49\\n', '8,64\\n', '9,81\\n', '10,100']"
  },
  {
    "objectID": "chapters/io.html#using-numpys-genfromtxt-function",
    "href": "chapters/io.html#using-numpys-genfromtxt-function",
    "title": "9  File I/O (Input/Output)",
    "section": "9.2 Using NumPy’s genfromtxt function",
    "text": "9.2 Using NumPy’s genfromtxt function\nIf the data file is highly structured (every line looks the same, separater character is consistent across the file, etc) then NumPy’s genfromtxt function can read the data very efficiently into an array. The genfromtxt function requires only one argument (the file name) with another optional argument (delimiter) that is typically included to specify the character used to separate the data. Below is an example for using this function to read in the .csv data we have been working with.\n\nfrom numpy import genfromtxt\n\ndata = genfromtxt('squares.csv',delimiter = \",\")\n\nprint(data)\n\n[[  1.   1.]\n [  2.   4.]\n [  3.   9.]\n [  4.  16.]\n [  5.  25.]\n [  6.  36.]\n [  7.  49.]\n [  8.  64.]\n [  9.  81.]\n [ 10. 100.]]\n\n\nNotice that the data was read into a NumPy array (2D in this case because there were two columns of data), which means that we can easily slice off the individual columns if needed.\n\nfrom numpy import genfromtxt\n\ndata = genfromtxt('squares.csv',delimiter = \",\")\n\nnumbers = data[:,0]\nsquares = data[:,1]\nprint(numbers)\nprint(squares)\n\n[ 1.  2.  3.  4.  5.  6.  7.  8.  9. 10.]\n[  1.   4.   9.  16.  25.  36.  49.  64.  81. 100.]"
  },
  {
    "objectID": "chapters/basicPlotting.html",
    "href": "chapters/basicPlotting.html",
    "title": "10  Basis Plotting",
    "section": "",
    "text": "Creating plots is an important task in science and engineering. The old addage “A picture is worth a thousand words!” is wrong…. it’s worth way more than that if you do it right. When making plots on a computer it is important to remember that computers don’t plot functions, rather they plot individual points"
  },
  {
    "objectID": "chapters/basicPlotting.html#plotting-functions-of-a-single-variable",
    "href": "chapters/basicPlotting.html#plotting-functions-of-a-single-variable",
    "title": "10  Basis Plotting",
    "section": "10.1 Plotting Functions of a Single Variable",
    "text": "10.1 Plotting Functions of a Single Variable\nSimple plots of x vs. y are done using a library called matplotlib. In order to make a plot, matplotlib needs lists of x and y points that are going to be plotted. It cannot generate these points on its own. To build an array x of x-values starting at x = 0, ending at x = 10, and having a step size of .01, you’ll need numpy’s arange function:\n\nfrom matplotlib import pyplot\nfrom numpy import arange,sin,pi,cos\n\nx = arange(0,2 * pi/5,.01)\ny = sin(5 * x)\ny2 = cos(5 * x)\n\npyplot.figure()\npyplot.plot(x,y)\npyplot.plot(x,y2)\npyplot.show()"
  }
]