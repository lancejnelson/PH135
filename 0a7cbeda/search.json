[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Scientific Computing",
    "section": "",
    "text": "Python is a computer programming language available on all major platforms (Mac, Windows, Linux). Python is a scripting language which means that the computer interprets and runs your code at the moment you run it. In contrast, in a compiled language like C the code must first be converted into binary before it can run (called “compiling” the code). There are pros and cons to both types of languages. The on-the-fly interpretation of Python makes it quick and easy to write code and provides fast results for simple calculations. When codes become longer and more complex, on-the-fly interpretation becomes less efficient and execution time will be much slower than it would be with a compiled language. The pros and cons flip for a comiled language; writing code in a compiled language can be cumbersome and slow, but the execution time is typically much faster. Out of necessity, most programmers become proficient in both types of languages. Python(or another interpreted language) is used to “toy around” with your problem and build familiarity. As the complexity of the code increases the user is then forced to transition to a compiled language to get the needed speed. This is the famous “two language” problem and there is a new programming language designed to eliminate this problem by combining the pros from both into one language. (The name of the language is Julia)\nPython is free, open source software and is maintained by the non-profit Python software foundation. This is great because it means that you will always have free access to the Python language regardless of what organization or univeristy you are affliated with. You’ll never have to worry about not being able to use your Python code without paying for it. Another benefit of open source languages is that all of the codes developed by other people are available for anyone to inspect and modify. This allows anyone to review another’s code to ensure that it does what they say it does, or to modify it to do something else. One last benefit that comes with an open source language is the community of Python users available to answer questions and provide instruction to the beginner. Answers to most questions about python are readily available on tutorial or forum websites.\n\n\n\nThe first step is to install the software (if you haven’t already). The most convenient way to install Python and also get many of the commonly-used libraries is to use an installer. I recommend Anaconda. When installing the software be sure to choose Python 3 since this is the current version. By default, Anaconda will install a suit of sotwares and libraries that are commonly used. If you want to install other Python libraries, open the Anaconda-Navigator (green circle icon) and select the Environment tab on the left. Select Not Installed from the pull-down to see all of the libraries that are available to be installed. To install a library, check the box next to it and click Apply. Anaconda will take care of the rest.\n\nTo Do:\n\nInstall Anaconda\nCheck to see if the library “numpy” is installed. If not, install it.\n\n\n\n\n\nA Jupyter notebook is an electronic document designed to support interactive data processing, analysis, and visualization in an easily shared format. A Jupyter notebook can contain live code, math equations, explanatory text, and the output of codes (numbers, plots, graphics, etc..). To launch a Jupyter notebook, first open Anaconda-Navigator (green circle icon) and click the Launch button under JupyterLab. Jupyter can also be launched from the command line by typing jupyter-lab. The jupyter notebook will launch in your default web browser, but it is not a website. From here you can select an already existing Jupyter notebook, denoted by the orange icons and the .ipynb extension, or create a new notebook by clicking New from the File menu.\n\nTo Do:\n\nOn iLearn, find the module entitled “Jupyter Notebooks” and download the file “Intro.ipynb”.\nLaunch JupyterLab as explained above.\nOpen “Intro.ipynb” that you downloaded in step 1 and continue reading this book in the jupyter notebook.\n\n\n\n\nThere are two types of “cells” in a Jupyter notebook: code cells and text cells (also called Markdown cell). Code cells contain “live” Python code that can be run inside of the notebook with any output appearing directly below it. Markdown cells are designed to contain explanatory information about what is happening inside of the code cells. They can contain text, math equations, and images. Markdown cells suport markdown, html, and Latex (for generating pretty math equations).\nBoth markdown and code cells can be executed by either selecting Run Selected Cells in the Run menu, by clicking the Play icon at the top of the notebook, or by using the Shift-Return shortcut when your curson is in the desired cell.\n\n\n\nNavigating a Jupyter notebook is fairly straightforward but there are a few handy shortcuts/hotkeys that will make navigation quicker and your workflow more efficient. When working in a Jupyter notebook, you are always operating in one of two modes: edit mode or navigate mode. In edit mode you can make modifications to the text or code in a cell and in navigate mode you can add/delete cells and modify the cell type. If you can see a blinking cursor in one of the cells you are in edit mode. Otherwise you are in navigate mode. To exit edit mode, simply press the esc key and you will enter navigate mode. To exit navigate mode, simply press the enter key and you will enter edit mode for the cell you were focused on. (You can also double click on a cell with your mouse to enter edit mode.) The shift + enter key sequence will “execute” a cell and produce the associated output. For text cells, executing just means to render the text in a nicely formatted fashion. “Executing” a code cell will actually execute the code block contained in the cell. You also enter navigate mode every time you execute a cell using the shift + enter key sequence. A summary of these shortcuts is given below:\n\nUp/down arrows - Navigate to different cells in the notebook.\nY - turns a text cell into a code cell.\nM - turns a code cell into a text cell.\nA - inserts a new cell above the current cell.\nB - inserts a new cell below the current cell.\nX - deletes the current cell.\nenter - enters edit mode.\nshift + enter - execute a cell.\nesc - enter navigate mode.\n\nYou should take some time now to practice these shortcut keys until you become good at navigating a jupyter notebook. Consider attempting the following actions using the shortcuts above:\n\nAdd a cell below this one.\nTurn the cell into a code cell (observe the distinct appearance of code cells).\nType the following code into the cell:\n\nprint(\"I did it!\")\n\nExecute the cell using shift + enter. Observe the output.\nDelete the cell.\nEnter edit mode for this text cell.\nAdd a sentence of your choice at the end of the cell.\n“Execute” the cell and observe the new output.\nRemove the sentence to restore the cell to it’s previous state.\n\n\n\n\n\n\n\nJupyter notebooks in this class will be a nice mix of text cells (explanation) and code cells (examples). You will soon learn that code cells produce no output unless you explicitly tell them to using a print statement (similar to the one you used above). When you encounter a code cell, you should feel free to make modifications and additions to the cell until you fully understand how the code works.\n\n\n\nComments are a way to describe what each section of code does and makes it easier for you and others to understand the code. It may seem clear what each section of code does as you write it, but after a week, month or longer, it is unlikely to be obvious. Paul Wilson of the University of Wisconson at Madison is quoted as saying, “Your closest collaborator is you six months ago, but you don’t reply to emails.” Comment your code now so that you are not confused later.\nThere are several ways to add comments to your code:\n\nUse # to start a comment. Everything on that line the follows will be ignored.\nFor longer comments that will span several lines, use triple double quotes to begin and end the comment (\"\"\")\n\nThe cell below illustrates these two ways to make comments:\n# Speed of light in a vacuum\nc = 3e8\n\nv = 300 # Speed of sound in air\n\n\"\"\"\nThe variables below are the initial conditions for a cannon\nlaunching a ball at a 30 degree angle with an initial speed of\n50 m/s.  The initial height of the cannon ball is 1000 m\n\"\"\"\nv = 50\ntheta = 30\nh_i = 1000\n\nTo Do:\n\nExecute the code block below and verify that no output is produced.\nAdd print statements that help you see the result of the calculation.\nAdd simple commments next to each line explaining the code.\n\n\na = 2 \nb = 3 \nc = a**b\n\nimport subprocess\nimport sys\n\ndef install(package):\n    subprocess.check_call([sys.executable, \"-m\", \"pip\", \"install\", package])\ninstall(\"numpy\")\n\nDefaulting to user installation because normal site-packages is not writeable\nRequirement already satisfied: numpy in /Users/lancenelson/Library/Python/3.8/lib/python/site-packages (1.21.4)\n\n\nWARNING: You are using pip version 21.3.1; however, version 22.1.2 is available.\nYou should consider upgrading via the '/Library/Developer/CommandLineTools/usr/bin/python3 -m pip install --upgrade pip' command."
  },
  {
    "objectID": "basicPythonI.html",
    "href": "basicPythonI.html",
    "title": "2  Basic Python",
    "section": "",
    "text": "When performing mathematical operations, it is often desirable to store the values in variables for later use instead of manually typing them back in each time you need to use them. This will reduce effort because small changes to variables can automatically propagate through your calculations.\nAttaching a value to a variable is called assignment and is performed using the equal sign (=), as demonstrated in the cell below:\na = 5.0\nb = 3\nc = a + b\n\n\nThere are some rules for allowed variable names in Python. They are as follows:\n\nVariable names must begin with a letter or an underscore (_)\nVariables names must only contain letters, numbers, and underscores.\nVariable names cannot contain spaces.\nVariables names cannot be a word reserved by Python for something else. These words are:\n\n\n\n\n\nPython\nreserved\nwords\n\n\n\n\n\nand\nas\nassert\nbreak\nclass\n\n\ncontinue\ndef\ndel\nelif\nelse\n\n\nexcept\nFalse\nfinally\nfor\nfrom\n\n\nglobal\nif\nimport\nin\nis\n\n\nlambda\nNone\nnonlocal\nnot\nor\n\n\npass\nraise\nreturn\nTrue\ntry\n\n\nwhy\nwith\nyield\n\n\n\n\n\nThe cell below contains some allowed variable names and some that are not allowed.\n\nTo Do:\n\nDetermine which variable names are allowed and which are not in the cell below.\nWhat does Python do if you try to define a variable using a name that is not allowed?\n\n\nmy1variable = 3\n1stvariables = 2\na big constant = 3\na_big_constant = 1e8\nIt is also a good practice to make variable names meaningful. For example, in the cell below we calculate \\(E = mc^2\\) using two choices for variable assignments. In one case, it is easy to determine what the calculation is and in the other it isn’t.\n# Good Variable Names\nmass_kg = 1.6\nlight_speed = 3.0e8\nE = mass_kg * light_speed**2\n\n\n# Poor Variable Names\na = 1.6\nb = 3.0e8\nc = a * b**2\n\n\n\nThere are two types of numbers in Python - floats and integers. Floats, short for “floating point numbers,” are values with decimals in them. They may be either whole or non-whole numbers such as 3.0 or 1.2, but there is always a decimal point. Integers are whole numbers with no decimal point such as 2 or 53.\nMathematical operations that only use integers and evaluate to a whole number will generate an integers (except for division). All other situations will generate a float. See the example cell below.\na = 24\nb = 6\nd = 0.3\ne = a + b # Produces an integer.\nf = a + d # Produces a float\ng = a * b # Produces a ???\nh = a / b # Produces a ???\nIntegers and floats can be interconverted to each other using the int() and float() functions.\n\nint(3.0)\nfloat(4)\n\n4.0\n\n\nThe distinction between floats and ints is often a minor detail. Occasionally, a function will require that an argument be a float or an int but usually you won’t have to worry about which one you use.\nBelow you will find some other common mathematical operations that can be performed on numerical variables.\na = 20\nb = 10\nc = a + b \nd = a/b  \nr = a//b\nr = a % b\ne = a * b\nf = c**4\n\nTo Do:\n\nUse print statements to investigate what each operation does.\n\nCan you force each operation to produce a float and an integer?\nAdd comments next to each line (Use # to start a comment) explaining that operation.\n\n\n\n\n\nAugmented assignment is a shortened way to make a simple modification to a variable. For example, if we want to increase the value of a variable by 10, one way to do it would be like this.\na = 5\na = a + 10\nThis is certainly not difficult, but it does involve typing the variable twice which becomes cumbersome as your variable name gets longer. Alternatively, we can accomplish the same thing with the += operator.\na = 5\na += 10\nAugmented assignment can be used with addition, subtraction, multiplication, and division as shown in the code cell below.\n\nTo Do:\n\nPredict what the final result of a will be in the code cell below.\nAdd an appropriately-place print statement to see if you were correct.\nIf you were wrong, pow-wow with your neighbor until you understand.\n\n\na = 7\na += 3\na -= 1\na *= 4\na /= 3\n\n\n\nAt the beginning of a program or calculation, it is often necessary to define a set of variables. Each variable may get it’s own line of code, but if there are a lot of variables, this can begin to clutter your code a little. An alternative is to assign multiple variables on a single line. In the code below, we assign the atomic mass of the first three elements.\nH, He, Li = 1.01, 4.00, 5.39\n\nTo Do:\n\nUse print statements to verify that each variable was assigned it’s own value.\nAdd assignments for the atomic masses of the next three elements on the periodic table.\n\n\n\n\n\nSometimes you find yourself working with large numbers in your calculation. Maybe your calculation involves the use of ten billion, which has 10 zeros in it. It can be difficult to look at all of those zeros with no commas to help break it up. In those cases, you can use an underscore (_) in place of the comma, as shown below.\nmyLargeNumber = 10000000000 # This is tough to look at.\nmyLargeNumber = 10_000_000_000  # This is easy to read\n\nmyLargeFloat = 5000000.6 # This is tough to read\nmyLargeFloat = 5_000_000.6 # This is easy to read\n\n\n\nIf your number is very large or very small ( \\(20-30\\) zeros), you would probably rather not have to type all of the zeros at all, even if you can break it up with the underscores. For example, the Boltzman constant, which comes up in thermodynamics, has a value equal to\n\\[ 1.38 \\times 10^{-23}\\]\nWe can avoid typing all those zeros by using scientific notation when defining the variable. (see example below) This is super handy for very large and very small number. (Numbers of both variety show up frequently in physics!)\nkB = 1.38e-23\n\n\n\nIn addition to basic mathematical functions, python contains several mathematical functions. As in mathematics, a function has a name (e.g. f) and the arguments are places inside of the parenthesis after the name. The argument is any value or piece of information fed into the function. In the case below, f requires a single argument x.\n\\[f(x)\\]\nIn the cell below, you will find several useful math equations.\n\nabs(-5.5)\nfloat(2)\nint(5.6)\nprint(1.26e-6)\nround(-5.51)\nstr(3.2)\n\n1.26e-06\n\n\n'3.2'\n\n\nIn addition to Python’s native collection of mathematical functions, there is also a math module with more mathematical functions. Think of a module as an add-on or tool pack for Python just like a library. The math module comes with every installation of python and can be imported (i.e. activated) using the import math command. After the module has been imported, any function in the module is called using math.function() where function is the name of the function. Here is a list of commonly-used function inside the math module:\n\nimport math\nmath.sqrt(4)\nmath.ceil(4.3)\nmath.cos(1.5)\nmath.sin(1.5)\nmath.degrees(6.28)\nmath.e\nmath.exp(5)\nmath.factorial(4)\nmath.log(200)\nmath.log10(1000)\nmath.radians(360)\nmath.tan(3.14)\nmath.pi\nmath.pow(2,8)\n\n256.0\n\n\n\nTo Do:\n\nUse print statements to figure out what each function in the code cell above does. Pay special attention to trigonometric function. Do these functions expect the argument to be in radians or degrees?\nAdd comments to remind yourself for later.\n\n\nThere are other ways to import functions from modules. If you only wan to use a single function inside the module, you can selectively import it using from, as shown below.\n\nfrom math import radians\nradians(4)\n\n0.06981317007977318"
  },
  {
    "objectID": "basicPythonI.html#exercises",
    "href": "basicPythonI.html#exercises",
    "title": "2  Basic Python",
    "section": "2.2 Exercises",
    "text": "2.2 Exercises\n\nCalculate the distance from the origin to the point \\((23,81)\\) usign the math.hypot() function and then using the following distance equation:\n\n\\[ d = \\sqrt{\\Delta x^2 + \\Delta y^2}\\]\n\nSolve the quadratic equation using the quadratic function below for \\(a = 1\\), \\(b = 2\\), and \\(c = 1\\).\n\n\\[ x = {- b \\pm \\sqrt{b^2 - 4 a c} \\over 2a}  \\]\n(Optics Application) 3. When light encounters an interface between two different object, the light bends as it proceeds into the second material. The index of refraction (n) determines how much bending happens. Bending is greater for materials with a bigger index of refraction."
  },
  {
    "objectID": "basicPythonII.html",
    "href": "basicPythonII.html",
    "title": "3  Basic Python Part II",
    "section": "",
    "text": "Another commonly-used type of data is a string of characters known simply as strings. Strings can contain a variety of characters including letters, numbers, and symbols.\n\n\nStrings are created by placing the sequence of characters in single (or double) quotes.\ntext = \"some text\"\nStrings can also be created by converting a float or an integer into a string using the str() function.\ntext = str(4.5)\nOne common error made when working with strings is to attempt to perform math with them. Python will not perform math with strings because it sees them as a series of characters and nothing more. In the cell below, we attempt to perform math with some strings.\na = \"4\"\nb = \"2\"\nc = 2\n\nd = a + b\ne = a * b\nf = b * c\n\nTo Do:\n\nUse print statements in the cell above to determine what happens when you add two strings together.\nUse print statements in the cell above to determine what happens when you multiply two strings.\nUse print statements in the cell above to determine what happens when you multiply a string and an integer.\n\n\nIf you want to know the length of a string, you can use the len() function\n\ntext = \"some text\"\nlen(text)\n\n9\n\n\nThe length of the string above is 9 because a space is a valid character.\n\n\n\nYou have been using print() statements quite a lot lately (hopefully) but you probably haven’t printed text and numbers together. To display both text and numbers in the same message, there are several options. The first is to just put multiple variables into the print() function, separating them with commas.\n\ng = 9.8\nunit = \"m/s^2\"\nprint(g,unit)\n\n9.8 m/s^2\n\n\nAnother option is to convert the number to a string and then “add” it to the other string. This creates a single string as an argument to the print() function.\n\ng = 9.8\nunit = \"m/s^2\"\nprint(str(g) + unit)\n\n9.8m/s^2\n\n\nNotice the lack of space between the number and the unit. “Adding” the two strings smashed them together exactly as they were, no spaces added. You can insert multiple numbers into a string using something called “f”-strings. (short for formatted strings). To construct an f-string, simply place an “f” in front of the string. Anytime you want to insert a number in your string, enclose it in curly braces.\n\nv = 5.0\nc = 3e8\nprint(f\"The speed of light is {c} and the speed of my car is {v}\")\n\nThe speed of light is 300000000.0 and the speed of my car is 5.0\n\n\nYou can specify how the number should be formatted by placing a : after the variable name followed by a formatting tag. Here are a few examples to explore:\n\nv1 = 5.0\nv2 = 8.3\nc = 2.998e8\nn = 2\n\nprint(f\"There are {n:d} cars traveling side by side.  One car is traveling at {v1:4.2f} m/s and the other is traveling at {v2:4.2f} m/s.  Those speeds are much smaller than the speed of light, which is {c:.2e} m/s\") \n\nThere are 2 cars traveling side by side.  One car is traveling at 5.00 m/s and the other is traveling at 8.30 m/s.  Those speeds are much smaller than the speed of light, which is 3.00e+08 m/s\n\n\nAs you can see, the formatting tag tells the print statement how the number should be printed. For float variables, the formatting tag will have two numbers followed by an “f” (for float). The first number indicates how many total spaces should be allocated to print the number and the second number specifies the number of decimal places that should be displayed. For integer variables, use the formatting tag “g”. For bigger numbers, it is often useful to print the number in scientific notation. To do this, use the “.2e” formatting tag. The number after the decimal indicates how many numbers after the decimal should be displayed.\n\nTo Do:\n\nModify the print statement above so that the float variables are given 8 total spaces with only 1 number after the decimal being displayed.\nModify the print statement above so that the speed of light is displayed with 3 numbers after the decimal place.\n\n\n\n\n\nAccessing a piece (or slice) of a string is a common task in scientific computing. Often you will import data into Python from a text file and need to extract a portion of the file for later use in calculations. Indexing allows the user to extract a single element, or character, from a string. The key detail about indexing in Python is that indices start from zero. That means that the first character is index zero, the second character is index 1, and so on. For example, maybe a string contains the following amino acid sequence ‘MSLFKIRMPE’. For this example, the indices are as follows:\n\n\n\nCharacters\nM\nS\nL\nF\nK\nI\nR\nM\nP\nE\n\n\n\n\nIndex\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\nTo access a single character from a string, place the desired index in square brackets after the name of the string.\n\nseq = \"MSLFKIRMPI\"\nseq[0]\n\n'M'\n\n\nTo access the last character in a string you could do\n\nseq = \"MSLFKIRMPI\"\nseq[len(seq) - 1]\n\n'I'\n\n\nBut this seems overly cumbersome. An easier approach is to index backwards. The string can be reverse indexed from the last character to the first using negative indices, starting with -1 as the last charcter.\n\nseq = \"MSLFKIRMPE\"\nseq[-1]\n\n'E'\n\n\n\nTo Do:\n\nAccess the 5th character in the peptide sequence above.\nAccess the character that is 3rd from the end in the peptide sequence above.\n\n\nIndexing only provides a single character, but it is common to want a series of characters from a string. Slicing allows us to grab a section of a string. Slicing is performed by specifying start and stop indices separated by a colon in the square brackets. One important detail worth mentioning: the character at the starting index is included in the slice while the character located at the final index is not included in the slice.\n\nseq = \"MSLFKIRMPE\"\nseq[0:5]\n\n'MSLFK'\n\n\nLooking at the string, you notice that the character at location 5 (I) has been excluded from the slice. You can leave off the first number when slicing and the slice will start at the beginning of the string.\n\nseq = \"MSLFKIRMPE\"\nseq[:5]\n\n'MSLFK'\n\n\nYou can also use negative indices when slicing. This is especially helpful when you want to grab the last few characters in a string.\nfile = \"data.txt\"\next = file[-3:]\nFinally, we can adjust the step size in the slice. That is, we can ask for every other character in the string by setting a step size of 2. The structure of the slice is [start,stop,step].\n\nseq = \"MSLFKIRMPE\"\nseq[0:8:2]\n\n'MLKR'\n\n\nYou can omit the start and stop indices and Python will assume that you are slicing the entire string.\n\nseq = \"MSLFKIRMPE\"\nseq[::2]\n\n'MLKRP'\n\n\n\n\n\nA method is a function that works only with a specif type of object. String methods only work on strings, and they don’t work on other types of objects, like floats or ints. If it helps you, you can just think of a method as a function.\nOne example of a string method is the capitalize() function which returns a string with the first letter capitalized. To use a method (referred to as calling the method), the method name is appended to the variable you want it to operate on. For example, below is an Albert Einstein quote that needs capitalized.\n\nquote = \"i want to know God's thoughts. The rest are details.\"\nquote.capitalize()\nprint(quote)\n\ni want to know God's thoughts. The rest are details.\n\n\nNotice that the original variable (quote) remains unchanged. This particular method does not change the value of the original string but rather returns a capitalized version of it. If we want to save the capitalized version, we can assign it to a new variable, or overwrite the original.\n\nquote = \"i want to know God's thoughts. The rest are details\"\nquote = quote.capitalize()\nprint(quote)\n\nI want to know god's thoughts. the rest are details\n\n\nIn the cell below you will find a list of commonly-used string methods.\n\na = \"spdfgssfpggg\"\na.capitalize()\na.center(10)\na.count(\"s\")\na.find(\"d\")\na.isalnum()\na.isalpha()\na.isdigit()\na.lstrip(\"s\")\na.rstrip(\"g\")\na.split(\"s\")\na.startswith(\"s\")\na.endswith(\"p\")\n\nFalse\n\n\n\nTo Do:\n\nUse well-placed print statements to determine what each string method does.\nAdd comments next to each method for future reference."
  },
  {
    "objectID": "basicPythonII.html#exercises",
    "href": "basicPythonII.html#exercises",
    "title": "3  Basic Python Part II",
    "section": "3.2 Exercises",
    "text": "3.2 Exercises\n\nRemoving file ext\n\n\\[ d = \\sqrt{\\Delta x^2 + \\Delta y^2}\\]\n\nSolve the quadratic equation using the quadratic function below for \\(a = 1\\), \\(b = 2\\), and \\(c = 1\\).\n\n\\[ x = {- b \\pm \\sqrt{b^2 - 4 a c} \\over 2a}  \\]"
  },
  {
    "objectID": "basicPythonIII.html",
    "href": "basicPythonIII.html",
    "title": "4  Basic Python Part III",
    "section": "",
    "text": "We have learned about three types of variables in Python: ints, floats, and strings. Another variable type is a boolean, which can only be one of two values: true or false. You can assign a boolean variable in the same way that you assign numbers or string, using =\nmyBool = True\nTrue must be capitalized so don’t try true or it won’t be a boolean\nmyBool = true\n\n\nOften you will want to check to see if some condition is true. For example, maybe you want to know if the radius of a certain satellite’s orbit is bigger or smaller than Mercury’s orbit. To perform this check, there are several boolean operators that will return True or False. Take note of the boolean operators shown in the cell below along with the comments added to explain what they do.\n\nr1 = 3.5e8\nr2 = 2.7e6\n\nr1 > r2 # Is r1 greater than r2\nr1 < r2 # Is r1 less than r2\nr1 >= r2 # Is r1 greater than or equal to r2\nr1 <= r2 # Is r1 less than or equal to r2\nr1 != r2 # Is r1 not equal to r2\nr1 == r2 # Is r1 equal to r2\n\nFalse\n\n\nThe == operator is dangerous to use because two numbers are rarely identical due to the way computers store numbers. We recommend that you not use this operator to compare two numbers. The cell below illustrates what I mean.\n\na = (25.4/10.0) * (1.0/2.54)\nb = ((25.4/10.0) * 1.0)/2.54\n\nprint(a,b)\n\na == b\n\n0.9999999999999999 1.0\n\n\nFalse\n\n\nMathematically, these two numbers are identical, but in the computer these numbers are represented differently and therefore they are not recognized as identical. A better way to compare two numbers is to see if the absolute value of the difference of the two numbers is very small.\n\na = (25.4/10.0) * (1.0/2.54)\nb = ((25.4/10.0) * 1.0)/2.54\n\nabs(a - b) < 1e-8\n\nTrue\n\n\n\n\n\nComparisons like those shown above can be chained together to make compound comparisons using the and, or, and not operators.\n\n\n\nOperator\nDescription\n\n\n\n\nand\nTests for both being True\n\n\nor\nTests for either being True\n\n\nnot\nTests for False\n\n\n\nThe and operator requires both inputs to be True in order to return True while the or operator requires only one input to be True in order to evaluate at True. The not operator is different in that it only takes a single input value and returns True if and only if the input is False. It is a test for False.\nTruth tables are a good way to visualize the output from compound comparisons.\n\n\n\np\nq\np and q\np or q\n\n\n\n\nTrue\nTrue\nTrue\nTrue\n\n\nTrue\nFalse\nFalse\nTrue\n\n\nFalse\nTrue\nFalse\nTrue\n\n\nFalse\nFalse\nFalse\nFalse\n\n\n\nAs a simple example, suppose you know the density (\\(\\rho\\)) and speed of light (c) for two materials and you’d like to know if both values are bigger for material 1 or material 2.\n\nTo Do:\n\nPredict the output for each compound comparison given below. Add your guess as a comment.\nNow add appropriately-placed print statements to check your guesses.\nModify your guess as needed and discuss any questions with a neighbor.\n\n\n\nc1 = 2.5e8\nc2 = 2.48e8\nρ1 = 450\nρ2 = 580\n\nc1 > c2 and ρ1 > ρ2\nc1 < c2 and ρ1 < ρ2\nc1 > c2 and ρ1 < ρ2\nc1 < c2 and ρ1 > ρ2\n\nc1 > c2 and not ρ1 > ρ2\nc1 < c2 and not ρ1 < ρ2\n\nc1 > c2 or ρ1 > ρ2\nc1 < c2 or ρ1 < ρ2\n\nTrue\n\n\n### Tests for Inclusion\nYou can check for inclusion using the Python in operator. This provides an easy way to see if a character (or word) is present in a long string. Let’s say you have a long string that contains the names of Jupyter’s moons (there are 79 of them!!) and you want to see if a certain moon is included in the list. The in statement let’s us quickly test to see if it is in the list. (see example below)\n\njupytermoons = \"Metis,Adrastea,Amalthea,Thebe,Io,Europa,Ganymede,Callisto,Themisto,Leda,Himalia,Lysithea,Elara,Dia,Carpo,Euporie,Thelxinoe,Euanthe,Helike,Orthosie,Iocaste,Praxidike,Harpalyke,Mneme,Hermippe,Thyone,Ananke,Herse,Aitne,Kale,Taygete,Chaldene,Erinome,Aoede,Kallichore,Kalyke,Carme,Callirrhoe,Eurydome,Pasithee,Kore,Cyllene,Eukelade,Pasiphae,Hegemone,Arche,Isonoe,Sinope,Sponde,Autonoe,Megaclite\"\n\n\"Cyllene\" in jupytermoons\n\nTrue"
  },
  {
    "objectID": "basicPythonIII.html#conditions",
    "href": "basicPythonIII.html#conditions",
    "title": "4  Basic Python Part III",
    "section": "4.2 Conditions",
    "text": "4.2 Conditions\nConditions allow the user to specify if and when certain lines or blocks of code are executed. Specifically, when a condition is true, the block of indented code directly below it will run.\n\n4.2.1 ‘if’ statement\nThe if statement is used to control when a block of code runs. It’s usage is shown below ending in a colon and the block of code below indented with four spaces. Using the Tab key will also produce four spaces.\n\njupytermoons = \"Metis,Adrastea,Amalthea,Thebe,Io,Europa,Ganymede,Callisto,Themisto,Leda,Himalia,Lysithea,Elara,Dia,Carpo,Euporie,Thelxinoe,Euanthe,Helike,Orthosie,Iocaste,Praxidike,Harpalyke,Mneme,Hermippe,Thyone,Ananke,Herse,Aitne,Kale,Taygete,Chaldene,Erinome,Aoede,Kallichore,Kalyke,Carme,Callirrhoe,Eurydome,Pasithee,Kore,Cyllene,Eukelade,Pasiphae,Hegemone,Arche,Isonoe,Sinope,Sponde,Autonoe,Megaclite\"\n\nif \"Cyllene\" in jupytermoons:\n    found = True\n    print(\"Found Cyllene in the list\")\n    \nif \"Matis\" in jupytermoons:\n    found = True\n    print(\"Found Matis in the list\")\n\nFound Cyllene in the list\n\n\nIf the boolean statement after if is true, the indented code below it will run. If the statement is false, Python just skips the indented lines below.\n\n\n4.2.2 else Statment\nSometimes there will be an alternate block of code that you want to run if the if statement evaluates to False. The else statement is used to specify this block of code, as shown below.\n\njupytermoons = \"Metis,Adrastea,Amalthea,Thebe,Io,Europa,Ganymede,Callisto,Themisto,Leda,Himalia,Lysithea,Elara,Dia,Carpo,Euporie,Thelxinoe,Euanthe,Helike,Orthosie,Iocaste,Praxidike,Harpalyke,Mneme,Hermippe,Thyone,Ananke,Herse,Aitne,Kale,Taygete,Chaldene,Erinome,Aoede,Kallichore,Kalyke,Carme,Callirrhoe,Eurydome,Pasithee,Kore,Cyllene,Eukelade,Pasiphae,Hegemone,Arche,Isonoe,Sinope,Sponde,Autonoe,Megaclite\"\n\nif \"Cyllene\" in jupytermoons:\n    found = True\n    print(\"Found Cyllene in the string\")\nelse:\n    found = False\n    print(\"Did not find Cyllene in the string\")\n\n    \nif \"Matis\" in jupytermoons:\n    found = True\n    print(\"Found Matis in the string\")\nelse:\n    found = False\n    print(\"Did not find Matis in the string\")\n\nFound Cyllene in the string\nDid not find Matis in the string\n\n\nNotice that the else statement must be followed by a colon and the block of code to be executed is indented, just as in the if block.\nThere is an additional statement called the elif statement, short for “else if”, which is used to add extra conditions below the initial if statement. The block of code below the elif statement only runs if the if statement is false and the elif statement is true. An example is given below.\n\njupytermoons = \"Metis,Adrastea,Amalthea,Thebe,Io,Europa,Ganymede,Callisto,Themisto,Leda,Himalia,Lysithea,Elara,Dia,Carpo,Euporie,Thelxinoe,Euanthe,Helike,Orthosie,Iocaste,Praxidike,Harpalyke,Mneme,Hermippe,Thyone,Ananke,Herse,Aitne,Kale,Taygete,Chaldene,Erinome,Aoede,Kallichore,Kalyke,Carme,Callirrhoe,Eurydome,Pasithee,Kore,Cyllene,Eukelade,Pasiphae,Hegemone,Arche,Isonoe,Sinope,Sponde,Autonoe,Megaclite\"\n\nif \"Matis\" in jupytermoons:\n    foundMatis = True\n    print(\"Found Matis in the string\")\nelif \"Cyllene\" in jupytermoons:\n    foundCyllene = True\n    print(\"Found Cyllene in the string.\")\nelse:\n    foundCyl = False\n    foundMatis = False\n    print(\"Did not find Cyllene or Matis in the string\")\n\nFound Cyllene in the string.\n\n\nIt is worth noting that else statements are not required. If you leave the else statement off and the if statement is false, no code block will execute."
  },
  {
    "objectID": "basicPythonIII.html#exercises",
    "href": "basicPythonIII.html#exercises",
    "title": "4  Basic Python Part III",
    "section": "4.3 Exercises",
    "text": "4.3 Exercises\n\nRemoving file ext\n\n\\[ d = \\sqrt{\\Delta x^2 + \\Delta y^2}\\]\n\nSolve the quadratic equation using the quadratic function below for \\(a = 1\\), \\(b = 2\\), and \\(c = 1\\).\n\n\\[ x = {- b \\pm \\sqrt{b^2 - 4 a c} \\over 2a}  \\]"
  }
]