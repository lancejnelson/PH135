---
jupyter: python3
reference-location: margin
citation-location: margin
---

# The `numpy` module
Numpy (pronounced "num"-"pie") is a popular Python library that is heavily used in the scientific/mathematical community.  So much so that numpy is typically included as part of the standard bundle of libraries that comes with your Python installation.  The functions inside numpy will allow you to solve problems with less effort and will produce faster-executing code.  


## Numpy Arrays
You are already familiar with Python lists but may not have noticed that they are not suitable for mathematical calculations. For example, attempting to multiply a list by a scalar or evaluate a mathematical function like $\sin()$ on a list will *not* produce a mathematical result or may produce an error. For example, consider the following code.


```{python}
myList = [4,5,7]

newList = 2 * myList
print(newList)
```


You probably expected `newList` to be `[8,10,14]` but multiplying a list by a number doesn't do that.  Instead it repeats the list and concatenates it to itself.  To multiply each element of a list by a number you must use a `for` loop.

```{python}
myList = [4,5,7]

newList = []
for i in myList:
    newList.append(i* 2)

print(newList)

```

but this seems overly cumbersome for such a simple task.  Numpy *ndarrays* (short for n-dimensional arrays) or just *arrays* make this task much simpler. Arrays are similar to lists or nested lists except that mathematical operations and `numpy` functions (but not `math` functions) automatically propogate to each element instead of requiring a `for` loop to iterate over it.  Because of their power and convenience, arrays are the default object type for any operation performed with NumPy.  


## Array Creation

### Type Conversion from List

You can create an array from a list using numpy's `array` function. The list that is to be converted is the argument to the `array` function.  Mathematical operations can then be performed on the array and that operation will propogate through to all of the elements.


```{python}
from numpy import array

myArray = array([4,5,7])

newArray = 2 * myArray 

print(newArray)


```


Nested lists, or lists that contain lists as their elements, can be converted to multi-dimensional arrays using the `array` function.

```{python}
from numpy import array
myArray = array([[1,2,3],[4,5,6]])

print(myArray)

```



### The `arange` and `linspace` Functions

  Numpy has some sequence-generating functions that generate arrays by specifying start, stop, and stepsize values similar to the way `range` generates a list.  The two most common ones are `arange` and `linspace`.  The `arange` function behaves very similar to the native Python `range` function with a few notable exceptions:


1. `arange` produces an array whereas `range` produces a list.
2. The step size for `arange` does not need to be an integer.
3. `range` produces an iterator and `arange` generates a sequence of values immediately.


The arguments to `arange` are similar to `range`

```
arange(start,stop,step)
```

The `linspace` function is related to the `arange` function except that instead of specifying the step size of the sequence, the sequence is generated based on the number of equally-spaced points in the given span of numbers.  Additionally, `arange` excludes the stop value while `linspace` includes it.  The difference between these two functions is subtle and the use of one over the other often comes down to user preference or convenience.

```
linspace(start,stop,number of points)
```

Below is an example that shows the usage of `linspace` and `arange`.

```{python}
from numpy import linspace,arange

myArray = linspace(0,10,20)
myArray2 = arange(0,10,0.5)
print(myArray)
print(myArray2)
```


Two other useful functions for generating arrays are `zeros` and `ones` which generate arrays populated with exculsively ones or zeros. The functions require shape arguments as a tuple or list to specify the shape of the array.


```
zeros((rows,columns))
```


If the array to be created is only one dimensional, the argument can be a single number instead of a tuple.

```
zeros(n)
```


```{python}
from numpy import zeros,ones

myArray = zeros([3,4])
myArray2 = ones(5)
print(myArray)
print(myArray2)

```

Arrays of any constant (not just one or zero) can then be easily generated by performing the needed math on the original array.


```{python}
from numpy import zeros,ones

myArray = zeros([3,4]) + 5
myArray2 = ones(5) * 12
print(myArray)
print(myArray2)

```

### Arrays from Functions

A third approach is to generate an array from a function using the `fromfunction` function which generates an array of values using the array indices as the inputs.  Ths function requires two arguments: the name of the function being used and the shape of the array being generated.

```
fromfunction(function, shape)
```

Let's make a 3 x 3 array where each element is the product of the row and column indices:

```{python}
from numpy import fromfunction

def prod(x,y):
    return x * y

myArray = fromfunction(prod,(3,3))
print(myArray)

```


The table below gives a summary of useful functions for creating numpy arrays.  The required arguments are also described.

| Method | Description|
|--------|------------|
| `linspace(start,stop,n)`| Returns an array of `n` evenly-spaced points begining at `start` and ending at `stop`.|
| `arange(start,stop,dx)`| Returns an array begining at `start`,ending at `stop` with a step size of `dx`.|
| `empty(dims)`| Returns an empty array with dimensions `dim`.|
| `zeros(dims)`| Returns an array of zeros with dimensions `dim`.|
| `ones(dims)`| Returns an array of ones with dimensions `dim`.|
| `zeros_like(arr)`| Returns an array of zeros with dimensions that match the dimensions of `arr`.|
| `fromfunction(function,dims)`| Returns an array of numbers generated by evaluating `function` on the indices of an array with dimensions `dims`.|
| `copy(arr)`| Creates a copy of array `arr`.|


## Accessing and Slicing Arrays

Accessing and slicing arrays can be done in exactly the same way as is done with lists. However, there is some additional functionality for accessing and slicing arrays that do not apply to lists.


### One-dimensional Arrays

Elements from a one-dimensional array can be extracted using square brackets (`[]`) just like we have done with lists.

```{python}
from numpy import array

myArray = array([3,4,7,8])
print(myArray[2])
```


### Multi-dimensional Arrays
Multi-dimensional array can be indexed in a similar fashion to nested lists, but because we often encounter multi-dimensional arrays there is a shortcut that makes the syntax simpler and more convenient.  Let's consider a two-dimensional array as an example.  To access the entire second row of the array, provide the row index in square brackets just as with one-dimesional arrays.


```{python}
from numpy import array
myArray = array([[1,2,3],[4,5,6], [7,8,9]])

print(myArray[1])

```


To access the second element *in the second row*, we can add another set of square brackets with the appropriate index inside, just as we did with nested lists.  However, for convenience the second set of square brackets can be omitted and the row and column indices can be placed next to each other and separted by a comma.

```
array_name[row,column]
```

```{python}
from numpy import array
myArray = array([[1,2,3],[4,5,6], [7,8,9]])

print(myArray[1][1])  # This works, but is a bit hard on the eyes
print(myArray[1,1])  # This works also and is easier to look at.

```



### Accessing Multiple Elements

Multiple elements of an array can be accessed using a list for the index instead of a single number.




```{python}
from numpy import array

myArray = array([1,2,3,4,5,6,7,8,9,10])

print(myArray[2])  # Extract element 2
print(myArray[ [3,6,9] ])  # Extract elements 3, 6, and 9.

```

This can even be done with multi-dimensional arrays.  If the index is a single list, the corresponding rows will be extract. If the corresponding list of columns is added to the index list, individual elements will be extracted.

```
array_name[[rows]]  # Access set of rows
```

```
array_name[[rows], [columns]]  # Access set of elements
```

```{python}
from numpy import array
myArray = array([[1,2,3],[4,5,6], [7,8,9]])

print(myArray[[0,1]]) # Extract rows 0 and 1.

print(myArray[[1,2,0],[0,2,2]])   # Extract elements (1,0), (2,2), and (0,2)  
```


## Slicing Arrays

### Multi-dimensional Arrays

We’ve already shown you how to slice a list using the : operator. The same can be done with arrays. However, for 2D (and higher) arrays the slicing is more powerful (intuitive). It can be helpful to visualize an array as a matrix, even if it is not being treated that way Mathematically. For example, let’s say that you define the following array:

```{python}
from numpy import array
myArray = array([[1,2,3],[4,5,6], [7,8,9]])

```

which can be visualized as the following matrix:

$$
\begin{pmatrix}
1&2&3\\
4&5&6\\
7&8&9\\
\end{pmatrix}
$$

To slice out the following $2$ x $2$ sub matrix:


$$
\begin{pmatrix}
5&6\\
8&9\\
\end{pmatrix}
$$

we could do

```{python}
from numpy import array
myArray = array([[1,2,3],[4,5,6], [7,8,9]])

print(myArray[1:3,1:3])
```

To include all of the elements in a given dimension, use the `:` alone with no numbers surrounding it.


```{python}
from numpy import array
myArray = array([[1,2,3],[4,5,6], [7,8,9]])

print(myArray[:,1:3])  # Extract all rows with columns 1 and 2
```


### Boolean Slicing

Boolean operations can be evaluated on arrays to produce corrsponding arrays of booleans.  The boolean array can then be used to index the original array and extract elements that meet some criteria.



```{python}
from numpy import array

a = array([1,2,3,4,5,6])

boolArray = a > 2

print(boolArray)

print(a[boolArray])
```

This also works on multi-dimensional arrays although the result is always one-dimensional regardless of the shape of the original array.

```{python}
from numpy import array
myArray = array([[1,2,3],[4,5,6], [7,8,9]])

print(myArray[myArray>2]) # Extract elements that are greater than 2.

```


## Vectorization and Broadcasting
A major advantage of numpy arrays over lists is that operations *vectorize* across the arrays.  This means that mathematical operations propogate through the array instead of requiring a `for` loop.  This speeds up the calculation and makes code easier to write and read.

### Numpy Functions

The numpy library has a massive collection of vectorized mathematical functions and these functions should be used over similar functions from other libraries that are not vectorized (like `math`).

```{python}
from numpy import array
from numpy import sqrt as nsqrt
from math import sqrt as mathsqrt

squares = array([1,4,9,16,25])

print(nsqrt(squares))
#print(mathsqrt(squares))  #This will fail because it wasn't a numpy function.

```


### Arrays of same Dimensions

If a mathematical operation is performed between two arrays of the same dimensions, the mathematical operation is performed between corresponding elements in the two arrays.  For example, if two $2$ x $2$ arrays are added together, element (0,0) of the first array gets added to the corresponding element in the second and so forth for all elements:

$$
\begin{pmatrix}
1&2\\
3&4\\
\end{pmatrix}+
\begin{pmatrix}
5&6\\
7&8\\
\end{pmatrix}=
\begin{pmatrix}
6&8\\
10&12\\
\end{pmatrix}
$$

```{python}
from numpy import array

a = array([[1,2],[3,4]])
b = array([[5,6],[7,8]])

c = a + b  # Add the elements of the arrays together.
d = a * b  # Multiply the elements of the arrays together.

print(c)
print(d)

```



### Arrays of Different Dimensions
When a mathematical operation between two arrays of different dimensions is attempted, Python has to figure out how to make them have the same shape before performing the operation. *Broadcasting* refers to the set of rules used for operations like this.  To handled arrays with different dimensions, NumPy pads or clones the array with fewer dimensions to make it have the same dimensions as the larger array. For example, what would happen if you attempted this operation:

$$
\begin{pmatrix}
1&2\\
3&4\\
\end{pmatrix}+
\begin{pmatrix}
2&2\\
\end{pmatrix}
$$

One array is $2$ x $2$ and the other is $1$ x $2$.  Before the addition can take place, NumPy clones the smaller array and repeats it until it has the same size as the bigger array.

$$
\begin{pmatrix}
1&2\\
3&4\\
\end{pmatrix}+
\begin{pmatrix}
2&2\\
2&2\\
\end{pmatrix}
$$

```{python}
from numpy import array

a = array([[1,2],[3,4]])
b = array([2,2])
c = a + b

print(c)
```


There are some cases where NumPy simply cannot figure out how to broadcast one of the arrays appropriately and an error results.  When broadcasting, NumPy must verify that all dimensions are compatible with each other. Two dimensions are compatible when i) they are equal or ii) one of the dimensions is 1. For example, if we tried to perform the following mathematical operation, broadcasting would fail because the first dimension of the first array is 2 and the first dimension of the second array is 3.



$$
\begin{pmatrix}
1&2&3\\
3&4&5\\
\end{pmatrix}+
\begin{pmatrix}
1&1&1\\
2&2&2\\
3&3&3\\
\end{pmatrix}
$$

```{python}
#| eval: false
from numpy import array

a = array([[1,2,3],[4,5,6]])
b = array([[1,1,1],[2,2,2],[3,3,3]])
c = a + b
```


but if we attempted

$$
\begin{pmatrix}
1&2&3\\
\end{pmatrix}+
\begin{pmatrix}
1&1&1\\
2&2&2\\
3&3&3\\
\end{pmatrix}
$$

the operation would succeed because the first dimension of the first array is 1.

```{python}
from numpy import array

a = array([1,2])
b = array([[1,1,1],[2,2,2],[3,3,3]])
c = a + b
print(c)
```


### Vectorizing user-defined functions

Standard Python functions are often designed to perform a single calculation rather than iterate over a list to perform many calculations.  For example, here is a function to calculate the average acceleration of an object given its final velocity and time of travel.

```{python}

def accel(velocity, time):
    return velocity / time


print(accel(52.6,5.6))
```

Now what if I have a list of many times that I'd like to feed into this function and get an acceleration value for each one.


```{python}
#| eval: false
def accel(velocity, time):
    return velocity / time


times = [4.6,7.9,3.2,8.5,9.2,4.7]
print(accel(52.6,times))  # Produces an error because you can't divide by a list
```


An error results here because Python does not know how to divide by a list.  We can NumPy-ify this function using a function called `vectorize`.  The resulting function will behave just like the other functions from the NumPy library, vectorizing across the list of times.  



```{python}
from numpy import vectorize
def accel(velocity, time):
    return velocity / time


times = [4.6,7.9,3.2,8.5,9.2,4.7]
vaccel = vectorize(accel)  # Vectorize the function!
print(vaccel(52.6,times))  # Succeeds because NumPy knows how to vectorize.
```


Of course, we also could have just converted our times list into an array and used the original function.


```{python}
from numpy import array
def accel(velocity, time):
    return velocity / time


times = array([4.6,7.9,3.2,8.5,9.2,4.7])
print(accel(52.6,times))  # Succeeds because times is an array not a list.
```



## Manipulating and Modifying Arrays

A wealth of functions exist to perform routine manipulation tasks on arrays once they are created. Often these tasks will involve changing the number of rows or columns or merging two arrays into one.  The *size* and *shape* of an array are the number of elements and dimensions, respectively.  These can be determined using the `shape` and `size` methods.


```{python}
from numpy import array

a = array([[1,2,3],[4,5,6]])
print(a.size)
print(a.shape)
```


### Reshaping Arrays
