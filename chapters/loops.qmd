---
jupyter: python3
reference-location: margin
citation-location: margin
---

# Loops
 _Loops_ allow programs to rerun the same block of code multiple times.  This is important because there are often


## `for` loops

 The `for` loop is probably the most common loop you will encounter and is a good choice when you know beforehand exactly what things you want to loop over.  Here is an example of of `for` loop that is used to add up the elements of a list.

```{python}
thesum = 0
for i in [3,2,1,9.9]: 
    thesum += i
```


 This would be equivalent to the following code:

 ```{python}
 thesum = 0

 thesum = thesum + 3
 thesum = thesum + 2
 thesum = thesum + 1
 thesum = thesum + 9.9
 
 ```

which isn't that much longer than using a loop.  However, as the list gets longer and/or the mathematical operations being performed get more complex the second method would get unreasonably long.
The correct language is to say that we are _iterating_ over the list `[3,2,1,9.9]`.  This
means that the loop variable (`i` in this case but you can choose it to be whatever you want) gets assigned
the values of the list elements, one by one, until it reaches the end
of the list.  You can use `for` loops to iterate over any multi-element object like lists or tuples.  Python uses indentation to indicate
where the loop ends. In this case there was only one statement inside to loop, but if you wanted more than one each line should be indented.  


You can iterate over `range` objects and strings using `for` loops.


```{python}
for i in ['Physics', 'is','so','fun']: # Iterate over a list of strings
    print(i)
```
```{python}
for i in range(5,50,3):  #Generates a list from 5 -> 50 with a step size of 3
    print(i)
```


These examples are so simple that you might wonder when a loop might
actually be useful to you.  Let's see if we can build a loop to
calculate the following sum

$$ \sum_{n=1}^{1000} {1\over n^2}$$ {#eq-sum}

```{python}
theSum = 0
for n in range(1,1000):
    theSum = theSum + 1/n**2
print(theSum)
```
Here, `n` is being assigned the values
`1,2,3,4....1000`, one by one, until it gets all the way to
1000.  Each time through the loop, `n` is different
and the expression `1/n**2` evaluates to a new value.  The
variable `theSum` is updated each time through to be the
running total of all calculations performed thus far.  Here's another
example of a loop used to calculate the value of $20!$:

```{python}
theProduct = 1
for n in range(1,21):
    theProduct = theProduct * n #Multiply theProduct by n
print(theProduct)
```

Remember that the range function creates a list starting at $1$, going
up to $21$ but not including it. The math library has a function
called `factorial` that does the same thing.  Let's use it to
check our answer:

```{python}
from math import factorial
factorial(20)
```

### Boolean Logic Inside Loops
Often when using loops, we only want a block of code to execute when some condition is satisfied.
We can use boolean logic inside of the loop to accomplish this. For example, let's write a loop to compute the following sum:

$$ \sum_{{n\over 5} \in \text{ Int and } {n\over 3} \in \text{ Int}} {1\over n^2} $$

which is similar to the one we did above, but this time  we only want to include terms where $n$ is a perfect multiple of both 5 and 3. To check to see if `n` is a perfect multiple of a number we can calculate the modulo (remainder after division) using the `%` operator and check that it is equal to zero.

```{python}
theSum = 0
for n in range(1,1000):
    if n % 5 == 0 and n % 3 == 0:
        theSum = theSum + 1/n**2
print(theSum)
```


### Zipping and Enumerating

There are times when it is necessary to iterate over two lists simultaneously.  For example, let us say that we have a list of atomic numbers (`AN`) and a list of approximate atomic masses (`mass`) of the most abundant isotopes for the first six elements on the periodic table.


```
AN = [1,2,3,4,5,6]
mass = [1,4,7,9,11,12]
```

If we want to calculate the number of neutrons in each isotope, we need to subtract each atomic number from the atomic mass.  To accomplish this, it would be nice to iterate over both lists simultaneously


#### Zipping

The simplest way to iterate over two lists simultaneously is to combine both lists into a single, iterable object and iterate over it once.  The `zip` function does just that by merging two lists  or tuples into a nested list


```{python}
AN = [1,2,3,4,5,6]
mass = [1,4,7,9,11,12]

zipped = zip(AN,mass)

for pair in zipped:
    print(pair[1] - pair[0])

```

The zip objects are "single use" so you can't reuse `zipped` in a later loop.  If the two lists being zipped are not the same length, `zip` stops zipping when it reaches the end of the shorter list.


#### Enumeration

A close relative to `zip` is `enumerate` which zips a list to _the index value for that list_ (read that last statement again).  It also returns a "single use" object that can be iterated over.
```{python}
AN = [1,2,3,4,5,6]
mass = [1,4,7,9,11,12]

enum = enumerate(mass)

for idx,val in enum:
    print(val - AN[idx])

```




### List Comprehension

It is fairly common to use a `for` loop to populate a list with a sequence of numbers.  


```{python}
myList = []

for i in range(10):
    myList.append(i**2)

print(myList)

```

This entire process can be compressed down into a single line by expressing the `for` loop in square brackets. This is known as *list comprehension*. The code below will generate the list as above.


```{python}

myList = [i**2 for i in range(10)]
print(myList)
```


List comprehension can take a little time to get used to but it is well worth it.  It saves both time and space and makes code less cluttered.  You can even add boolean expressions to your conditionals for further control of the final result.


```{python}

myList = [i**2 for i in range(10) if i %2 == 0]  # Include only the evens.
print(myList)
```



## `while` Loops

Logic can be combined with loops using something called a
`while` loop.  A `while` loop is a good choice when you
don't know beforehand exactly how many iterations of the loop will be
executed but rather want the loop to continue to execute until some
condition is met.  As an example, notice that in @eq-sum, the terms in the sum get progressively smaller as $n$ gets bigger.  It doesn't make sense to continue adding to the sum once the terms get very small.  Let's compute this sum
by looping until the fraction ${1 \over n^2}$  become smaller than $1 \times 10^{-10}$.

```{python}
term = 1  # Load the first term in the sum
s = term  # Initialize the sum
n = 1     # Set a counter
while term > 1e-10:  # Loop while term is bigger than 1e-10
    n = n +  1        #Add 1 to n so that it will count: 2,3,4,5
    term = 1./n**2    # Calculate the next term to add
    s = s +  term     # Add 1/n^2 to the running total
```

This loop will continue to execute until `term<1e-10`. Note
that unlike the `for` loop, here you have to do your own counting if you need to know how many iterations have been performed. Be
careful about what value `n` starts at and when it is incremented
(`n = n + 1`). Also notice that `term` must be assigned
prior to the start of the loop.  If it wasn't the loop's first logical
test would fail and the loop wouldn't execute at all.

`while` loops should be used with caution because you can easily write a *faulty termination condition* and inadvertently write a loop that runs forever.  This happens because your termination condition was never met.  An example of this is given below.


Warning: Do not execute the code block below!!
```{python}
#| eval: false
x = 0

while x != 10:
    x = x + 3
print("Done")

```
 The loop above is intended to end after a few iterations when the value of x is equal to 10.  However, closer inspection reveals that the value of x will never be equal to 10.  After the first iteration x is equal to 3, then 6,9,12,15 and so on... but never 10.  This loop will run forever because the termination condition is never met (`x != 10` never produces a `False`)!!  If you choose to use a `while` loop, triple check your termination condition to make sure you haven't made a mental error.  Avoiding the use of `!=` or `==` in your termination condition will help too.  Use `<=` or `>=` instead.


## `continue`, `break`, and `pass` Commands

The `continue`, `break`, and `pass` commands are used to control the flow of code execution in loops.  Here is a description of their usage:


| Operator | Description |
| -------- | ----------- |
| `break`      | Exits a `for`/`while` loop.|
| `continue`      | Skips the remaining loop block and begins the next iteration.|
| `pass`      | No action; code contiues on|

 
 
  The `break` statement is useful when you want to completely stop a loop early.  Here is our sum loop rewritten with a `break` statement added to stop the loop after 1000 iterations.

```{python}
term = 1  # Load the first term in the sum
s = term  # Initialize the sum
n = 1     # Set a counter
while term > 1e-10:  # Loop while term is bigger than 1e-10
    n +=  1        #Add 1 to n so that it will count: 2,3,4,5
    term = 1./n**2    # Calculate the next term to add
    s += term     # Add 1/n^2 to the running total
    if n > 1000:
        print('This is taking too long. I''m outta here...')
        break
```

The `continue` statement is similar to `break` except that instead of stopping the loop, it only stops the current iteration of the loop.  All code below the `continue` statement will be skipped and the next iteration will begin.
For example, if you wanted to do
the sum from equation ?? but only include those terms for
which n is a multiple of 3, it could be done like this:

```{python}
term = 1  # Load the first term in the sum
s = term  # Initialize the sum
n = 1     # Set a counter
while term > 1e-10:  # Loop while term is bigger than 1e-10
    n +=  1        #Add 1 to n so that it will count: 2,3,4,5
    if n % 3 != 0:
        continue
    term = 1./n**2    # Calculate the next term to add
    s += term     # Add 1/n^2 to the running total
```
Now, when the value of `n` is not a multiple of 3, the sum will not be
updated and the associated terms are effectively skipped.
 

Finally, the `pass` statement does nothing.  Seriously!!  It is merely a place holder for code that has not bee written yet.  Usually, you'll use the `pass` statement to run and test code without errors due to missing code.  


## Flash Cards
1. Explain the basic structure and key elements of a `for` loop.
2. Explain the basic structure and key elements of a `while` loop.
3. What does the `break` statement do?
4. What does the `continue` statement do?
5. What does the `pass` statement do?
6. What does the `zip` function do? Give an example.
7. What does the `enumerate` function do? Give an example.
8. What is list comprehension? Give an example.

## Exercises

1. Summations appear often in science and mathematics.  One such summation is called the Riemann Zeta function and is given by $$ \zeta(n) = \sum_{k=1}^\infty {1\over k^n} = {1\over 1^n} + {1\over 2^n} + {1\over 3^n} + \dots$$

    1. Use a `for` loop to evaluate $\zeta(2)$ and $\zeta(4)$ and verify that $\zeta(2) = {\pi^2 \over 6}$ and $\zeta(4) = {\pi^4 \over 90}$.  This summation is called an infinite sum and we surely don't want our loop to continue forever!! Instead, an infinite sum like this one can be approximated by including a large number of terms.  To determine if you have included enough terms, increase the number of terms steadily and watch for the final result to stop changing appreciably.
    2. Now repeat part 1 using list comprehension and the `sum` function?
    3. Repeat the exercise one final time using a `while` loop.  Write the `while` loop so that it stops iterating when the value of ${1\over k^n}$ gets smaller than $1 \times 10^{-6}$.
    4. Which method do you prefer?


```{python}
#| eval: true

from math import pi

n = 4
seq= [1/k**n for k in range(1,1000)]

print(sum(seq))
print(pi**4/90)
```


2. A transcendental equation is one that cannot be solved analytically (with pencil and paper). Try solving the following equation for x to see what I mean: $$ {\sin x \over x} = 1$$  One numerical method for solving an equation like this involves first rearranging it to look like this: $$ x = \sin x$$ and then repeatedly evaluating the right hand side, using the result of the previous evaluation, until subsequent evaluations differ very little ($1 \times 10^{-3}$ would be fine). [^relax] Use a `while` loop to solve this equation and report the correct value for x.  Then plug the answer back into the equation to verify that it indeed does satisfy the equation.
Hint: You'll have to define two variables: one to hold the old guess and one to hold the updated guess.  Initialize these variables to any old values but make sure that they aren't the same value or your stopping criteria will trigger on the first iteration and the loop won't run at all.


```{python}
#| eval: false
from math import sin
xnew = 2
xold = 1

while abs(xnew - xold) > 1e-3:
    xold = xnew
    xnew = sin(xold)

    
print(xnew)
print(sin(xnew))

```
[^relax]: This is called successive relaxation.


3. An object that is dropped from a high altitude and allowed to fall through the air will experience a drag force that is opposite its motion.  Because of that drag force, the velocity of the particle will not increase forever, but instead approach a constant velocity (terminal velocity).  The function that describes the velocity of the particle as a function of time is given by

$$ v(t) = -{mg \over c} + \left( {m g \over c} + v_0\right) e^{-c t \over m}$$

and the terminal velocity is given by

$$v_t = \sqrt{m g \over c}$$

where $m$ is the mass of the projectile, $c$ is the drag constant, $g= 9.8$ m/s$^2$ is the acceleration due to gravity, $v_0$ is the initial velocity of the particle, and $t$ is time. 

```{python}
from math import exp
m = 2
g = 9.8
c = 0.75
v0=0

v = []
t = 0
dt = 0.5
while t < 10:
    v.append(-m * g / c + (m * g /c + v0) * exp(-c * t/m))
    t += dt

print(v)
```